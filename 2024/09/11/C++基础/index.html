<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C++基础 | Matrix's blog</title><meta name="keywords" content="C++"><meta name="author" content="Matrix"><meta name="copyright" content="Matrix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++基础"><meta name="application-name" content="C++基础"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C++基础"><meta property="og:url" content="http://blog.zymatrix.top/2024/09/11/C++%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="Matrix's blog"><meta property="og:description" content="学习思路 学习误区   太注重C++语言本身 喜欢量化学习的程度 太注重方向，做出的项目不通用，错失offer   学习思路   做的项目要有产品化的思维 需要开箱即用   多长时间，换工作   一年半：应届生，前半年学生转为职场人士，经过半年能独立做开发  之前没有系统性的从头开始学习C++，因此"><meta property="og:locale" content="zh-CN"><meta property="og:image" content=""><meta property="article:author" content="Matrix"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content=""><meta name="description" content="学习思路 学习误区   太注重C++语言本身 喜欢量化学习的程度 太注重方向，做出的项目不通用，错失offer   学习思路   做的项目要有产品化的思维 需要开箱即用   多长时间，换工作   一年半：应届生，前半年学生转为职场人士，经过半年能独立做开发  之前没有系统性的从头开始学习C++，因此"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://blog.zymatrix.top/2024/09/11/C++%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Matrix","link":"链接: ","source":"来源: Matrix's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Matrix's blog',
  title: 'C++基础',
  postAI: '',
  pageFillDescription: '学习思路, C++基础, 基本特性, 程序执行过程, const关键字, auto关键字, 静态变量 指针 引用, 左右值, move函数, 临时对象：, 可调用对象, 1. 函数：, 2. 仿函数：, 3. lambda表达式：, 类, this常成员函数与常对象, 一些关键字, 重载运算符, 继承, 虚函数, RTTI, 移动构造函数与移动赋值运算符, 智能指针, shared_ptr, weak_ptr, unique_ptr, 模板与泛型编程, 模板介绍类模板与模板实现原理, initializer_list与typename, 模板的重载全特化和偏特化, STL, 简介, 容器, IO库, 介绍, 注意事项, 内存输入输出设备的交互（iostream）, 内存与磁盘的交互（fstream）, 内存之中对于字符串的操作（sstream）, 多线程, 1. 多线程基本概念介绍, 2.线程的创建, 3.传递线程参数, 4.线程id的概念：, 5. 数据共享与数据保护, 6. 死锁, 异常处理, 1. 异常处理的介绍：, 2. C++的标准异常, 各种难以归类但有使用价值的知识点, 1. 万能引用与引用折叠, 2. 完美转发学习思路学习误区太注重语言本身喜欢量化学习的程度太注重方向做出的项目不通用错失学习思路做的项目要有产品化的思维需要开箱即用多长时间换工作一年半应届生前半年学生转为职场人士经过半年能独立做开发之前没有系统性的从头开始学习因此此博客仅用于记录快速系统学习语法知识基础基本特性程序执行过程程序被执行后就被称为一个进程一个进程可以被划分为很多区域这门课我们只需要理解以下的四个区就可以了代码区与常量区进程按照代码区的代码执行真正的常量也存储在这里比如字符串等数字这些是真正的常量再看一下关键字只不过是让编译器将变量视为常量罢了和真正的常量有本质上的区别栈区函数的执行所需的空间注意当函数执行完毕函数对应的栈内存全部销毁堆区进程用来灵活分配内存的地方只有手动释放时才会销毁内存静态变量区用来存储静态变量与全局变量的区域静态变量常常需要一些局部作用范围生命周期却很长的变量全局变量重要性就不必说了在语言程序中经常用到但在中不推荐使用因为会破坏封装性具体的存储方式如图所示堆区和栈区是程序运行的主要地方至于堆区主要意义在于灵活的生命周期如果需要创建的对象有几十每次调用函数都需要创建一个这么大的对象再复制到对应的容器中那就太过耗费内存了而且栈内存非常的小通常不超过而使用堆内存每调用一次函数就可以在堆内存中创建一个对象容器中只要存储指针就可以了极大的提高了程序效率而静态变量区有很多情况下我们需要作用范围局限在函数之内但生命周期却很长的变量比如统计一个函数被调用的次数总结栈区是函数执行的区域堆区是函数内灵活分配内存的地方二者缺一不可为什么不能只在栈上运行程序因为当函数运行结束时栈是要销毁的其上分配的内存全部失效也不能只在堆上运行程序因为堆的唯一寻址方式就是指针如果没有栈根本无法使用堆栈区远远小于堆区一般不超过所以主要的内容都在对堆区上堆区很大虚拟内存剩下的都是堆区关键字关键字介绍是让编译期将变量视为常量用修饰的变量和真正的常量有本质的区别真正的常量存储在常量区或代码区比如这个字符串就存储在常量区而这些数字就存储在代码区中这些都是真正的常量无法用任何方式修改修饰的变量仍然存储在堆区或栈区中从内存分布的角度讲和普通变量没有区别修饰的变量并非不可更改的本身就提供了关键字用来修改修饰的变量从汇编的角度讲修饰的变量也是可以修改的关键字是新加入的关键字就是为了简化一些写法使用推断类型确实简单方便但有个基本要求就是在使用时清楚的知道编译器会给推断出什么类型需要注意以下几点只能推断出类型引用不是类型所以无法推断出引用要使用引用只能自己加引用符号关键字在推断引用的类型时会直接将引用替换为引用指向的对象其实引用一直是这样的引用不是对象任何使用引用的地方都可以直接替换成引用指向的对象关键字在推断类型时如果没有引用符号会忽略值类型的修饰而保留修饰指向对象的典型的就是指针关键字在推断类型时如果有了引用符号那么值类型的和修饰指向对象的都会保留其实为什么会出现这种情况因为在传递值时修改这个值并不会对原有的值造成影响而传递引用时修改这个值会直接对原有的值造成影响当然我们可以在前面加上这样永远都有的含义不会影响编译速度甚至会加快编译速度因为编译器在处理时当是传统类型时编译期需要检查的类型是否可以转化为当为时编译期可以按照的类型直接给定变量的类型所以效率相差不大甚至反而还有提升不要滥用对于一些自己不明确的地方不要乱用否则很可能出现事与愿违的结果使用类型应该安全为先主要用在与模板相关的代码中一些简单的变量使用模板常常导致可读性下降经验不足还会导致安全性问题静态变量指针引用变量的存储位置有三种分别是静态变量区栈区堆区静态变量区在编译时就已经确定地址存储全局变量与静态变量指针都是存储在栈上或堆上不管在栈上还是堆上都一定有一个地址本质上说指针和普通变量没有区别在位系统中变量和指针都是位指针必须和这两个符号一起使用才有意义代表的这个变量的地址代表的对应地址存储的值代表对应地址存储的值作为地址对应的值所以指针才可以灵活的操作内存但这也带来了严重的副作用比如指针加加减减就可以操作内存所以引用被发明了引用就是作用阉割的指针可以视为类型所以引用必须上来就赋初值不能设置为空编译器不将其视作对象操作引用相当于操作引用指向的对象也就从根本是杜绝了引用篡改内存的能力左右值左值右值从开始就是一个很重要的概念了但想要真正理解左值右值不是一件容易的事任何一个对象要么是左值要么是右值比如和都是对象左值拥有地址属性的对象就叫左值左值来源于语言的说法能放在左面的就是左值注意左值也可以放在右面右值不是左值的对象就是右值或者说无法操作地址的对象就叫做右值一般来说判断一个对象是否为右值就看它是不是左值有没有地址属性不是左值那就是右值比如临时对象就都是右值临时对象的地址属性无法使用注意左值也可以放在右面但右值绝对不可以放在等号左面接下来就是大量举例了说明那些是左值哪些是右值比如是对自增然后返回是左值是先复制一个返回临时对象再自增是右值引用分类普通左值引用就是一个对象的别名只能绑定左值无法绑定常量对象左值引用可以对常量起别名可以绑定左值和右值右值引用只能绑定右值的引用万能引用函数右值看重对象的值而不考虑地址函数可以对一个左值使用使操作系统不再在意其地址属性将其完全视作一个右值函数让操作的对象失去了地址属性所以我们有义务保证以后不再使用该变量的地址属性简单来说就是不再使用该变量因为左值对象的地址是其使用时无法绕过的属性临时对象右值都是不体现地址的对象那么还有什么能比临时对象更加没有地址属性呢右值引用主要负责处理的就是临时对象程序执行时生成的中间对象就是临时对象注意所有的临时对象都是右值对象因为临时对象产生后很快就可能被销毁使用的是它的值属性可调用对象如果一个对象可以使用调用运算符里面可以放参数这个对象就是可调用对象可调用对象的分类函数函数自然可以调用运算符是最典型的可调用对象仿函数具有函数的类对象此时类对象可以当做函数使用因此称为仿函数表达式就是匿名函数普通的函数在使用前需要找个地方将这个函数定义于是提供了表达式需要函数时直接在需要的地方写一个表达式省去了定义函数的过程增加开发效率表达式的格式最少是完整的格式为各个组件介绍代表捕获列表表示表达式可以访问前文的哪些变量表示不捕获任何变量表示按值捕获所有变量表示按照引用捕获所有变量也可以混合使用比如表示变量用引用传递除的所有变量用值传递表示变量用值传递除的所有变量用引用传递当然也可以捕获单独的变量表示以值传递的形式捕获表示以引用传递的方式捕获代表表达式的参数函数有参数自然也有表示指定的返回值如果不指定表达式也会推断出一个返回值的就是函数体了和普通函数的函数体功能完全相同的可调用对象主要就这三个当然这三个也可以衍生出很多写法最常见的就是函数指针函数指针的本质就是利用指针调用函数本质还是函数在当中引入了可以起到和函数指针一样的效果使用函数可以在为调用的函数时捕获变量函数指针要细分也可以分为指向类成员函数的指针指向普通函数的指针类常成员函数与常对象关键字是什么编译器将解释为指向函数所作用的对象的指针类的本质就是语言的结构体外加几个类外的函数最后都要转化为语言来实现类外的函数就是通过来指向这个类的当然这么说并非完全准确是一个关键字只是我们将它当做指针理解罢了有很多功能是单纯的指针无法满足的比如每个类函数的参数根本没有名叫的指针这不过是编译器赋予的功能罢了常成员函数和常对象常成员函数和常对象很多人并不在意确实都写普通变量也可以但是在大型程序中尽量加上关键字可以减少很多不必要的错误关键字含义这里说一下常成员函数和常对象常成员函数就是无法修改成员变量的函数可以理解为将指针指向对象用修饰的函数常对象就是用修饰的对象定义好之后就再也不需要更改成员变量的值了常对象在大型程序中还是很有意义的常成员函数注意事项因为类的成员函数已经将指针省略了只能在函数后面加关键字来实现无法修改类成员变量的功能了注意常函数无法调用了普通函数否则常函数的这个常字还有什么意义成员函数能写作常成员函数就尽量写作常成员函数可以减少出错几率同名的常成员函数和普通成员函数是可以重载的常量对象会优先调用常成员函数普通对象会优先调用普通成员函数常对象注意事项常对象不能调用普通函数常函数在大型程序中真的很重要很多时候我们都需要创建好就不再改变的对象总结常成员函数和常对象要多用这真的是一个非常好的习惯写大项目可以少出很多一些关键字关键字关键字的有什么作用在函数声明或定义中函数返回类型前加上关键字就可以把函数指定为内联函数关键字必须与函数定义放在一起才能使函数成为内联仅仅将放在函数声明前不起任何作用内联函数的作用普通函数在调用时需要给函数分配栈空间以供函数执行压栈等操作会影响成员运行效率于是提供了内联函数将函数体放到需要调用函数的地方用空间换效率关键字的注意事项关键字只是一个建议开发者建议编译器将成员函数当做内联函数一般适合搞内联的情况编译器都会采纳建议关键字的总结使用关键字就是一种提高效率但加大编译后文件大小的方式现在随着硬件性能的提高关键字用的越来越少了关键字关键字的作用意为可变的与相对被修饰的成员变量永远处于可变的状态即便处于一个常函数中该变量也可以被更改这个关键字在现代中使用情况并不多一般来说只有在统计函数调用次数时才会用到关键字的注意事项是一种万不得已的写法一个程序不得不使用关键字时可以认为这部分程序是一个糟糕的设计不能修饰静态成员变量和常成员变量总结关键字是一种没有办法的办法设计时应该尽量避免只有在统计函数调用次数这类情况下才推荐使用这个关键字也称不上是重点关键字关键字的作用关键字的作用很简单在编译时不会生成默认构造函数时便于书写也可以对默认复制构造函数默认的赋值运算符和默认的析构函数使用表示使用的是系统默认提供的函数这样可以使代码更加明显现代中哪怕没有构造函数也推荐将构造函数用关键字标记可以让代码看起来更加直观方便总结关键字还是推荐使用的在现代代码中如果需要使用一些默认的函数推荐用标记出来关键字关键字的作用会为程序生成默认构造函数默认复制构造函数默认重载赋值运算符重载部分会详细讲解在很多情况下我们并不希望这些默认的函数被生成在以前只能有将此函数声明为私有函数或是将函数只声明不定义两种方式于是提供了关键字只要在函数最后加上就可以明确告诉编译期不要默认生成该函数总结关键字还是推荐使用的在现代代码中如果不希望一些函数默认生成就用表示这个功能还是很有用的比如在单例模式中重载运算符重载运算符在整个中拥有非常重要的地位这一节非常重要重载运算符的作用很多时候我们想让类对象也能像基础类型的对象一样进行作基础操作比如也可以使用某些运算符但是一般的类即使编译器可以识别这些运算符类对象也无法对这些运算符做出应对我们必须对类对象定义处理这些运算符的方式提供了定义这些行为的方式就是运算符来定义运算符的行为是一个关键字告诉编译器我要重载运算符了注意我们只能重载已有的运算符所有无法将这个运算符定义为指数的形式因为根本没有这个运算符重载运算符不能改变运算符的元数元数这个概念就是指一个运算符对应的对象数量比如必须为也就是说必须有两个对象那么就是二元运算符比如运算符必须写为也就是一元运算符重载运算符举例一元运算符重载二元运算符重载至于唯一的三元运算符不能重载类类型转化运算符类型特殊的运算符注意类会默认进行重载如果不需要可以用关键字进行修饰总结重载运算符非常重要类中几乎都要定义各种各种的重载运算符继承继承介绍非继承的类相互是没有关联性的假设现在需要设计医生教师公务员三个类需要定义很多重复的内容而且相互没有关联调用也没有规律如果这还算好那一个游戏有几千件物品调用时也要写几千个函数这太要命了于是继承能力就应运而生了继承原理的继承可以理解为在创建子类成员变量之前先创建父类的成员变量实际上语言就是这么模仿出继承功能的继承的注意事项子类对象的构造过程先调用父类的构造函数再调用子类的构造函数也就是说先初始化父类的成员再初始化子类的成员若父类没有默认的构造函数子类的构造函数又未调用父类的构造函数则无法编译子类对象的析构过程先调用父类的析构函数再调用子类的析构函数总结面向对象三大特性的继承就这么简单很多人觉得类继承很复杂其实完全不是这样的只要明白子类在内存上其实就相当于把父类的成员变量放在子类的成员变量前面罢了构造和析构过程也是为了这个机制而设计的虚函数虚函数介绍虚函数就是面向对象的第三大特点多态多态非常的重要它完美解决了上一课设计游戏装备类的问题我们可以只设计一个函数函数参数是基类指针就可以调用子类的功能比如射击游戏所有的枪都继承自一个枪的基类人类只要有一个开枪的函数就可以实现所有枪打出不同的子弹父类指针可以指向子类对象这个是自然而然的因为子类对象的内存前面就是父类成员类型完全匹配当父类指针指向子类对象且子类重写父类某一函数时父类指针调用该函数就会产生以下的可能该函数为虚函数父类指针调用的是子类的成员函数该函数不是虚函数父类指针调用的是父类的成员函数虚函数的注意事项子父类的虚函数必须完全相同为了防止开发人员一不小心将函数写错于是添加了关键字父类的析构函数必须为虚函数这一点很重要当父类对象指向子类对象时容易使独属于子类的内存泄露会造成内存泄露的严重问题关键字的作用前面已经说过了为了防止开发人员将函数名写错了加入了关键字虚函数实现多态的原理介绍动态绑定和静态绑定静态绑定程序在编译时就已经确定了函数的地址比如非虚函数就是静态绑定动态绑定程序在编译时确定的是程序寻找函数地址的方法只有在程序运行时才可以真正确定程序的地址比如虚函数就是动态绑定虚函数是如何实现动态绑定的呢每个有虚函数的类都会有一个虚函数表对象其实就是指向虚函数表的指针编译时编译器只告诉了程序会在运行时查找虚函数表的对应函数每个类都会有自己的虚函数表所以当父类指针引用的是子类虚函数表时自然调用的就是子类的函数总结虚函数是类的重要特性之一很简单但使用频率非常高至于如何实现的也要掌握介绍即通过运行时类型识别程序能够通过基类的指针或引用来检查这些指针或引用所指向的对象的实际派生类为了支持多态的指针或引用的类型可能与它实际指向对象的类型不相同这时就需要去判断类的实际类型了是判断指针或引用实际类型的唯一方式的使用场景可能有很多人会疑惑的作用所以单独拿出来说一下异常处理这是最主要的使用场景具体作用在异常处理章节会详细讲解操作具体作用等到章节会详细讲解的使用方式的使用过程就两个函数函数函数返回的一个叫做的结构体该结构体包括了所指向对象的实际信息其中函数就可以返回函数的真实名称结构体其他函数没什么用函数提供的将父类指针转化为子类指针的函数的注意事项当使用函数时父类和子类必须有虚函数父类有了虚函数子类自然会有虚函数否则类型判断会出错总结就是在运行阶段判断对象实际类型的唯一方式移动构造函数与移动赋值运算符对象移动的概念对一个体积比较大的类进行大量的拷贝操作是非常消耗性能的因此中加入了对象移动的操作所谓的对象移动其实就是把该对象占据的内存空间的访问权限转移给另一个对象比如一块内存原本属于在进行移动语义后这块内存就属于了移动语义为什么可以提高程序运行效率因为我们的各种操作经常会进行大量的复制构造赋值运算操作这两个操作非常耗费时间移动构造是直接转移权限这是不是就快多了注意在进行转移操作后被转移的对象就不能继续使用了所以对象移动一般都是对临时对象进行操作因为临时对象很快就要销毁了注意这里的右值引用不能是的因为你用右值引用函数参数就算为了让其绑定到一个右值上去的就是说这个右值引用是一定要变的但是你一旦加了就没法改变该右值引用了默认移动构造函数和默认移动赋值运算符会默认生成移动构造函数和移动赋值运算符的条件只有一个类没有定义任何自己版本的拷贝操作拷贝构造拷贝赋值运算符且类的每个非静态成员都可以移动系统才能为我们合成可以移动的意思就是可以就行移动构造移动赋值所有的基础类型都是可以移动的有移动语义的类也是可以移动的智能指针为什么要有智能指针直接使用和运算符极其容易导致内存泄露而且非常难以避免于是人们发明了智能指针这种可以自动回收内存的工具智能指针一共就三种普通的指针可以单独一个指针占用一块内存也可以多个指针共享一块内存共享型智能指针同一块堆内存可以被多个共享独享型智能指针同一块堆内存只能被一个拥有弱引用智能指针也是一种共享型智能指针可以视为对共享型智能指针的一种补充智能指针和裸指针不要混用的工作原理我们在动态分配内存时堆上的内存必须通过栈上的内存来寻址也就是说栈上的指针堆上的指针也可以指向堆内存但终究是要通过栈来寻址的是寻找堆内存的唯一方式所以我们可以给堆内存添加一个引用计数有几个指针指向它它的引用计数就是几当引用计数为是操作系统会自动释放这块堆内存常用操作初始化使用运算符初始化一般来说不推荐使用进行初始化因为标准提供了专门创建的函数该函数是经过优化的效率更高使用函数进行初始化注意千万不要用裸指针初始化容易出现内存泄露的问题当然使用复制构造函数初始化也是没有问题的的引用计数智能指针就是通过引用计数来判断释放堆内存时机的函数可以得到对象的引用计数智能指针可以像普通指针那样使用早已对各种操作进行了重载就当它是普通指针就可以了的常用函数函数判断该对象是否独占若独占返回否则返回函数当函数有参数时改变此对象指向的内存当函数无参数时将此对象置空也就是将对象内存的指针设置为函数强烈不推荐使用如果一定要使用那么一定不能返回的指针函数交换两个智能指针所指向的内存命名空间中全局的函数类提供的函数关于智能指针创建数组的问题用智能指针作为参数传递时直接值传递就可以了的大小为固定的或字节也就是两倍指针的的大小位系统指针为个字节位系统指针为个字节中就两个指针所以直接值传递就可以了总结在现代程序中当想要共享一块堆内存时优先使用可以极大的减少内存泄露的问题介绍这个智能指针是在的时候引入的标准库它的出现完全是为了弥补天生有缺陷的问题其实可以说近乎完美只是通过引用计数实现的方式也引来了引用成环的问题这种问题靠它自己是没办法解决的所以在的时候将和一起引入了标准库用来解决循环引用的问题的循环引用问题的作用原理的对象需要绑定到对象上作用原理是不会改变对象的引用计数只要对象的引用计数为就会释放内存的对象不会影响释放内存的过程的总结使用较少就是为了处理循环引用问题而设计的介绍独占式智能指针在使用智能指针时我们一般优先考虑独占式智能指针因为消耗更小如果发现内存需要共享那么再去使用的初始化和完全类似使用运算符进行初始化使用函数进行初始化的常用操作禁止复制构造函数也禁止赋值运算符的重载否则独占便毫无意义允许移动构造移动赋值移动语义代表之前的对象已经失去了意义移动操作自然不影响独占的特性函数不带参数的情况下释放智能指针的对象并将智能指针置空带参数的情况下释放智能指针的对象并将智能指针指向新的对象将的对象转化为对象当的对象为一个右值时就可以将该对象转化为的对象这个使用的并不多需要将独占式指针转化为共享式指针常常是因为先前设计失误注意对象无法转化为对象模板与泛型编程模板介绍类模板与模板实现原理模板的介绍模板能够实现一些其他语法难以实现的功能但是理解起来会更加困难容易导致新手摸不着头脑模板分为类模板和函数模板函数模板又分为普通函数模板和成员函数模板类模板基础类模板的写法与使用十分固定模板的实现原理模板需要编译两次在第一次编译时仅仅检查最基本的语法比如括号是否匹配等函数真正被调用时才会真正生成需要的类或函数所以这直接导致了一个结果就是不论是模板类还是模板函数声明与实现都必须放在同一个文件中因为在程序在编译期就必须知道函数的具体实现过程如果实现和声明分文件编写需要在链接时才可以看到函数的具体实现过程这当然会报错于是人们发明了文件来存放模板这种声明与实现在同一文件的情况与的用法介绍其实就是初始化列表我们可以用初始化列表初始化各种容器比如数组的用法在定义模板时表示这个一个待定的类型在类外表明自定义类型时使用在的早期版本为了减少关键字数量用来表示模板的参数但是后来因为第二个原因不得不引入关键字模板的重载全特化和偏特化模板的重载函数模板是可以重载的类模板不能被重载通过重载可以应对更加复杂的情况比如在处理和对象时虽然都可以代表字符串但在复制时直接拷贝内存效率明显更高就不得不依次调用构造函数了所以在一些比较最求效率的程序中对不同的类型进行不同的处理还是非常有意义的其实函数模板的重载和普通函数的重载没有什么区别模板的特化模板特化的意义函数模板可以重载以应对更加精细的情况类模板不能重载但可以特化来实现类似的功能模板的特化也分为两种全特化和偏特化模板的全特化就是指模板的实参列表与与相应的模板参数列表一一对应模板的偏特化偏特化就是介于普通模板和全特化之间只存在部分类型明确化而非将模板唯一化其实对于函数模板来说特化与重载可以理解为一个东西简介的介绍就是的简称定义在命名空间中定义了常用的容器与算法等极大的提高了我们的程序开发效率在开发中可以说不会用的人会用但不懂实现原理的人既会使用又懂得实现原理的人是完完全全的三个档次泛型编程的概念用模板进行编程可以实现一些其它方式难以实现的功能但对于新手来说泛型编程可能会难以理解摸不着头脑也就是说模板是学习泛型编程的基础注意泛型编程不属于面向对象编程的范畴泛型编程和面向对象编程是并列的作为泛型编程的最典型代表它实现了其它编程方式难以实现的效果比如将整个模板库分为六个部分每个部分可以单独设计举个最简单的例子和在数据结构方面完全不一样但可以设计出迭代器这个模块让该模块可以在不同的数据结构中按照同样的方式运行这种技术没有泛型编程是难以实现的学习的注意事项学习一定要有全局观念不要局限于单个容器重点在于明白六大组件之间的联系当然如果只是单纯为了应付当前的业务单独学一下某个容器的用法也没有问题的六大容器介绍容器是一种数据结构也就是真正用来存储数据的地方分为三类顺序式容器关联式容器无序式容器其实无序式容器也是一种关联式容器但是既然标准委员会将无序容器与关联式容器平行的列了出来那么我们这里也就让无序式容器和关联式容器平行吧迭代器提供了可以访问任何容器的方法算法用来操作容器中的数据的模板函数仿函数适配器分配器容器顺序容器每个元素都有固定的位置位置取决于插入时间和地点与元素的值无关将元素置于一个动态数组中可以随机存储元素也就是用索引直接存取数组尾部添加或删除元素非常迅速但在中部或头部就比较费时的缩写也就是双端队列的实现相比于有些复杂但本质仍然是优化过的动态数组只不过相比于单纯的动态数组在前面添加或删除元素非常快了可以随机存储元素头部和尾部添加或删除元素都非常快略慢与但在中间插入元素比较费时和差不多本质就是链表所以自然具有了链表的属性不能随机存取元素也就是无法用索引存取元素在任何位置插入和删除元素都比较迅速在任何位置插入删除元素的时间相同在元素头部操作慢于在元素尾部操作慢于和把普通字符串封装了一下单项链表简单来说就是受限的凡是不支持的功能它都不支持做各种支持的操作效率都会高于最典型的就排序算法了要优于只提供前向迭代器而不是双向迭代器因此它也不支持反向迭代器不提供成员函数没有指向最末元素的锚点基于这个原因不提供用以处理最末元素的成员关联容器元素位置取决于元素的值和插入顺序无关使用红黑树实现是一种高度平衡的二叉树如果大家不了解红黑树可以去百度一下了解个大概就可以了二叉树的本质决定了的元素存取值取决于元素本身的值和插入顺序无关内部元素的值依据元素的值自动排列与插入顺序无关内部相同数值的元素只能出现一次内部相同数值的元素可出现多次容器用二叉树实现便于查找使用红黑树实现是一种高度平衡的二叉树内部元素是成对的也就是键值实值内部元素依据其键值自动排序内部相同的键值只能出现一次则可以出现多次无序式容器使用哈希表实现的由于哈希表的特性实现了真正的无序如果不理解为什么使用哈希表就是真正无序的可以去百度一下哈希表或者干脆直接记住就可以了使用方法也是和类似同样使用哈希表实现的自然具有了哈希表实现的容器的特点使用方法和类似关联式容器和无序式容器的对比关联式容器都是有序的对于那些对顺序有要求的操作关联式容器效率会高很多比如增加元素删除元素无序容器都是真正的无序在查找数据方面有着优势比如修改特定元素查找元素从内存消耗的角度讲无序容器要高于关联容器不过这并不重要一句话来说如果从这两类容器中选一个使用的话如果是增加删除元素比较频繁就使用关联式容器如果修改元素查找元素比较平凡就使用无序容器我们在处理数据时应该选择什么容器呢在我们需要使用存储的容器时只能使用如果增加删除频繁就使用修改查找频繁就使用在处理普通元素当元素需要频繁插入删除时选择顺序容器如果在尾部插入删除选择在头部尾部插入删除选择在中间插入删除选择当元素需要频繁查找时选择频繁增加删除时选频繁查找修改时选我们发现对于普通元素容器的选择不怎么容易判断其实在真正的大型项目中要对各种容器进行测试的普通练习一般选择或就可以了库介绍就是的简写也就是输入输出功能功能的本质数据在内存磁盘输入输出设备之间移动就是功能库组成部分定义了这个基类来定义输入输出的最基本操作库所有的类都继承自这个类即可这两个类直接继承自类类定义了从内存到输出设备比如显示器的功能我们最常使用的就是类的对象类定义了从输入设备比如键盘到内存的功能我们最常用的就是类的对象文件定义了和类的对象就是和所以我们只要简单的引入这个头文件就可以方便的使用这两个对象注意这个输入输入时相对于内存来说的输入到内存是类分别继承自类和类定义了从磁盘到内存的功能因为重载了运算符所以对象也可以用运算符来将文件数据写入内存除了的所有重载运算符都是可以被继承的定义了从内存到磁盘的功能与同理也可以用操作数据流文件引入了和所以我们只要引入这个头文件就可以使用文件流功能了注意这个输入输出同样是相对内存来说的内存与输入输出设备的数据流动磁盘与内存的数据流动已经介绍完了磁盘和输入输出设备直接无法直接交互必须通过内存库还为我们额外定义了字符串的输入输出类因为对字符串的操作极为频繁所以这个库还是很有意义的分别继承自类和类定义了从指定字符串到特定内存的功能与同理也可以用运算符操作数据定义了从特定内存到指定字符串的功能可以用操作数据头文件就引入了和所以我们只要引入这个头文集就可以使用字符串与内存直接交互数据的功能注意事项对象无法使用拷贝构造函数和赋值运算符所以我们使用流对象无法使用值传递一般使用引用进行传递对象的状态操作是非常容易出现错误的操作一些错误是可以修复的另一部分则发生在系统更深处已经超出了应用程序可以修正的范围比如我们使用向一个类型的数中输入一个字符串会使这个对象出现错误所以我们在使用对象时都应该判断对象的状态比如或不要只用这两个进行控制最好搭配来使用我们需要知道流对象错误的原因因为不同的错误需要不同的处理方法库定义了类型可以完整的表示对象当前的状态在不同的平台中实现方法略有区别在中直接用来代表类型将不同的位置以表示不同的状态可以与位操作符一起使用来一次检测或设置多个标志位可以用函数来获得对象当前用类型来表示的状态类型有以下状态状态系统级错误一旦表示的位被置为流对象就再也无法使用了状态代表可恢复错误比如想读取一个数字却读取了一个字符这种错误就是可以恢复的当位被置时位也会被置状态当到达文件结束位置时和位都会被置状态表示流对象没有任何错误只要有一位被置为则检测流状态的条件就会失败标准库还定义了一组成员函数来查询这些标志位的状态函数在所有错误位均未置的情况下返回函数在对应位被置的情况下返回因为位被置或位被置时位也会被置为所以用函数可以准确判断出流对象是否出现错误实际上我们将流对象当做条件使用的代码就等价于流对象的管理函数返回一个值对应当前流状态函数将流对象设置为想要的状态函数是一个重载的函数将所有位置也就是状态将对应的条件状态标志位复位函数作用提取输入字符并丢弃他们函数原型读取到前个字符或在读这个字符进程中遇到字符就停止把读取的这些东西丢掉内存输入输出设备的交互其实已经没什么好讲的了比较常用的就是这个了其实并不复杂不过是按行接收数据罢了因为存储对象中所以不容易出现格式错误但仍然可能出现系统错误所以在企业级程序中还是应当对的情况进行处理还有个不怎么常用的函数函数的用法和类似只不过是以字符的格式进行接收在企业级代码中仍然需要对的情况进行处理内存与磁盘的交互相对于多了很多自己独有的操作库默认没有给和类提供对象需要我们自己去定义对象创建方式有三种可以使用默认构造函数进行定义例如也可以在创建流对象时打开想要打开的文件例如可以是字符串也可以是风格的字符串指针文件的依赖于流对象的类型也可以在打开文件时就指定文件的例如函数打开名为的文件并将文件与绑定可以是一个也可以是一个风格的字符串指针函数关闭文件注意一定不要忘了函数返回一个值指出与关联的文件是否成功打开且尚未关闭文件模式以读的方式打开以写的方式打开在进行写操作时定位到文件末尾打开文件后立即定位到文件末尾截断文件也就是文件已有的全部删除重新开始写以二进制方式打开文件文件模式需要强调以下几点与关联的文件默认模式打开与关联的文件默认模式打开与关联的文件默认和模式打开默认情况下即使我们没有指定以模式打开的文件也会被截断为了保持以模式打开的文件的内容我们必须同时指定模式或模式只可以对或的对象设定的模式只可以对或的对象设定的模式只有当模式被设置时才可以设置模式和模式可以应用与任何类型的文件流对象且可以与任何其它文件模式组合使用内存之中对于字符串的操作流介绍流可以向对象写入数据也可以从对象读取数据与文件操作类似只不过数据交互变成了从内存到内存流有哪些从对象读取数据向对象写数据既可以从对象读取数据也可以向对象写数据流对象继承自对象除了继承得来的操作流对象还有自己的成员来管理流相关的对于流库是没有像这样的自定流对象的流对象需要我们自己去定义代表一个流对象的类型以下同理是一个未绑定的对象是一个绑定了的拷贝的流对象是一个对象返回所保存的的拷贝将拷贝到中返回流对象的作用对数据类型进行转化也就是和其它类型的转化这是流对象最重要的功能转化为等类型等类型转化为用于对空格分隔的字符串的切分多线程多线程基本概念介绍多线程的重要性对于一个专业的开发来说多线程是必须掌握的模块现代程序都是多线程程序了因为单核处理器的性能早已经达到了瓶颈只能往多核方向发展现代的个人计算机都是核起步工作站服务器就更不用说了工作站可以理解为处理能力更强的大型个人计算机常见的核核服务器有核的甚至更多对于一个计算机来说是不是说核越多好呢不是多核会导致单核的工作性能下降当核数多到一定程度后反而总体运行效率下降了不过这并不影响现代计算机核数越来越多的趋势传统的单线程程序同时只能在一个核上运行这是不是太浪费资源了计算机有个核你就用了一个暴殄天物啊多线程程序可以使用多个核极大提高程序运行效率现在网络通信音频视频游戏服务都是多线程程序并发与并行的概念介绍一句话来说并行是同时在不同的处理器上处理不同的任务并发是同时在一个处理器上处理多个任务解释一下并行是指有多个处理器每个处理器各执行一个线程互不抢占资源如果线程数量多于也没有办法只能将处理器的时间划分为多个时间段再将时间段分配给各个线程并发是指只有一个处理器但多个线程被轮换快速执行使得宏观上有了同时执行的效果作用原理是将单处理器的时间划分为多个时间段再分配给不同的线程同一时间段只能有一个线程在运行其它线程均处于挂起状态进程的概念进程的概念在面向进程设计的操作系统就是也包括后面衍生出的和面向线程设计的操作系统说的就是上有很大区别两种设计方式的共同点与不同点还是需要理解的进程是计算机中的程序对某些数据集合的一次运行活动是系统进行资源分配和调度的最基本单位是操作系统的结构基础再用大白话说一遍一个可执行程序执行起来就是一个进程当然一个程序要执行起来需要各种资源这些资源就是数据集合在面向进程设计的计算机结构中进程是程序的基本执行单位进程包括程序执行的所有资源同时自己也可以执行在面向线程设计的计算机结构中线程才是程序的基本执行单位进程不过是线程的容器罢了进程就像一个仓库里面存放了程序的所有资源进程中的线程才是真正执行程序的单元线程的概念的线程和的线程还是有很大区别的的线程就是一种轻量级的进程只有依靠进程才可以存在也模拟出了线程的方式让线程成为真正的执行单元的线程就简单多了真正执行程序的最小单元线程的创建主线程介绍一个程序执行起来就是一个进程而函数就是主线程一旦主线程执行完毕主线程结束整个进程就会结束子线程介绍在一个线程执行时我们可以创建出另外一个线程两个线程各自执行互补干涉注意当主线程执行完毕就会强制结束所有子线程然后进程结束从这个角度来说可以认为子线程是主线程的辅助线程但是要明白主线程和子线程是平级的只不过主线程执行完毕后会给所有子线程发送一个信号使所有子线程强制结束子线程的创建方式很简单直接使用类就可以了子线程创建后如果就不管了那么会出现非常严重的问题有些子线程负责对部分数据的处理主线程必须要等到子线程处理完毕才能继续执行所以函数就诞生了使用了函数后主线程就会处于挂起状态直到子线程执行完毕才可以继续执行有些子线程和主线程完全分离各自执行各自的但主线程执行完毕子线程就会立马被强制结束容易导致各种查都不知道从哪里开始查于是函数就诞生了函数可以让子线程被运行库接管就算主线程执行完毕子线程也会由运行时库清理相关资源保证不会出现各种意想不到的传递线程参数传递子线程函数的参数直接传递即可注意传递参数分为三种方式值传递引用传递指针传递传递参数注意事项在使用时不要传递指针或者说在设置子线程函数时不要设置指针参数因为值传递和引用传递并未直接传递地址而指针传递却直接传递地址所以当使用时传指针就会导致错误指针已经被系统回收所以不要千万不要传指针在使用时不要使用隐式类型转化因为很有可能子线程参数还没来的及将参数转化为自己的类型主线程就已经执行完毕了总结普通类型在传递子线程函数参数时直接值传递即可类类型传递引用就可以了类类型传递引用会首先调用一次复制构造函数生成一个临时变量故而导致地址不相同如果采用值传递需要两次复制构造函数开销更大的用法使用普通的引用传递会调用一次复制构造函数导致函数无法对引用对象进行修改于是诞生了它可以使子线程在传递参数时不再调用复制构造函数线程的概念线程定义每个线程都有自己的不管是主线程还是子线程都有自己的直接使用就可以获得当前线程的注意线程是依附于进程存在的所以不同的进程可以有相同的线程数据共享与数据保护多个线程的执行顺序是乱的具体执行方法和处理器的调度机制有关系从开发者的角度讲就是没有规律的在讲数据保护问题之前为了帮助大家理解数据保护问题这里额外扩展一些关于汇编的知识一个进程运行时数据存储在内存中如果一个数据要进行运算必须先将数据拷贝到寄存器中比如要对栈上的一个进行操作需要将的值拷贝到寄存器中将该值自加后再拷贝到原来的内存如果此时有两个线程均进行的是这样的操作可能出现两个进程都拷贝了原来的值到寄存器然后各种加一再拷贝到对应内存的情况最终导致这个变量只自加了一次这是同时写数据的情况那么一读一写呢这也是有问题的谁知道读数据时写数据步骤已经到了哪里谁知道读出来的是个什么东西数据保护问题数据保护问题总共有三种情况至少两个线程对共享数据均进行读操作完全不会出现数据安全问题至少两个线程对共享数据均进行写操作会出现数据安全问题需要数据保护至少两个线程对共享数据有的进行读有的进行写也会出现数据安全问题需要进行数据保护数据保护的方法一共就两种互斥锁原子操作互斥锁互斥锁的作用原理很简单对共享数据加锁当一个线程对这块数据进行操作时别的线程就无法对该区域数据进行操作这种方式的互斥锁有个弊端就是之后容易忘记就和指针类似于是和智能指针类似也有了用来防止开发人员忘了解锁原子操作使用频率远远不及互斥锁原子操作的原理将一个数据设置为原子状态使得该数据处于无法被分割的状态意思就是处理器在处理被设置为原子状态的数据时其它处理器无法处理该段数据该处理器也会保证在处理完该数据之前不会处理其他数据总结在编写多线程代码时数据保护是一个必须考虑非常常用的功能互斥锁的使用频率是远远高于原子操作原子操作看似简单但当需要保护的数据很多时就会极其复杂所以对于单个数据可以使用原子操作其它的使用互斥锁就可以了死锁死锁就像两个人在互相等对方说等来了就去现在所在的地方说等来了我就去所在的地方结果就是和都在等对面过来才能去对面这就导致了一个死循环放在多线程中就是死锁举个例子解决方法也很简单只要让两个锁顺序一致就可以了但是让两个锁顺序一致常常是说起来容易做起来难于是提供了这个模板可以保证多个互斥锁绝对不会出现死锁的问题同时提供了的功能来避免忘记释放锁的问题总结死锁是一个比较常见的面试时也经常询问死锁相关的知识异常处理异常处理的前情提要很多人不喜欢使用异常处理认为它麻烦应对可能出现的错误要写那么多代码会非常麻烦但实际上不是这样的我们只需要在一些开发人员难以控制比较容易出错的地方对异常进行处理就可以了需要进行异常处理的地方并不多举几个例子接收传递过来的被除数我们难以判断被除数是否为此时异常处理就很有意义了接收文件名如果文件不存在我们可以按照之前的写法要求重发一遍也可以直接报异常异常就是文件不存在我们在动态分配内存时经常出现内存不足的情况在大型程序中这是非常常见比如我们需要动态分配一个未知大小的数组数组大小等待传入使用操作符会直接抛出的异常对的处理非常重要大家如果做专业的开发会经常用到此外使用智能指针时如果内存分配不够也会抛出的异常有个我们需要接受一个参数然后取出参数对应的数组元素此时就经常出现数组的越界问题异常处理的介绍异常是程序在执行期间产生的问题编译期出现的错误在写代码时开发环境就有提示的异常是指程序运行时发生的特殊情况异常提供了一种转移程序控制权的方式的异常处理涉及到三个关键字当问题出现时程序会抛出一个异常这是通过关键字来完成的在你想要处理问题的地方通过异常处理程序捕获异常关键字用于捕获异常块中的代码标识将被激活的特定异常它后面通常跟着一个或多个块如果有一个块抛出一个异常捕获异常的方法会使用和关键字块中放可能抛出异常的代码块中的代码被称为保护代码常见的异常处理格式如图所示抛出异常语句可以在代码块的任何地方抛出异常抛出的表达式的结果决定了抛出的异常的类型的标准异常提供了一系列标准的异常定义在头文件中它们是以父子层次结构组织起来的如下图所示别看图很复杂异常种类有很多但经常使用的其实就几个错误使用分配内存失败就会抛出错误错误在使用时容器越界就会抛出这个错误这也是比更加优秀的原因错误运行时错误只有在程序运行时才能检测到的错误这是一个相对的概念和形成对比可以读代码读出来就不行我们也经常将一些读代码无法判断的异常标识为错误可以接受任何错误我们一般都会在最后加上这样就可以接受所有类型的异常了自定义异常类型其实需要自定义异常类型的情况真的非常少这里就不介绍了其实和标准异常也是一样的各种难以归类但有使用价值的知识点万能引用与引用折叠万能引用的概念除了带来了右值引用还带来了万能引用也就是既能当做左值又能当做右值的引用注意万能引用是既可以被编译期处理为左值引用又可以被编译期处理为右值引用不是既是左值引用又是右值引用不违背一个引用不是左值引用就是右值引用的基本说法万能引用会在编译期被当做左值引用或右值引用处理万能引用的格式万能引用的格式有两种模板型这个就是万能引用类型注意只有是万能引用类型以下的写法均不是万能引用这就是普通的右值引用这也是右值引用注意此时不是万能引用因为影响的是的类型只有这样写才是万能引用此时的类型完全独立于类了每调用一次函数都要推断的类型型这个就是万能引用就不是万能引用了万能引用的作用就是当参数为左值时为左值当参数为右值时为右值就这么简单引用折叠引用折叠其实概念很简单一个引用不是左值引用就是右值引用当一个万能引用被认为左值引用时类型应该是此时类型就会折叠为简单来说就是引用符号太多了折叠为或完美转发完美转发的定义完美转发是什么呢说到底它描述的其实就是一个参数传递的过程能够将一个传递到一个函数的参数再通过该函数原封不动的传递给另一个函数这里的原封不动不单是指参数的值更包括参数的类型参数的限定符我们发现以前的传递参数的方法都无法在万能引用中解决完美转发的问题于是提供了模板来解决完美转发的问题模板可以使参数推断出它原来的类型实现了完美转发总结完美转发就是一个专门配合万能引用的知识点专门用来在使用万能引用的地方原封不动的传递参数其实记住它是和万能引用配合使用的就掌握的差不多了',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-17 20:01:59',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Matrix's blog" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Matrix's blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>1</sup></a><a href="/tags/CTF/" style="font-size: 1.05rem;">CTF<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>2</sup></a><a href="/tags/JavaSE/" style="font-size: 1.05rem;">JavaSE<sup>1</sup></a><a href="/tags/Linux-Kernel/" style="font-size: 1.05rem;">Linux Kernel<sup>1</sup></a><a href="/tags/OS/" style="font-size: 1.05rem;">OS<sup>2</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>1</sup></a><a href="/tags/Web%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">Web后端<sup>1</sup></a><a href="/tags/csapp/" style="font-size: 1.05rem;">csapp<sup>1</sup></a><a href="/tags/%E5%93%B2%E5%AD%A6/" style="font-size: 1.05rem;">哲学<sup>5</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E6%9D%82%E8%AE%B0/" style="font-size: 1.05rem;">杂记<sup>3</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">汇编语言<sup>1</sup></a><a href="/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/" style="font-size: 1.05rem;">马列毛<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/cs/" itemprop="url">cs</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C++基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-10T16:00:00.000Z" title="发表于 2024-09-11 00:00:00">2024-09-11</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-09-17T12:01:59.255Z" title="更新于 2024-09-17 20:01:59">2024-09-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C++基础"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为武汉"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>武汉</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://blog.zymatrix.top/2024/09/11/C++%E5%9F%BA%E7%A1%80/"><header><a class="post-meta-categories" href="/categories/cs/" itemprop="url">cs</a><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><h1 id="CrawlerTitle" itemprop="name headline">C++基础</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Matrix</span><time itemprop="dateCreated datePublished" datetime="2024-09-10T16:00:00.000Z" title="发表于 2024-09-11 00:00:00">2024-09-11</time><time itemprop="dateCreated datePublished" datetime="2024-09-17T12:01:59.255Z" title="更新于 2024-09-17 20:01:59">2024-09-17</time></header><h1 id="学习思路"><a href="#学习思路" class="headerlink" title="学习思路"></a>学习思路</h1><ol>
<li>学习误区</li>
</ol>
<ul>
<li>太注重C++语言本身</li>
<li>喜欢量化学习的程度</li>
<li>太注重方向，做出的项目不通用，错失offer</li>
</ul>
<ol start="2">
<li>学习思路</li>
</ol>
<ul>
<li>做的项目要有产品化的思维</li>
<li>需要开箱即用</li>
</ul>
<ol start="3">
<li>多长时间，换工作</li>
</ol>
<ul>
<li>一年半：应届生，前半年学生转为职场人士，经过半年能独立做开发</li>
</ul>
<p>之前没有系统性的从头开始学习C++，因此此博客仅用于记录快速系统学习C++语法知识。</p>
<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><h3 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h3><p>程序被执行后就被称为一个进程，一个进程可以被划分为很多区域，这门课我们只需要理解以下的四个区就可以了。</p>
<ol>
<li><p><strong>代码区与常量区</strong>：进程按照代码区的代码执行，真正的常量也存储在这里，比如“abc”字符串，“1”，“88”等数字。这些是真正的常量。再看一下const关键字。const只不过是让编译器将变量视为常量罢了，和真正的常量有本质上的区别。</p>
</li>
<li><p><strong>栈区</strong>：函数的执行所需的空间，注意，当函数执行完毕，函数对应的栈内存全部销毁。</p>
</li>
<li><p><strong>堆区</strong>：进程用来灵活分配内存的地方，只有手动释放时才会销毁内存。</p>
</li>
<li><p><strong>静态变量区</strong>：用来存储静态变量与全局变量的区域</p>
</li>
</ol>
<p>(1)   静态变量：常常需要一些局部作用范围，生命周期却很长的变量</p>
<p>(2)   全局变量：重要性就不必说了，在c语言程序中经常用到，但在C++中不推荐使用，因为会破坏封装性。</p>
<p>具体的存储方式如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/showlibia/img/main/clip_image001.jpg" alt="20191021161835642"></p>
<p>堆区和栈区，是程序运行的主要地方。</p>
<p>至于堆区，主要意义在于灵活的生命周期。</p>
<p>如果需要创建的对象有几十M，每次调用函数都需要创建一个这么大的对象，再复制到对应的容器中，那就太过耗费内存了。而且栈内存非常的小，通常不超过8M。</p>
<p>而使用堆内存，每调用一次函数就可以在堆内存中创建一个对象，容器中只要存储指针就可以了，极大的提高了程序效率。</p>
<p>而静态变量区：</p>
<p>有很多情况下，我们需要作用范围局限在函数之内，但生命周期却很长的变量，比如统计一个函数被调用的次数。</p>
<p>总结：栈区是函数执行的区域，堆区是函数内灵活分配内存的地方，二者缺一不可。</p>
<p><strong>为什么不能只在栈上运行程序</strong>，因为当函数运行结束时，栈是要销毁的，其上分配的内存全部失效。</p>
<p>也不能只在堆上运行程序，因为堆的唯一寻址方式就是指针，如果没有栈，根本无法使用堆。</p>
<p>栈区远远小于堆区，一般不超过8M，所以主要的内容都在对堆区上。堆区很大，虚拟内存剩下的都是堆区。</p>
<h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h4><p>const关键字介绍：const是让编译期将变量视为常量，用const修饰的变量和真正的常量有本质的区别。</p>
<ol>
<li><p>真正的常量存储在常量区或代码区，比如“abcdefg”这个字符串就存储在常量区，而“3”，“100”这些数字就存储在代码区中，这些都是真正的常量，无法用任何方式修改。</p>
</li>
<li><p>const修饰的变量仍然存储在堆区或栈区中，从内存分布的角度讲，和普通变量没有区别。const修饰的变量并非不可更改的，C++本身就提供了mutable关键字用来修改const修饰的变量，从汇编的角度讲，const修饰的变量也是可以修改的。</p>
</li>
</ol>
<h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><p>auto是C++11新加入的关键字，就是为了简化一些写法。</p>
<p>使用auto推断类型确实简单方便，但有个基本要求，就是在使用auto时清楚的知道编译器会给auto推断出什么类型。</p>
<p>auto需要注意以下几点：</p>
<ol>
<li><p>auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号。</p>
</li>
<li><p>auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。</p>
</li>
<li><p>auto关键字在推断类型时，如果没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。</p>
</li>
<li><p>auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留。</p>
</li>
</ol>
<p>其实3，4为什么会出现这种情况，因为在传递值时，修改这个值并不会对原有的值造成影响。而传递引用时，修改这个值会直接对原有的值造成影响。</p>
<ol start="5">
<li><p>当然，我们可以在前面加上const，这样永远都有const的含义。</p>
</li>
<li><p>auto不会影响编译速度，甚至会加快编译速度。因为编译器在处理XX a &#x3D; b时，当XX是传统类型时，编译期需要检查b的类型是否可以转化为XX。当XX为auto时，编译期可以按照b的类型直接给定变量a的类型，所以效率相差不大，甚至反而还有提升。</p>
</li>
<li><p>auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先。</p>
</li>
<li><p>auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题。</p>
</li>
</ol>
<h3 id="静态变量-指针-引用"><a href="#静态变量-指针-引用" class="headerlink" title="静态变量 指针 引用"></a>静态变量 指针 引用</h3><p>变量的存储位置有三种，分别是静态变量区，栈区，堆区。</p>
<p>静态变量区在编译时就已经确定地址，存储全局变量与静态变量。</p>
<p>指针都是存储在栈上或堆上，不管在栈上还是堆上，都一定有一个地址。</p>
<p>本质上说，指针和普通变量没有区别。</p>
<p>在32位系统中，int变量和指针都是32位。指针必须和“&amp;”，“*”这两个符号一起使用才有意义。</p>
<p>&amp;a代表的a这个变量的地址，a代表的a对应地址存储的值，*a代表对应地址存储的值作为地址对应的值。</p>
<p>所以指针才可以灵活的操作内存，但这也带来了严重的副作用，比如指针加加减减就可以操作内存，所以引用被发明了，引用就是作用阉割的指针（可以视为“类型<em>const”，所以引用必须上来就赋初值，不能设置为空），编译器不将其视作对象，操作引用相当于操作引用指向的对象。*<em>也就从根本是杜绝了引用篡改内存的能力。</em></em></p>
<h3 id="左右值"><a href="#左右值" class="headerlink" title="左右值"></a>左右值</h3><p>左值右值从C++11开始就是一个很重要的概念了，但想要真正理解左值，右值不是一件容易的事。</p>
<p>**C++**任何一个对象要么是左值，要么是右值。</p>
<p>比如int i &#x3D; 10，i和10都是对象</p>
<p><strong>左值：拥有地址属性的对象就叫左值，</strong>左值来源于c语言的说法，能放在“&#x3D;”左面的就是左值，注意，左值也可以放在“&#x3D;”右面。</p>
<p><strong>右值：不是左值的对象就是右值。或者说无法操作地址的对象就叫做右值。</strong>一般来说，判断一个对象是否为右值，就看它是不是左值，有没有地址属性，不是左值，那就是右值。</p>
<p><strong>比如临时对象，就都是右值，临时对象的地址属性无法使用。</strong></p>
<p>**注意：左值也可以放在“&#x3D;<strong>”右面，但右值绝对不可以放在等号左面</strong></p>
<p><strong>接下来就是大量举例了，说明那些是左值，哪些是右值。</strong></p>
<p> 比如++i是对i自增然后返回i，是左值，i++是先复制一个i返回临时对象，再自增，是右值</p>
<p><strong>引用分类</strong></p>
<p>(1)   普通左值引用：就是一个对象的别名，只能绑定左值，无法绑定常量对象。</p>
<p>(2)   const左值引用：可以对常量起别名，可以绑定左值和右值。</p>
<p>(3)   <strong>右值引用</strong>：只能绑定右值的引用。</p>
<p>(4)   万能引用：</p>
<h3 id="move函数"><a href="#move函数" class="headerlink" title="move函数"></a>move函数</h3><p>(1) 右值看重对象的值而不考虑地址，move函数可以对一个左值使用，使操作系统不再在意其地址属性，将其完全视作一个右值。</p>
<p>(2) move函数让操作的对象失去了地址属性，<strong>所以我们有义务保证以后不再使用该变量的地址属性，简单来说就是不再使用该变量，因为左值对象的地址是其使用时无法绕过的属性。</strong></p>
<h5 id="临时对象："><a href="#临时对象：" class="headerlink" title="临时对象："></a>临时对象：</h5><p><strong>右值都是不体现地址的对象。那么，还有什么能比临时对象更加没有地址属性呢？右值引用主要负责处理的就是临时对象。</strong></p>
<p>程序执行时生成的中间对象就是临时对象，注意，所有的临时对象都是右值对象，因为临时对象产生后很快就可能被销毁，使用的是它的值属性。</p>
<h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><p>如果一个对象可以使用调用运算符“()”，()里面可以放参数，这个对象就是可调用对象。</p>
<p>可调用对象的分类：</p>
<h5 id="1-函数："><a href="#1-函数：" class="headerlink" title="1. 函数："></a>1. 函数：</h5><p>函数自然可以调用()运算符，是最典型的可调用对象。</p>
<h5 id="2-仿函数："><a href="#2-仿函数：" class="headerlink" title="2. 仿函数："></a>2. 仿函数：</h5><p>具有operator()函数的类对象，此时类对象可以当做函数使用，因此称为仿函数。</p>
<h5 id="3-lambda表达式："><a href="#3-lambda表达式：" class="headerlink" title="3. lambda表达式："></a>3. lambda表达式：</h5><p>就是匿名函数，普通的函数在使用前需要找个地方将这个函数定义，于是C++提供了lambda表达式，需要函数时直接在需要的地方写一个lambda表达式，省去了定义函数的过程，增加开发效率。</p>
<p><strong>lambda</strong>表达式的格式：最少是“[] {}”，完整的格式为“[] () -&gt;ret {}”。</p>
<p>lambda各个组件介绍</p>
<ol>
<li>[]代表捕获列表：表示lambda表达式可以访问前文的哪些变量。</li>
</ol>
<p>(1)   []表示不捕获任何变量。</p>
<p>(2)   [&#x3D;]：表示按值捕获所有变量。</p>
<p>(3)   [&amp;]：表示按照引用捕获所有变量。</p>
<p>&#x3D;，&amp;也可以混合使用，比如</p>
<p>(4)   [&#x3D;, &amp;i]：表示变量i用引用传递，除i的所有变量用值传递。</p>
<p>(5)   [&amp;, i]：表示变量i用值传递，除i的所有变量用引用传递。</p>
<p>当然，也可以捕获单独的变量</p>
<p>(6)   [i]：表示以值传递的形式捕获i</p>
<p>(7)   [&amp;i]：表示以引用传递的方式捕获i</p>
<ol start="2">
<li><p>()代表lambda表达式的参数，函数有参数，lambda自然也有。</p>
</li>
<li><p>-&gt;ret表示指定lambda的返回值，如果不指定，lambda表达式也会推断出一个返回值的。</p>
</li>
<li><p>{}就是函数体了，和普通函数的函数体功能完全相同。</p>
</li>
</ol>
<p>C++的可调用对象主要就这三个，当然，这三个也可以衍生出很多写法。最常见的就是函数指针，函数指针的本质就是利用指针调用函数，本质还是函数，在C++11当中引入了std::function，可以起到和函数指针一样的效果。使用function函数，可以在lambda为调用的函数时捕获变量。函数指针要细分也可以分为指向类成员函数的指针，指向普通函数的指针。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="this，常成员函数与常对象"><a href="#this，常成员函数与常对象" class="headerlink" title="this，常成员函数与常对象"></a>this，常成员函数与常对象</h3><ol>
<li>this关键字：</li>
</ol>
<p>(1) this是什么：</p>
<ul>
<li><p>编译器将this解释为指向函数所作用的对象的指针。C++类的本质就是C语言的结构体外加几个类外的函数，C++最后都要转化为C语言来实现，类外的函数就是通过this来指向这个类的。</p>
</li>
<li><p>当然，这么说并非完全准确，this是一个关键字，只是我们将它当做指针理解罢了。</p>
</li>
</ul>
<p>this有很多功能是单纯的指针无法满足的。比如每个类函数的参数根本没有名 叫this的指针。这不过是编译器赋予的功能罢了。</p>
<ol start="2">
<li>常成员函数和常对象</li>
</ol>
<p><strong>常成员函数和常对象很多人并不在意，确实，都写普通变量也可以。但是，在大型程序中，尽量加上const关键字可以减少很多不必要的错误。</strong></p>
<p>(1)   const关键字含义：这里说一下<strong>常成员函数和常对象。</strong></p>
<p>常成员函数就是无法修改成员变量的函数。可以理解为将this指针指向对象用const修饰的函数。</p>
<p>常对象就是用const修饰的对象，定义好之后就再也不需要更改成员变量的值了。常对象在大型程序中还是很有意义的。</p>
<p>(2)   常成员函数注意事项：</p>
<p>因为类的成员函数已经将this指针省略了，只能在函数后面加const关键字来实现无法修改类成员变量的功能了</p>
<ul>
<li><p>注意：常函数无法调用了普通函数，否则常函数的这个“常”字还有什么意义。</p>
</li>
<li><p><strong>成员函数能写作常成员函数就尽量写作常成员函数，可以减少出错几率。</strong></p>
</li>
<li><p>同名的常成员函数和普通成员函数是可以重载的，常量对象会优先调用常成员函数，普通对象会优先调用普通成员函数</p>
</li>
</ul>
<p>(1) 常对象注意事项：</p>
<ul>
<li><p>常对象不能调用普通函数。</p>
</li>
<li><p>常函数在大型程序中真的很重要，很多时候我们都需要创建好就不再改变的对象。</p>
</li>
</ul>
<p>(2) 总结：<strong>常成员函数和常对象要多用，这真的是一个非常好的习惯，写大项目可以少出很多bug</strong></p>
<h3 id="一些关键字"><a href="#一些关键字" class="headerlink" title="一些关键字"></a>一些关键字</h3><ol>
<li>inline关键字</li>
</ol>
<p>(1)   inline关键字的有什么作用：</p>
<ul>
<li><p>在函数声明或定义中函数返回类型前加上关键字inline就可以把函数指定为内联函数。关键字inline必须与函数定义放在一起才能使函数成为内联，仅仅将inline放在函数声明前不起任何作用。</p>
</li>
<li><p>内联函数的作用，普通函数在调用时需要给函数分配栈空间以供函数执行，压栈等操作会影响成员运行效率，于是C++提供了内联函数将函数体放到需要调用函数的地方，用空间换效率。</p>
</li>
</ul>
<p>(2) inline关键字的注意事项：inline关键字只是一个建议，开发者建议编译器将成员函数当做内联函数，一般适合搞内联的情况编译器都会采纳建议。</p>
<p>(3) Inline关键字的总结。使用inline关键字就是一种提高效率，但加大编译后文件大小的方式，现在随着硬件性能的提高，inline关键字用的越来越少了。</p>
<ol start="2">
<li>mutable关键字</li>
</ol>
<p>(1)   mutable关键字的作用：</p>
<ul>
<li>Mutable意为可变的，与const相对，被mutable修饰的成员变量，永远处于可变的状态，即便处于一个常函数中，该变量也可以被更改。</li>
</ul>
<p>这个关键字在现代C++中使用情况并不多，一般来说只有在统计函数调用次数时才会用到。</p>
<p>(2)   mutable关键字的注意事项</p>
<ul>
<li><p>mutable是一种万不得已的写法，一个程序不得不使用mutable关键字时，可以认为这部分程序是一个糟糕的设计。</p>
</li>
<li><p>mutable不能修饰静态成员变量和常成员变量。</p>
</li>
</ul>
<p>(3)   总结：mutable关键字是一种没有办法的办法，设计时应该尽量避免，只有在统计函数调用次数这类情况下才推荐使用。这个关键字也称不上是重点。</p>
<ol start="3">
<li>default关键字</li>
</ol>
<p>(1) default关键字的作用：default关键字的作用很简单。</p>
<ul>
<li><p>在编译时不会生成默认构造函数时便于书写。</p>
</li>
<li><p>也可以对<strong>默认复制构造函数，默认的赋值运算符和默认的析构函数</strong>使用，表示使用的是系统默认提供的函数，这样可以使代码更加明显。</p>
</li>
<li><p>现代C++中，哪怕没有构造函数，也推荐将构造函数用default关键字标记，可以让代码看起来更加直观，方便。</p>
</li>
</ul>
<p>总结：default关键字还是推荐使用的，在现代C++代码中，如果需要使用一些默认的函数，推荐用default标记出来。</p>
<ol start="4">
<li>delete关键字</li>
</ol>
<p>(1)   Delete关键字的作用：C++会为程序生成默认构造函数，默认复制构造函数，默认重载赋值运算符（重载部分会详细讲解）。</p>
<p>在很多情况下，我们并不希望这些默认的函数被生成，在C++11以前，只能有将此     函数声明为私有函数或是将函数只声明不定义两种方式。</p>
<p>C++11于是提供了delete关键字，只要在函数最后加上“&#x3D;delete”就可以明确告诉 编译期不要默认生成该函数。</p>
<p>总结：delete关键字还是推荐使用的，在现代C++代码中，如果不希望一些函数默认生成，就用delete表示，这个功能还是很有用的，比如在单例模式中，</p>
<h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p>重载运算符在整个C++中拥有非常重要的地位，这一节非常重要。</p>
<ol>
<li>重载运算符的作用：</li>
</ol>
<p>(1) 很多时候我们想让类对象也能像基础类型的对象一样进行作基础操作，比如“+”，“-”，“*”，“\”，也可以使用某些运算符“&#x3D;”，“()”，“[]”,“&lt;&lt;”，“&gt;&gt;”。但是一般的类即使编译器可以识别这些运算符，类对象也无法对这些运算符做出应对，我们必须对类对象定义处理这些运算符的方式。</p>
<p>(2)   C++提供了定义这些行为的方式，就是“operator 运算符”来定义运算符的行为，operator是一个关键字，告诉编译器我要重载运算符了。</p>
<ol start="2">
<li>注意：</li>
</ol>
<p>(1)   我们只能重载C++已有的运算符，所有无法将“<strong>”这个运算符定义为指数的形式，因为C++根本没有“</strong>”这个运算符。</p>
<p>(2)   C++重载运算符不能改变运算符的元数，“元数”这个概念就是指一个运算符对应的对象数量，比如“+”必须为“a + b”，也就是说“+”必须有两个对象，那么“+”就是二元运算符。比如“++”运算符，必须写为“a++”，也就是一元运算符。</p>
<ol start="3">
<li>重载运算符举例</li>
</ol>
<p>(1)   一元运算符重载</p>
<p>①   “++”，“–”,</p>
<p>②   “[]”</p>
<p>③   “()”</p>
<p>④   “&lt;&lt;”，“&gt;&gt;”</p>
<p>(2)   二元运算符重载</p>
<p>①   “+”，“-”，“*”，“&#x2F;”</p>
<p>②   “&#x3D;”，</p>
<p>③   “&gt;”，“&lt;”，“&#x3D;&#x3D;” </p>
<p>至于唯一的三元运算符“?:”，不能重载</p>
<p>(3)   类类型转化运算符：“operator 类型”</p>
<p>(4)   特殊的运算符：new，delete，new[]，delete[]</p>
<p>注意：“&#x3D;”类会默认进行重载，如果不需要可以用“delete关键字进行修饰”。</p>
<p>总结：重载运算符非常重要，C++类中几乎都要定义各种各种的重载运算符。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li><p>C++继承介绍：C++非继承的类相互是没有关联性的，假设现在需要设计医生，教师，公务员三个类，需要定义很多重复的内容而且相互没有关联，调用也没有规律。如果这还算好，那一个游戏有几千件物品，调用时也要写几千个函数。这太要命了。于是继承能力就应运而生了。</p>
</li>
<li><p>C++继承原理：C++的继承可以理解为在创建子类成员变量之前先创建父类的成员变量，实际上，C语言就是这么模仿出继承功能的。</p>
</li>
<li><p>C++继承的注意事项。</p>
</li>
</ol>
<p>(1)   C++子类对象的构造过程。先调用父类的构造函数，再调用子类的构造函数，也就是说先初始化父类的成员，再初始化子类的成员。</p>
<p>(2)   若父类没有默认的构造函数，子类的构造函数又未调用父类的构造函数，则无法编译。</p>
<p>(3)   C++子类对象的析构过程。先调用父类的析构函数，再调用子类的析构函数。</p>
<p>总结：面向对象三大特性的继承就这么简单，很多人觉得类继承很复杂，其实完全不是这样的，只要明白子类在内存上其实就相当于把父类的成员变量放在子类的成员变量前面罢了。构造和析构过程也是为了这个机制而设计的。</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ol>
<li>虚函数介绍：</li>
</ol>
<p>(1)   虚函数就是面向对象的第三大特点：多态。多态非常的重要，它完美解决了上一课设计游戏装备类的问题，我们可以只设计一个函数，函数参数是基类指针，就可以调用子类的功能。比如射击游戏，所有的枪都继承自一个枪的基类，人类只要有一个开枪的函数就可以实现所有枪打出不同的子弹。</p>
<p>(2)   父类指针可以指向子类对象，这个是自然而然的，因为子类对象的内存前面就是父类成员，类型完全匹配。</p>
<p>(3)   当父类指针指向子类对象，且子类重写父类某一函数时。父类指针调用该函数，就会产生以下的可能</p>
<p><strong>①</strong>   <strong>该函数为虚函数：父类指针调用的是子类的成员函数。</strong></p>
<p><strong>②</strong>   <strong>该函数不是虚函数：父类指针调用的是父类的成员函数。</strong></p>
<ol start="2">
<li>虚函数的注意事项：</li>
</ol>
<p>(1)   子父类的虚函数必须完全相同，为了防止开发人员一不小心将函数写错，于是C++11添加了override关键字。</p>
<p>(2) <strong>父类的析构函数必须为虚函数</strong>：这一点很重要，当父类对象指向子类对象时，容易使独属于子类的内存泄露。会造成内存泄露的严重问题。</p>
<ol start="3">
<li>overide关键字的作用：前面已经说过了，为了防止开发人员将函数名写错了，加入了override关键字。</li>
</ol>
<p><strong>4.</strong> <strong>虚函数实现多态的原理介绍</strong></p>
<p>(1)   动态绑定和静态绑定：</p>
<p>①   静态绑定：程序在编译时就已经确定了函数的地址，比如非虚函数就是静态绑定。</p>
<p>②   动态绑定：程序在编译时确定的是程序寻找函数地址的方法，只有在程序运行时才可以真正确定程序的地址，比如虚函数就是动态绑定。</p>
<p>(2)   虚函数是如何实现动态绑定的呢？</p>
<p>①   每个有虚函数的类都会有一个虚函数表，对象其实就是指向虚函数表的指针，编译时编译器只告诉了程序会在运行时查找虚函数表的对应函数。每个类都会有自己的虚函数表，所以当父类指针引用的是子类虚函数表时，自然调用的就是子类的函数。</p>
<ol start="5">
<li>总结：虚函数是C++类的重要特性之一，很简单，但使用频率非常高，至于如何实现的也要掌握。</li>
</ol>
<h3 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h3><ol>
<li>RTTI介绍：</li>
</ol>
<p>(1)   RTTI（Run Time Type Identification）即通过运行时类型识别，程序能够通过基类的指针或引用来检查这些指针或引用所指向的对象的实际派生类。</p>
<p>(2)C++为了支持多态，C++的指针或引用的类型可能与它实际指向对象的类型不相同，这时就需要rtti去判断类的实际类型了，rtti是C++判断指针或引用实际类型的唯一方式。</p>
<ol start="2">
<li>RTTI的使用场景：可能有很多人会疑惑RTTI的作用，所以单独拿出来说一下。</li>
</ol>
<p>(1)   异常处理：这是RTTI最主要的使用场景，具体作用在异常处理章节会详细讲解。</p>
<p>(2)   IO操作：具体作用等到IO章节会详细讲解。</p>
<ol start="3">
<li>RTTI的使用方式：RTTI的使用过程就两个函数</li>
</ol>
<p>(1)   typeid函数：typeid函数返回的一个叫做type_info的结构体，该结构体包括了所指向对象的实际信息，其中name()函数就可以返回函数的真实名称。type_info结构体其他函数没什么用.</p>
<p>(2)   dynamic_cast函数：C++提供的将父类指针转化为子类指针的函数。</p>
<ol start="4">
<li>RTTI的注意事项：</li>
</ol>
<p>(1)当使用typeid函数时，父类和子类必须有虚函数（父类有了虚函数，子类自然会有虚函数），否则类型判断会出错。</p>
<ol start="5">
<li>RTTI总结：就是C++在运行阶段判断对象实际类型的唯一方式。</li>
</ol>
<h3 id="移动构造函数与移动赋值运算符"><a href="#移动构造函数与移动赋值运算符" class="headerlink" title="移动构造函数与移动赋值运算符"></a>移动构造函数与移动赋值运算符</h3><ol>
<li>对象移动的概念：</li>
</ol>
<p>(1)   对一个体积比较大的类进行大量的拷贝操作是非常消耗性能的，因此C++11中加入了“对象移动”的操作</p>
<p>(2)   所谓的对象移动，其实就是把该对象占据的内存空间的访问权限转移给另一个对象。比如一块内存原本属于A，在进行“移动语义”后，这块内存就属于B了。</p>
<ol start="2">
<li>移动语义为什么可以提高程序运行效率。因为我们的各种操作经常会进行大量的“复制构造”，“赋值运算”操作。这两个操作非常耗费时间。移动构造是直接转移权限，这是不是就快多了。</li>
</ol>
<p><strong>注意：在进行转移操作后，被转移的对象就不能继续使用了，所以对象移动一般都是对临时对象进行操作（因为临时对象很快就要销毁了）。</strong></p>
<p>注意这里的右值引用不能是const的，因为你用右值引用函数参数就算为了让其绑定到一个右值上去的！就是说这个右值引用是一定要变的，但是你一旦加了const就没法改变该右值引用了。 </p>
<p><strong>3.</strong> <strong>默认移动构造函数和默认移动赋值运算符</strong></p>
<p>会默认生成移动构造函数和移动赋值运算符的条件：</p>
<p><strong>只有一个类没有定义任何自己版本的拷贝操作（拷贝构造，拷贝赋值运算符），且类的每个非静态成员都可以移动，系统才能为我们合成。</strong></p>
<p><strong>可以移动的意思就是可以就行移动构造，移动赋值。所有的基础类型都是可以移动的，有移动语义的类也是可以移动的。</strong></p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ol>
<li><p>为什么要有智能指针：直接使用new和delete运算符极其容易导致内存泄露，而且非常难以避免。于是人们发明了智能指针这种可以自动回收内存的工具。</p>
</li>
<li><p>智能指针一共就三种：普通的指针可以单独一个指针占用一块内存，也可以多个指针共享一块内存。</p>
</li>
</ol>
<p>(1)   共享型智能指针：shared_ptr，同一块堆内存可以被多个shared_ptr共享。</p>
<p>(2)   独享型智能指针：unique_ptr，同一块堆内存只能被一个unique_ptr拥有。</p>
<p>(3)   弱引用智能指针：weak_ptr，也是一种共享型智能指针，可以视为对共享型智能指针的一种补充</p>
<p><strong>智能指针和裸指针不要混用</strong></p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>1.shared_ptr的工作原理</p>
<p>(1)   我们在动态分配内存时，堆上的内存必须通过栈上的内存来寻址。也就是说栈上的指针（堆上的指针也可以指向堆内存，但终究是要通过栈来寻址的）是寻找堆内存的唯一方式。</p>
<p>(2)   所以我们可以给堆内存添加一个引用计数，有几个指针指向它，它的引用计数就是几，当引用计数为0是，操作系统会自动释放这块堆内存。</p>
<p>2.常用操作</p>
<p><strong>(1)</strong> 初始化</p>
<ul>
<li>使用new运算符初始化</li>
</ul>
<p>一般来说不推荐使用new进行初始化，因为C++标准提供了专门创建shared_ptr的函数“make_shared”，该函数是经过优化的，效率更高。</p>
<p><strong>②</strong>   使用make_shared函数进行初始化：</p>
<p><strong>注意：千万不要用裸指针初始化shared_ptr，容易出现内存泄露的问题。</strong></p>
<p><strong>③</strong>   <strong>当然使用复制构造函数初始化也是没有问题的。</strong></p>
<p>(2)shared_ptr的引用计数：</p>
<p>智能指针就是通过引用计数来判断释放堆内存时机的。</p>
<p>use_count()函数可以得到shared_ptr对象的引用计数。</p>
<p><strong>3.</strong> <strong>智能指针可以像普通指针那样使用，”share_ptr”</strong>早已对各种操作进行了重载，就当它是普通指针就可以了。</p>
<p><strong>4.</strong> shared_ptr的常用函数</p>
<p>(3)   unique函数：判断该shared_ptr对象是否独占若独占，返回true。否则返回false。</p>
<p>(4)   reset函数：</p>
<p>①   当reset函数有参数时，改变此shared_ptr对象指向的内存。</p>
<p>②   当reset函数无参数时，将此shared_ptr对象置空，也就是将对象内存的指针设置为nullptr。</p>
<p><strong>(5)</strong>   <strong>get函数，强烈不推荐使用：</strong></p>
<p><strong>如果一定要使用，那么一定不能delete返回的指针。</strong></p>
<p>(6)   swap函数：交换两个智能指针所指向的内存</p>
<p>①   std命名空间中全局的swap函数</p>
<p>②   shared_ptr类提供的swap函数</p>
<ol start="5">
<li><p><strong>关于智能指针创建数组的问题。</strong></p>
</li>
<li><p><strong>用智能指针作为参数传递时直接值传递就可以了。</strong>shared_ptr的大小为固定的8或16字节（也就是两倍指针的的大小，32位系统指针为4个字节，64位系统指针为8个字节，shared_ptr中就两个指针），所以直接值传递就可以了。</p>
</li>
<li><p>总结：在现代程序中，当想要共享一块堆内存时，优先使用shared_ptr，可以极大的减少内存泄露的问题。</p>
</li>
</ol>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>1.weak_ptr介绍：</p>
<p>(1) 这个智能指针是在C++11的时候引入的标准库，它的出现完全是为了弥补shared_ptr天生有缺陷的问题，其实shared_ptr可以说近乎完美。</p>
<p>(2) 只是通过引用计数实现的方式也引来了引用成环的问题，这种问题靠它自己是没办法解决的，所以在C++11的时候将shared_ptr和weak_ptr一起引入了标准库，用来解决循环引用的问题。</p>
<ol start="2">
<li><p>shared_ptr的循环引用问题：</p>
</li>
<li><p><strong>weak_ptr</strong>的作用原理：weak_ptr的对象需要绑定到shared_ptr对象上，作用原理是weak_ptr不会改变shared_ptr对象的引用计数。只要shared_ptr对象的引用计数为0，就会释放内存，weak_ptr的对象不会影响释放内存的过程。</p>
</li>
</ol>
<p><strong>4.</strong> weak_ptr的总结：<strong>weak_ptr</strong>使用较少，就是为了处理shared_ptr循环引用问题而设计的。</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ol>
<li><p><strong>uniqe_ptr</strong>介绍：独占式智能指针，在使用智能指针时，我们一般优先考虑独占式智能指针，因为消耗更小。如果发现内存需要共享，那么再去使用“shared_ptr”。</p>
</li>
<li><p><strong>unique_ptr</strong>的初始化：和shared_ptr完全类似</p>
</li>
</ol>
<p>(1)   使用new运算符进行初始化</p>
<p>(2)   使用make_unique函数进行初始化</p>
<p>3.unique_ptr的常用操作</p>
<p>(1)   unque_ptr禁止复制构造函数，也禁止赋值运算符的重载。否则独占便毫无意义。、</p>
<p>(2)   unqiue_ptr允许移动构造，移动赋值。移动语义代表之前的对象已经失去了意义，移动操作自然不影响独占的特性。</p>
<p>(3)   reset函数：</p>
<p>①   不带参数的情况下：释放智能指针的对象，并将智能指针置空。</p>
<p>②   带参数的情况下：释放智能指针的对象，并将智能指针指向新的对象。</p>
<ol start="4">
<li>将unque_ptr的对象转化为shared_ptr对象，当unique_ptr的对象为一个右值时，就可以将该对象转化为shared_ptr的对象。</li>
</ol>
<p><strong>这个使用的并不多，需要将独占式指针转化为共享式指针常常是因为先前设计失误。</strong></p>
<p>注意：shared_ptr对象无法转化为unique_ptr对象。</p>
<h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="模板介绍，类模板与模板实现原理"><a href="#模板介绍，类模板与模板实现原理" class="headerlink" title="模板介绍，类模板与模板实现原理"></a>模板介绍，类模板与模板实现原理</h3><p><strong>1.</strong> <strong>模板的介绍：</strong></p>
<p>(1)   模板能够实现一些其他语法难以实现的功能，但是理解起来会更加困难，容易导致新手摸不着头脑。</p>
<p>(2)   模板分为类模板和函数模板，函数模板又分为普通函数模板和成员函数模板。</p>
<p><strong>2.</strong> <strong>类模板基础：</strong></p>
<p>(1)   类模板的写法与使用十分固定</p>
<p><strong>3.</strong> <strong>模板的实现原理：</strong></p>
<p>模板需要编译两次，在第一次编译时仅仅检查最基本的语法，比如括号是否匹配。等函数真正被调用时，才会真正生成需要的类或函数。</p>
<p>所以这直接导致了一个结果，就是不论是模板类还是模板函数，声明与实现都必须放在同一个文件中。因为在程序在编译期就必须知道函数的具体实现过程。如果实现和声明分文件编写，需要在链接时才可以看到函数的具体实现过程，这当然会报错。</p>
<p>于是人们发明了.hpp文件来存放模板这种声明与实现在同一文件的情况。</p>
<h3 id="initializer-list与typename"><a href="#initializer-list与typename" class="headerlink" title="initializer_list与typename"></a>initializer_list与typename</h3><ol>
<li>initializer_list的用法</li>
</ol>
<p>initializer_list介绍：initializer_list其实就是初始化列表，我们可以用初始化列表初始化各种容器，比如“vector”，“数组”。</p>
<ol start="2">
<li>typename的用法</li>
</ol>
<p>(1)   在定义模板时表示这个一个待定的类型</p>
<p>(2)   在类外表明自定义类型时使用</p>
<p>在C++的早期版本，为了减少关键字数量，用class来表示模板的参数，但是后来因为第二个原因，不得不引入typename关键字。</p>
<h3 id="模板的重载，全特化和偏特化"><a href="#模板的重载，全特化和偏特化" class="headerlink" title="模板的重载，全特化和偏特化"></a>模板的重载，全特化和偏特化</h3><ol>
<li>模板的重载</li>
</ol>
<p>(1)   函数模板是可以重载的（类模板不能被重载），通过重载可以应对更加复杂的情况。比如在处理char和string对象时，虽然都可以代表字符串，但char在复制时直接拷贝内存效率明显更高，string就不得不依次调用构造函数了。所以在一些比较最求效率的程序中对不同的类型进行不同的处理还是非常有意义的。</p>
<p>其实函数模板的重载和普通函数的重载没有什么区别。</p>
<ol start="2">
<li>模板的特化</li>
</ol>
<p>(1)   模板特化的意义：函数模板可以重载以应对更加精细的情况。类模板不能重载，但可以特化来实现类似的功能。</p>
<p>(2)   模板的特化也分为两种，全特化和偏特化。模板的全特化：就是指模板的实参列表与与相应的模板参数列表一一对应。</p>
<p>(3)   模板的偏特化：偏特化就是介于普通模板和全特化之间，只存在部分类型明确化，而非将模板唯一化。</p>
<p><strong>(4)</strong>   <strong>其实对于函数模板来说，特化与重载可以理解为一个东西。</strong></p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li>stl的介绍：</li>
</ol>
<p>(1)   stl就是（standard template library）的简称，定义在std命名空间中，定义了C++常用的容器与算法等。</p>
<p>stl极大的提高了我们的程序开发效率。</p>
<p>在C++开发中，可以说：不会用stl的人，会用stl但不懂stl实现原理的人，既会使用stl，又懂得stl实现原理的人是完完全全的三个档次。</p>
<p>(2)   泛型编程的概念：用模板进行编程，可以实现一些其它方式难以实现的功能，但对于新手来说，泛型编程可能会难以理解，摸不着头脑。</p>
<p>也就是说，模板是学习泛型编程的基础。</p>
<p><strong>注意：泛型编程不属于面向对象编程的范畴，泛型编程和面向对象编程是并列的。</strong></p>
<p>(3)   stl作为泛型编程的最典型代表，它实现了其它编程方式难以实现的效果，比如将整个模板库分为六个部分，每个部分可以单独设计。举个最简单的例子，vector和map在数据结构方面完全不一样，但stl可以设计出“迭代器”这个模块，让该模块可以在不同的数据结构中按照同样的方式运行。这种技术没有泛型编程是难以实现的。</p>
<ol start="2">
<li>学习stl的注意事项</li>
</ol>
<p><strong>(1)</strong>   <strong>学习stl</strong>一定要有全局观念，不要局限于单个容器，重点在于明白六大组件之间的联系。</p>
<p><strong>(2)</strong>   <strong>当然，如果只是单纯为了应付当前的业务，单独学一下某个容器的用法也没有问题。</strong></p>
<ol start="3">
<li>SLT的六大容器介绍：</li>
</ol>
<p>(1)   容器（container）：是一种数据结构，也就是真正用来存储数据的地方。分为三类</p>
<p>①   顺序式容器：</p>
<p>②   关联式容器：</p>
<p>③   无序式容器：其实无序式容器也是一种关联式容器，但是既然C++标准委员会将无序容器与关联式容器平行的列了出来，那么我们这里也就让无序式容器和关联式容器平行吧。</p>
<p>(2)   迭代器（iterator）：提供了可以访问任何容器的方法。</p>
<p>(3)   算法（alogorithm）：用来操作容器中的数据的模板函数。</p>
<p>(4)   仿函数（functor）</p>
<p>(5)   适配器（adaptor）</p>
<p>(6)   分配器（allocator）</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><strong>1.</strong> 顺序容器（sequence container）：每个元素都有固定的位置，<strong>位置取决于插入时间和地点，与元素的值无关</strong></p>
<p>(1)   vector：<strong>将元素置于一个动态数组中，可以随机存储元素（也就是用索引直接存取）。</strong></p>
<p>数组尾部添加或删除元素非常迅速。但在中部或头部就比较费时。</p>
<p><strong>(2)</strong>   deque：“double end queue”的缩写，也就是双端队列。deque的实现相比于vector有些复杂，但本质仍然是优化过的动态数组，只不过相比于单纯的动态数组，在前面添加或删除元素非常快了。 </p>
<p><strong>可以随机存储元素。</strong>头部和尾部添加或删除元素都非常快（略慢与vector）。但在 中间插入元素比较费时（和vector差不多）。</p>
<p>(3)   list：本质就是链表，所以自然具有了链表的属性。 </p>
<p><strong>不能随机存取元素（也就是lis无法用索引存取元素）</strong>。在任何位置插入和删除元 素都比较迅速。（在任何位置插入删除元素的时间相同，在元素头部操作慢于deque，在元素尾部操作慢于deque和vector）</p>
<p>(4)   string：把普通字符串封装了一下</p>
<p>(5)   forward_list：单项链表，简单来说就是受限的list，凡是list不支持的功能，它都不支持。做各种支持的操作效率都会高于list，最典型的就排序算法了，forword_list要优于list。</p>
<p>①   ForwordList 只提供前向迭代器，而不是双向迭代器。因此它也不支持反向迭代器。</p>
<p>②   ForwordList不提供成员函数 size()。</p>
<p>③   ForwordList 没有指向最末元素的锚点。基于这个原因，不提供用以处理最末元素的成员 back(),push_back(),pop_back()。</p>
<p><strong>2.</strong> 关联容器（associated container）：<strong>元素位置取决于元素的值，和插入顺序无关。</strong></p>
<p>(1)   set&#x2F;multiset：使用“红黑树”实现，是一种高度平衡的二叉树，如果大家不了解红黑树，可以去百度一下。了解个大概就可以了。二叉树的本质决定了**set&#x2F;multiset的元素存取值取决于元素本身的值，和插入顺序无关。</p>
<p>内部元素的值依据元素的值自动排列，与插入顺序无关。set内部相同数值的元素只能出现一次，multiset内部相同数值的元素可出现多次。容器用二叉树实现，便于查找。</p>
<p>(2)   map&#x2F;multimap：使用“红黑树”实现，是一种高度平衡的二叉树。</p>
<p>内部元素是成对的“key&#x2F;value”，也就是“键值&#x2F;实值”，内部元素依据其键值自动排序，map内部相同的键值只能出现一次，multimap则可以出现多次。</p>
<ol start="3">
<li>无序式容器（unordered container）：</li>
</ol>
<p>(1)   unordered_map&#x2F;unordered_multimap：使用“哈希表”实现的，由于哈希表的特性，实现了真正的无序。如果不理解为什么使用“哈希表”就是真正无序的，可以去百度一下“哈希表”，或者干脆直接记住就可以了。</p>
<p>使用方法也是“key&#x2F;value”，和map&#x2F;multimap类似。</p>
<p>(2)   unordered_set&#x2F;unorder_multiset：同样使用“哈希表”实现的。自然具有了哈希表实现的容器的特点。</p>
<p>使用方法和setl&#x2F;multiset类似。</p>
<ol start="4">
<li>关联式容器和无序式容器的对比：</li>
</ol>
<p><strong>(1)</strong>   <strong>关联式容器都是有序的，对于那些对顺序有要求的操作，关联式容器效率会高很多。（比如增加元素，删除元素）</strong></p>
<p><strong>(2)</strong>   <strong>无序容器都是真正的无序，在查找数据方面有着优势。（比如修改特定元素，查找元素）</strong></p>
<p><strong>(3)</strong>   <strong>从内存消耗的角度讲，无序容器要高于关联容器不过这并不重要。</strong></p>
<p><strong>一句话来说，如果从这两类容器中选一个使用的话。如果是增加，删除元素比较频繁，就使用关联式容器。如果修改元素，查找元素比较平凡，就使用无序容器。</strong></p>
<p><strong>5.</strong> <strong>我们在处理数据时应该选择什么容器呢？</strong></p>
<p><strong>(1)</strong>   <strong>在我们需要使用存储“key&#x2F;value</strong>”的容器时，只能使用map&#x2F;multimap&#x2F;unoredered_map&#x2F;unordered_multimap。如果增加删除频繁，就使用map&#x2F;multimap，修改，查找频繁，就使用unordered_map&#x2F;unoredered_multimap。</p>
<p><strong>(2)</strong>   <strong>在处理普通元素：</strong></p>
<p><strong>①</strong>   <strong>当元素需要频繁插入删除时，选择顺序容器。</strong></p>
<p><strong>1)</strong>     <strong>如果在尾部插入删除，选择vector</strong></p>
<p><strong>2)</strong>     <strong>在头部，尾部插入删除，选择deque</strong></p>
<p><strong>3)</strong>     <strong>在中间插入，删除，选择list</strong> </p>
<p><strong>②</strong>   <strong>当元素需要频繁查找时，选择.set&#x2F;multiset&#x2F;unorder_set&#x2F;unorder_multiset</strong>。</p>
<p><strong>1)</strong>     <strong>频繁增加，删除时，选set</strong></p>
<p><strong>2)</strong>     <strong>频繁查找，修改时，选ordered_set</strong></p>
<p><strong>我们发现，对于普通元素，容器的选择不怎么容易判断。</strong></p>
<p>其实在真正的大型项目中，要对各种容器进行测试的，普通练习一般选择vector或set就可以了。</p>
<h2 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>io就是input，output的简写，也就是输入输出功能。io功能的本质，数据在内存，磁盘，输入输出设备之间移动就是io功能。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/showlibia/img/main/clip_image002.jpg" alt="1024969-20170413201400142-220635465"></p>
<ol start="2">
<li>io库组成部分：</li>
</ol>
<p>(1)   C++定义了ios这个基类来定义输入输出的最基本操作，C++io库所有的类都继承自这个类即可。</p>
<p>(2)   istream，ostream这两个类直接继承自ios类。</p>
<p>①   ostream类定义了从内存到输出设备（比如显示器）的功能，我们最常使用的cout就是ostream类的对象。</p>
<p>②   istream类定义了从输入设备比如键盘）到内存的功能，我们最常用的cin就是istream类的对象。</p>
<p><strong>③</strong>   <strong>iostream</strong>文件定义了ostream和istream类的对象，就是cout和cin。所以我们只要简单的引入iostream这个头文件，就可以方便的使用这两个对象</p>
<p><strong>注意：这个输入，输入时相对于内存来说的，输入到内存，是istream</strong>。</p>
<p>(3)   ifstream，ofstream类分别继承自istream类和ostream类。</p>
<p>①   ifstream定义了从磁盘到内存的功能。因为istream重载了“&lt;&lt;”运算符，所以ifstream对象也可以用“&lt;&lt;”运算符来将文件数据写入内存。除了“&#x3D;”的所有重载运算符都是可以被继承的。</p>
<p>②   ofstream定义了从内存到磁盘的功能。与ifstream同理，也可以用“&gt;&gt;”操作数据流。</p>
<p><strong>③</strong>   <strong>fstream</strong>文件引入了ifstream和ofstream，所以我们只要引入ftream这个头文件，就可以使用文件流功能了。</p>
<p>注意：这个输入输出同样是相对内存来说的。</p>
<p>内存与输入输出设备的数据流动，磁盘与内存的数据流动已经介绍完了。磁盘和输入输出设备直接无法直接交互，必须通过内存。</p>
<p>io库还为我们额外定义了字符串的输入输出类，因为对字符串的操作极为频繁，所以这个库还是很有意义的。</p>
<p>(4)   istringstream，ostringstream分别继承自istream类和ostream类</p>
<p>①   istringstream定义了从指定字符串到特定内存的功能。与ifstream同理，也可以用“&lt;&lt;”运算符操作数据。</p>
<p>②   ostringstream定义了从特定内存到指定字符串的功能。可以用“&gt;&gt;”操作数据。</p>
<p><strong>③</strong>   <strong>sstream</strong>头文件就引入了istringstream和ostringstream，所以我们只要引入sstream这个头文集，就可以使用字符串与内存直接交互数据的功能。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>1.</strong> <strong>io</strong>对象无法使用拷贝构造函数和赋值运算符</p>
<p>所以我们使用流对象无法使用值传递，一般使用引用进行传递。</p>
<p><strong>2.</strong> <strong>Io</strong>对象的状态</p>
<p><strong>(1)</strong>   <strong>io</strong>操作是非常容易出现错误的操作，一些错误是可以修复的，另一部分则发生在系统更深处，已经超出了应用程序可以修正的范围。</p>
<p>比如我们使用cin向一个int类型的数中输入一个字符串，会使cin这个对象出现错误。</p>
<p><strong>所以我们在使用io</strong>对象时都应该判断io对象的状态。</p>
<p><strong>比如：while(cin &gt;&gt; val)</strong> **或if(cin &gt;&gt; val)**（不要只用这两个进行控制，最好搭配iostate来使用）</p>
<p>(2)   我们需要知道流对象错误的原因，因为不同的错误需要不同的处理方法。</p>
<p>io库定义了iostate类型，可以完整的表示io对象当前的状态。在不同的平台中，  iostate实现方法略有区别，在vs中直接用int来代表iostate类型，将不同的位置1 以表示不同的状态。可以与位操作符一起使用来一次检测或设置多个标志位。</p>
<p>可以用<strong>rdstat</strong>函数来获得io对象当前用iostat类型来表示的状态：</p>
<p>(3)   iostata类型有以下状态</p>
<p>①   badbit状态，系统级错误，一旦表示badbit的位被置为1，流对象就再也无法使用了。</p>
<p>②   failbit状态，代表可恢复错误，比如想读取一个数字却读取了一个字符，这种错误就是可以恢复的。当badbit位被置1时，failbit位也会被置1。</p>
<p>③   eofbit状态，当到达文件结束位置时，eofbit和failbit位都会被置1。</p>
<p>④   goodbit状态，表示流对象没有任何错误。</p>
<p>只要badbit，failbit，eofbit有一位被置为1，则检测流状态的条件就会失败。</p>
<p>(4)   标准库还定义了一组成员函数来查询这些标志位的状态</p>
<p>①   good()函数在所有错误位均未置1的情况下返回true。</p>
<p>②   bad()，fail()，eof()函数在对应位被置1的情况下返回true。因为badbit位被置1或eofbit位被置1时，failbit位也会被置为1。所以用fail()函数可以准确判断出流对象是否出现错误。</p>
<p>③   实际上，我们将流对象当做条件使用的代码就等价于“!fail()”</p>
<p>(5)   流对象的管理</p>
<p>①   rdstate函数，返回一个iostate值，对应当前流状态</p>
<p>②   setstate(flag) 函数，将流对象设置为想要的状态</p>
<p>③   clear函数：是一个重载的函数。</p>
<ol>
<li><pre><code>clear()，将所有位置0，也就是goodbit状态。
</code></pre>
</li>
<li><pre><code>clear(flag)，将对应的条件状态标志位复位。
</code></pre>
</li>
</ol>
<p>④   ignore函数：</p>
<p>作用：提取输入字符并丢弃他们。</p>
<p>函数原型：istream&amp; ignore (streamsize n &#x3D; 1, int delim &#x3D; EOF)</p>
<p>读取到前n个字符或在读这n个字符进程中遇到delim字符就停止，把读取的这些东西丢掉</p>
<h3 id="内存输入输出设备的交互（iostream）"><a href="#内存输入输出设备的交互（iostream）" class="headerlink" title="内存输入输出设备的交互（iostream）"></a>内存输入输出设备的交互（iostream）</h3><p><strong>1.</strong> <strong>getline</strong>：</p>
<p>其实iostream已经没什么好讲的了，比较常用的就是这个getline了，getline其实并不复杂，不过是按行接收数据罢了，<strong>因为存储string</strong>对象中，所以不容易出现格式错误，但仍然可能出现系统错误，所以在企业级程序中，还是应当对bad的情况进行处理。</p>
<p><strong>2.</strong> <strong>get:</strong></p>
<p>还有个不怎么常用的get函数。get函数的用法和getline类似，只不过get是以字符的格式进行接收。<strong>在企业级代码中仍然需要对bad的情况进行处理。</strong></p>
<h3 id="内存与磁盘的交互（fstream）"><a href="#内存与磁盘的交互（fstream）" class="headerlink" title="内存与磁盘的交互（fstream）"></a>内存与磁盘的交互（fstream）</h3><ol>
<li>fstream相对于iostream。多了很多自己独有的操作</li>
</ol>
<p>(1)io库默认没有给ifstream和ofstream类提供对象，需要我们自己去定义。</p>
<p>(2) fstream对象创建方式有三种</p>
<p>①   可以使用默认构造函数进行定义。例如： ifstream fstrm，</p>
<p>②   也可以在创建流对象时打开想要打开的文件。例如ifstream fstrm(s)。s可以是字符串，也可以是c风格的字符串指针。文件的mode依赖于流对象的类型。</p>
<p>③   也可以在打开文件时就指定文件的mode。例如ifstream fstrm(s, mode)</p>
<p>(3)   fstrm.open(s)函数，打开名为s的文件，并将文件与fsrm绑定，s可以是一个string，也可以是一个c风格的字符串指针。</p>
<p><strong>(4)</strong>   fstrm.close()函数，关闭文件。<strong>注意，一定不要忘了。</strong></p>
<p>(5)   fstrm.is_open()函数，返回一个bool值，指出与fstrm关联的文件是否成功打开且尚未关闭。</p>
<ol start="2">
<li>文件模式：</li>
</ol>
<p>(1)   in以读的方式打开</p>
<p>(2)   out以写的方式打开</p>
<p>(3)   app在进行写操作时定位到文件末尾</p>
<p>(4)   ate打开文件后立即定位到文件末尾</p>
<p>(5)   trunc截断文件（也就是文件已有的全部删除，重新开始写）</p>
<p>(6)   binary以二进制方式打开文件</p>
<ol start="3">
<li>文件模式需要强调以下几点</li>
</ol>
<p>(1)   与ifstream关联的文件默认in模式打开。</p>
<p>(2)   与ofstream关联的文件默认out模式打开</p>
<p>(3)   与fstream关联的文件默认in和out模式打开</p>
<p>(4)   默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保持以out模式打开的文件的内容，我们必须同时指定app模式或in模式。</p>
<p>(5)   只可以对ifstream或fstream的对象设定in的模式</p>
<p>(6)   只可以对ofstream或fstream的对象设定out的模式</p>
<p>(7)   只有当out模式被设置时才可以设置trunc模式</p>
<p>(8)   ate和binary模式可以应用与任何类型的文件流对象，且可以与任何其它文件模式组合使用。</p>
<h3 id="内存之中对于字符串的操作（sstream）"><a href="#内存之中对于字符串的操作（sstream）" class="headerlink" title="内存之中对于字符串的操作（sstream）"></a>内存之中对于字符串的操作（sstream）</h3><ol>
<li><p>string流介绍：string流可以向string对象写入数据，也可以从string对象读取数据。与文件操作类似，只不过数据交互变成了从内存到内存。</p>
</li>
<li><p>string流有哪些</p>
</li>
</ol>
<p>(1)   istringstream从string对象读取数据</p>
<p>(2)   ostringstream向string对象写数据</p>
<p>(3)   stringstream既可以从string对象读取数据，也可以向string对象写数据</p>
<ol start="3">
<li>string流对象继承自iostream对象，除了继承得来的操作，string流对象还有自己的成员来管理流相关的string。</li>
</ol>
<p>(1)   对于string流，io库是没有像cout，cin这样的自定流对象的。流对象需要我们自己去定义</p>
<p>①   sstream strm：sstream代表一个string流对象的类型，以下同理。strm是一个未绑定的stringstream对象。</p>
<p>②   Sstream strm(s)：strm是一个绑定了s的拷贝的string流对象。s是一个string对象</p>
<p>(2)   strm.str()：返回strm所保存的string的拷贝。</p>
<p>(3)   strm.str(s)：将s拷贝到strm中，返回void</p>
<ol start="4">
<li>string流对象的作用</li>
</ol>
<p><strong>(1)</strong>   <strong>对数据类型进行转化，也就是string<strong><strong>和其它类型的转化，这是string</strong></strong>流对象最重要的功能。</strong></p>
<p>①   string转化为int等类型。</p>
<p>②   int等类型转化为string。</p>
<p>(2)   用于对空格分隔的字符串的切分，</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-多线程基本概念介绍"><a href="#1-多线程基本概念介绍" class="headerlink" title="1. 多线程基本概念介绍"></a>1. 多线程基本概念介绍</h3><p><strong>1.</strong> <strong>多线程的重要性：</strong></p>
<p>(1)   对于一个专业的C++开发来说，多线程是必须掌握的模块。</p>
<p>(2)   现代程序都是多线程程序了。因为单核处理器的性能早已经达到了瓶颈，只能往多核方向发展。现代的个人计算机都是4核起步，工作站，服务器就更不用说了。</p>
<p>(3)   工作站可以理解为处理能力更强的大型个人计算机，常见的12核，16核。服务器有48核的，甚至更多。</p>
<p>(4)   对于一个计算机来说，是不是说核越多好呢？不是，多核会导致单核的工作性能下降。当核数多到一定程度后，反而总体运行效率下降了。不过，这并不影响现代计算机核数越来越多的趋势。</p>
<p>(5)   传统的单线程程序同时只能在一个核上运行，这是不是太浪费资源了。计算机有8个核，你就用了一个，暴殄天物啊。多线程程序可以使用多个核，极大提高程序运行效率。现在网络通信，音频，视频，游戏服务都是多线程程序。 </p>
<p><strong>2.</strong> <strong>并发与并行的概念介绍：</strong></p>
<p>(1)   一句话来说：并行是同时在不同的处理器上处理不同的任务，并发是“同时”在一个处理器上处理多个任务。</p>
<p>解释一下：</p>
<p>①   并行是指有多个处理器。每个处理器各执行一个线程，互不抢占cpu资源，如果线程数量多于CPU，也没有办法，只能将处理器的时间划分为多个时间段，再将时间段分配给各个线程。</p>
<p>②   并发是指只有一个处理器，但多个线程被轮换快速执行，使得宏观上有了同时执行的效果。作用原理是将单处理器的时间划分为多个时间段，再分配给不同的线程。同一时间段只能有一个线程在运行，其它线程均处于挂起状态。</p>
<p><strong>3.</strong> <strong>进程的概念：</strong></p>
<p>(1)   进程的概念在面向进程设计的操作系统（就是unix，也包括后面衍生出的linux，mac）和面向线程设计的操作系统（说的就是windows）上有很大区别，两种设计方式的共同点与不同点还是需要理解的。</p>
<p>①   进程是计算机中的程序对某些数据集合的一次运行活动，是系统进行资源分配和调度的最基本单位，是操作系统的结构基础。再用大白话说一遍，一个可执行程序执行起来，就是一个进程。当然，一个程序要执行起来需要各种资源，这些资源就是数据集合。</p>
<p>②   在面向进程设计的计算机结构中，进程是程序的基本执行单位，进程包括程序执行的所有资源，同时自己也可以执行。</p>
<p>③   在面向线程设计的计算机结构中，线程才是程序的基本执行单位，进程不过是线程的容器罢了。进程就像一个仓库，里面存放了程序的所有资源，进程中的线程才是真正执行程序的单元。</p>
<p><strong>4.</strong> <strong>线程的概念：</strong></p>
<p>(1)   linux的线程和windows的线程还是有很大区别的。</p>
<p>(2)   linux的线程就是一种轻量级的进程，只有依靠进程才可以存在。也模拟出了windows线程的方式，让线程成为真正的执行单元。</p>
<p>(3)   windows的线程就简单多了，真正执行程序的最小单元。</p>
<h3 id="2-线程的创建"><a href="#2-线程的创建" class="headerlink" title="2.线程的创建"></a>2.线程的创建</h3><ol>
<li><p>主线程介绍：一个程序执行起来就是一个进程。而main函数就是主线程，一旦主线程执行完毕，主线程结束，整个进程就会结束。</p>
</li>
<li><p>子线程介绍：在一个线程执行时，我们可以创建出另外一个线程。两个线程各自执行，互补干涉。注意，当主线程执行完毕，就会强制结束所有子线程，然后进程结束，从这个角度来说，可以认为子线程是主线程的辅助线程。<strong>但是要明白主线程和子线程是平级的，只不过主线程执行完毕后会给所有子线程发送一个信号，使所有子线程强制结束。</strong></p>
</li>
<li><p>子线程的创建方式：很简单，直接使用thread类就可以了。</p>
</li>
<li><p><strong>子线程创建后如果就不管了，那么会出现非常严重的问题。</strong></p>
</li>
</ol>
<p>(1)   有些子线程负责对部分数据的处理，主线程必须要等到子线程处理完毕才能继续执行，所以join函数就诞生了。</p>
<p>使用了join函数后，主线程就会处于挂起状态，直到子线程执行完毕才可以继续执行。</p>
<p>(2)   有些子线程和主线程完全分离，各自执行各自的。但主线程执行完毕，<strong>子线程就会立马被强制结束，容易导致各种</strong>bug，查都不知道从哪里开始查。于是deatch函数就诞生了。</p>
<p>detach()函数可以让<strong>子线程被C++运行库接管</strong>，就算主线程执行完毕，子线程也会由C++运行时库清理相关资源。保证不会出现各种意想不到的bug。</p>
<h3 id="3-传递线程参数"><a href="#3-传递线程参数" class="headerlink" title="3.传递线程参数"></a>3.传递线程参数</h3><p>(1) 传递子线程函数的参数：直接传递即可，注意：传递参数分为三种方式，值传递，引用传递，指针传递。</p>
<p>(2) 传递参数注意事项：</p>
<p>①   在使用detach时不要传递指针，或者说在设置子线程函数时，不要设置指针参数。因为值传递和引用传递并未直接传递地址，而指针传递却直接传递地址。所以当使用deatch时，传指针就会导致错误，指针已经被系统回收，所以不要千万不要传指针。</p>
<p><strong>②</strong>   <strong>在使用detach</strong>时不要使用隐式类型转化，因为很有可能子线程参数还没来的及将参数转化为自己的类型，主线程就已经执行完毕了。</p>
<p><strong>(3)</strong> <strong>总结：</strong></p>
<p><strong>①</strong>   <strong>普通类型在传递子线程函数参数时，直接值传递即可。</strong></p>
<p><strong>②</strong>   <strong>类类型传递引用就可以了，类类型传递引用会首先调用一次复制构造函数生成一个临时变量，故而导致地址不相同。如果采用值传递，需要两次复制构造函数，开销更大。</strong></p>
<p><strong>(4)</strong> <strong>std::ref</strong>的用法：</p>
<p>使用普通的引用传递会调用一次复制构造函数，导致函数无法对引用对象进行修改，于是std::ref诞生了，它可以使子线程在传递参数时不再调用复制构造函数。</p>
<h3 id="4-线程id的概念："><a href="#4-线程id的概念：" class="headerlink" title="4.线程id的概念："></a>4.线程id的概念：</h3><ol>
<li><p>线程id定义：每个线程都有自己的id，不管是主线程还是子线程都有自己的id。直接使用std::this_thread::get_id()就可以获得当前线程的id。</p>
</li>
<li><p>注意：线程是依附于进程存在的，所以不同的进程可以有相同的线程id。</p>
</li>
</ol>
<h3 id="5-数据共享与数据保护"><a href="#5-数据共享与数据保护" class="headerlink" title="5. 数据共享与数据保护"></a>5. 数据共享与数据保护</h3><ol>
<li><p>多个线程的执行顺序是乱的，具体执行方法和处理器的调度机制有关系。从开发者的角度讲，就是没有规律的。</p>
</li>
<li><p>在讲数据保护问题之前，为了帮助大家理解数据保护问题，这里额外扩展一些关于汇编的知识。</p>
</li>
</ol>
<p>一个进程运行时，数据存储在内存中。如果一个数据要进行运算，必须先将数据拷贝到寄存器中。比如要对栈上的一个int i进行“++”操作，需要将i的值拷贝到寄存器中，将该值自加后再拷贝到原来的内存。</p>
<p>如果此时有两个线程均进行的是这样的操作，可能出现两个进程都拷贝了i原来的值到寄存器，然后各种加一，再拷贝到i对应内存的情况，最终导致i这个变量只自加了一次。</p>
<p>这是同时写数据的情况，那么一读一写呢？这也是有问题的，谁知道读数据时写数据步骤已经到了哪里，谁知道读出来的是个什么东西。</p>
<ol start="3">
<li>数据保护问题：</li>
</ol>
<p>(1)   数据保护问题总共有三种情况：</p>
<p>①   至少两个线程对共享数据均进行读操作，完全不会出现数据安全问题。</p>
<p>②   至少两个线程对共享数据均进行写操作，会出现数据安全问题，需要数据保护。</p>
<p>③   至少两个线程对共享数据有的进行读，有的进行写，也会出现数据安全问题，需要进行数据保护。</p>
<p>数据保护的方法一共就两种：互斥锁，原子操作。</p>
<p><strong>4.</strong> <strong>互斥锁：</strong></p>
<p>(1)   互斥锁的作用原理很简单，对共享数据加锁，当一个线程对这块数据进行操作时，别的线程就无法对该区域数据进行操作。</p>
<p>(2)   这种方式的互斥锁有个弊端，就是lock()之后容易忘记unlock()，就和指针类似。于是和智能指针类似，也有了lock_guard，用来防止开发人员忘了解锁。</p>
<ol start="5">
<li>原子操作：（使用频率远远不及互斥锁）</li>
</ol>
<p>(3)   原子操作的原理：将一个数据设置为原子状态，使得该数据处于无法被分割的状态，意思就是处理器在处理被设置为原子状态的数据时，其它处理器无法处理该段数据，该处理器也会保证在处理完该数据之前不会处理其他数据。</p>
<p>总结：在编写多线程代码时，数据保护是一个必须考虑，非常常用的功能。互斥锁的使用频率是远远高于原子操作，原子操作看似简单，但当需要保护的数据很多时，就会极其复杂。</p>
<p><strong>所以：对于单个数据，可以使用原子操作，其它的使用互斥锁就可以了。</strong></p>
<h3 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6. 死锁"></a>6. 死锁</h3><p>死锁就像两个人在互相等对方。A说，等B来了就去B现在所在的地方；B说，等A来了我就去A所在的地方，结果就是A和B都在等对面过来才能去对面。这就导致了一个死循环，放在多线程中，就是死锁。</p>
<p>举个例子：</p>
<p>解决方法也很简单。</p>
<ol>
<li><p>只要让两个锁顺序一致就可以了。</p>
</li>
<li><p>但是让两个锁顺序一致常常是说起来容易，做起来难。于是C++11提供了std::lock。这个模板可以保证多个互斥锁绝对不会出现死锁的问题。同时提供了std::adopt_lock的功能来避免忘记释放锁的问题。</p>
</li>
</ol>
<p><strong>总结：死锁是一个比较常见的bug</strong>，面试时也经常询问死锁相关的知识。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>异常处理的前情提要：很多人不喜欢使用异常处理，认为它麻烦，应对可能出现的错误要写那么多代码，会非常麻烦。</strong></p>
<p><strong>但实际上不是这样的，我们只需要在一些开发人员难以控制，比较容易出错的地方对异常进行处理就可以了，需要进行异常处理的地方并不多。</strong></p>
<p>举几个例子。</p>
<ol>
<li><p>接收传递过来的被除数，我们难以判断被除数是否为0，此时异常处理就很有意义了。</p>
</li>
<li><p>接收文件名，如果文件不存在，我们可以按照之前的写法要求重发一遍，也可以直接报异常，异常就是文件不存在。</p>
</li>
<li><p>我们在动态分配内存时，经常出现内存不足的情况（在大型程序中，这是非常常见）。比如我们需要动态分配一个未知大小的数组，数组大小等待传入。使用new操作符会直接抛出bad_alloc的异常。</p>
</li>
</ol>
<p>对new的处理非常重要，大家如果做专业的C++开发，会经常用到。</p>
<p>此外使用智能指针时如果内存分配不够也会抛出bad_alloc的异常</p>
<ol start="4">
<li>有个vector，我们需要接受一个参数，然后取出参数对应的数组元素。此时就经常出现数组的越界问题。</li>
</ol>
<h3 id="1-异常处理的介绍："><a href="#1-异常处理的介绍：" class="headerlink" title="1. 异常处理的介绍："></a>1. 异常处理的介绍：</h3><ol>
<li><p><strong>异常是程序在执行期间产生的问题（编译期出现的错误在写代码时开发环境就有提示）</strong>。C++的异常是指程序运行时发生的特殊情况。</p>
</li>
<li><p>异常提供了一种转移程序控制权的方式。C++的异常处理涉及到三个关键字：try，catch，throw。</p>
</li>
</ol>
<p>(1)   throw：当问题出现时，程序会抛出一个异常。这是通过throw关键字来完成的。</p>
<p>(2)   catch：在你想要处理问题的地方，通过异常处理程序捕获异常。catch关键字用于捕获异常。</p>
<p>(3)   try：try块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个catch块。</p>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用try和catch关键字。try块中放可能抛出异常的代码，try块中的代码被称为保护代码。常见的异常处理格式如图所示。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/showlibia/img/main/clip_image001.png"></p>
<ol start="3">
<li>抛出异常：throw语句可以在代码块的任何地方抛出异常，throw抛出的表达式的结果决定了抛出的异常的类型。</li>
</ol>
<h3 id="2-C-的标准异常"><a href="#2-C-的标准异常" class="headerlink" title="2. C++的标准异常"></a>2. C++的标准异常</h3><ol>
<li>C++提供了一系列标准的异常，定义在头文件“<exception>”中，它们是以父子层次结构组织起来的，如下图所示。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/showlibia/img/main/clip_image003.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/showlibia/img/main/clip_image005.png"></p>
<ol start="2">
<li>别看图很复杂，异常种类有很多，但经常使用的其实就几个。</li>
</ol>
<p>(1)   bad_alloc错误，使用new分配内存失败就会抛出bad_alloc错误。</p>
<p>(2)   out_of_range错误，在使用at时，容器越界就会抛出这个错误，这也是“at”比“[]”更加优秀的原因。</p>
<p>(3)   runtime_error错误，运行时错误，只有在程序运行时才能检测到的错误。这是一个相对的概念，和logic_error形成对比。logic_error可以读代码读出来，runtime_error就不行。</p>
<p>我们也经常将一些读代码无法判断的异常标识为runtime_error。</p>
<p>(4)   … 错误，可以接受任何错误，我们一般都会在catch最后加上“…”，这样就可以接受所有类型的异常了。</p>
<ol start="3">
<li>自定义异常类型，其实需要自定义异常类型的情况真的非常少，这里就不介绍了，其实和标准异常也是一样的。</li>
</ol>
<h2 id="各种难以归类但有使用价值的知识点"><a href="#各种难以归类但有使用价值的知识点" class="headerlink" title="各种难以归类但有使用价值的知识点"></a>各种难以归类但有使用价值的知识点</h2><h4 id="1-万能引用与引用折叠"><a href="#1-万能引用与引用折叠" class="headerlink" title="1. 万能引用与引用折叠"></a>1. 万能引用与引用折叠</h4><ol>
<li>万能引用的概念：</li>
</ol>
<p>(1)   C++11除了带来了右值引用，还带来了万能引用，也就是既能当做左值，又能当做右值的引用。</p>
<p>注意：万能引用是既可以被编译期处理为左值引用，又可以被编译期处理为右值引用。<strong>不是既是左值引用又是右值引用，不违背C++一个引用不是左值引用，就是右值引用的基本说法，万能引用会在编译期被当做左值引用或右值引用处理。</strong></p>
<ol start="2">
<li>万能引用的格式：万能引用的格式有两种</li>
</ol>
<p>(1)   模板型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; parm)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>这个T&amp;&amp;</strong> <strong>就是万能引用类型。</strong></p>
<p><strong>注意：只有T&amp;&amp;</strong> <strong>是万能引用类型</strong></p>
<p><strong>以下的写法均不是万能引用：</strong></p>
<p><strong>const T&amp;&amp; parm</strong>    <strong>这就是普通的右值引用。</strong></p>
<p><strong>vector<T> &amp;&amp; parm</strong>  <strong>这也是右值引用。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; elem)</span></span>;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>



<p><strong>注意：此时T&amp;&amp;</strong> 不是万能引用，因为T影响的是MyVector的类型。</p>
<p><strong>只有这样写，才是万能引用。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">push_back</span><span class="params">(T2&amp;&amp; elem)</span></span>;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p><strong>此时T2&amp;&amp;</strong> <strong>的类型完全独立于MyVector</strong>类了，每调用一次push_back函数，都要推断T2的类型。</p>
<p>(2)   auto型：</p>
<p>auto &amp;&amp; var &#x3D; var2；</p>
<p>这个auto&amp;&amp; 就是万能引用。</p>
<p><strong>const auto&amp;&amp; var</strong> <strong>就不是万能引用了。</strong></p>
<ol start="3">
<li><p>万能引用的作用，就是当参数为左值时。T&amp;&amp;为左值。当参数为右值时，T&amp;&amp; 为右值。就这么简单。</p>
</li>
<li><p>引用折叠：引用折叠其实概念很简单</p>
</li>
</ol>
<p>一个引用不是左值引用就是右值引用，当一个万能引用被认为左值引用时，类型应该是T&amp; &amp;&amp;，此时类型就会折叠为T&amp;。</p>
<p>简单来说，就是引用符号太多了，折叠为“&amp;”或“&amp;&amp;”</p>
<h4 id="2-完美转发"><a href="#2-完美转发" class="headerlink" title="2. 完美转发"></a>2. 完美转发</h4><ol>
<li><p>C++完美转发的定义：完美转发是什么呢？说到底，它描述的其实就是一个参数传递的过程，能够将一个传递到一个函数的参数，再通过该函数原封不动的传递给另一个函数（<strong>这里的原封不动不单是指参数的值，更包括参数的类型，参数的限定符</strong>）</p>
</li>
<li><p>我们发现以前的传递参数的方法都无法在万能引用中解决完美转发的问题。</p>
</li>
<li><p>于是C++提供了forward模板来解决完美转发的问题，forward模板可以使参数推断出它原来的类型，实现了完美转发。</p>
</li>
</ol>
<p><strong>4.</strong> <strong>总结：完美转发就是一个专门配合万能引用的知识点，专门用来在使用万能引用的地方原封不动的传递参数。其实记住它是和万能引用配合使用的就掌握的差不多了，</strong></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" title="头像" alt="头像"></a><div class="post-copyright__author_name">Matrix</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://blog.zymatrix.top/2024/09/11/C++%E5%9F%BA%E7%A1%80/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://blog.zymatrix.top/2024/09/11/C++%E5%9F%BA%E7%A1%80/')">C++基础</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://blog.zymatrix.top/2024/09/11/C++%E5%9F%BA%E7%A1%80/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++基础&amp;url=http://blog.zymatrix.top/2024/09/11/C++%E5%9F%BA%E7%A1%80/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.zymatrix.top" target="_blank">Matrix's blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/null" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/09/07/MyBatis%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MyBatis学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">那时她还年轻，不知道命运馈赠的礼物都在暗中标好了价格</div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.</span> <span class="toc-text">学习思路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">C++基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">基本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">程序执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">const关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.2.</span> <span class="toc-text">auto关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F-%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">静态变量 指针 引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E5%80%BC"><span class="toc-number">2.1.4.</span> <span class="toc-text">左右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.5.</span> <span class="toc-text">move函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">2.1.5.0.1.</span> <span class="toc-text">临时对象：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.6.</span> <span class="toc-text">可调用对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.1.6.0.1.</span> <span class="toc-text">1. 函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.1.6.0.2.</span> <span class="toc-text">2. 仿函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.1.6.0.3.</span> <span class="toc-text">3. lambda表达式：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%EF%BC%8C%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">this，常成员函数与常对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">一些关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.3.</span> <span class="toc-text">重载运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.4.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.5.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTTI"><span class="toc-number">2.2.6.</span> <span class="toc-text">RTTI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.7.</span> <span class="toc-text">移动构造函数与移动赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.3.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">2.3.1.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">2.3.2.</span> <span class="toc-text">weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">2.3.3.</span> <span class="toc-text">unique_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D%EF%BC%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">模板介绍，类模板与模板实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initializer-list%E4%B8%8Etypename"><span class="toc-number">2.4.2.</span> <span class="toc-text">initializer_list与typename</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%8C%E5%85%A8%E7%89%B9%E5%8C%96%E5%92%8C%E5%81%8F%E7%89%B9%E5%8C%96"><span class="toc-number">2.4.3.</span> <span class="toc-text">模板的重载，全特化和偏特化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-number">2.5.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%BA%93"><span class="toc-number">2.6.</span> <span class="toc-text">IO库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.6.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%88iostream%EF%BC%89"><span class="toc-number">2.6.3.</span> <span class="toc-text">内存输入输出设备的交互（iostream）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E7%A3%81%E7%9B%98%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%88fstream%EF%BC%89"><span class="toc-number">2.6.4.</span> <span class="toc-text">内存与磁盘的交互（fstream）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B9%8B%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88sstream%EF%BC%89"><span class="toc-number">2.6.5.</span> <span class="toc-text">内存之中对于字符串的操作（sstream）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.7.1.</span> <span class="toc-text">1. 多线程基本概念介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.7.2.</span> <span class="toc-text">2.线程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%A0%E9%80%92%E7%BA%BF%E7%A8%8B%E5%8F%82%E6%95%B0"><span class="toc-number">2.7.3.</span> <span class="toc-text">3.传递线程参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8Bid%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">2.7.4.</span> <span class="toc-text">4.线程id的概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.7.5.</span> <span class="toc-text">5. 数据共享与数据保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%AD%BB%E9%94%81"><span class="toc-number">2.7.6.</span> <span class="toc-text">6. 死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.8.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">2.8.1.</span> <span class="toc-text">1. 异常处理的介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-C-%E7%9A%84%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-number">2.8.2.</span> <span class="toc-text">2. C++的标准异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E9%9A%BE%E4%BB%A5%E5%BD%92%E7%B1%BB%E4%BD%86%E6%9C%89%E4%BD%BF%E7%94%A8%E4%BB%B7%E5%80%BC%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.9.</span> <span class="toc-text">各种难以归类但有使用价值的知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%8E%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="toc-number">2.9.0.1.</span> <span class="toc-text">1. 万能引用与引用折叠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">2.9.0.2.</span> <span class="toc-text">2. 完美转发</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/11/C++%E5%9F%BA%E7%A1%80/" title="C++基础">C++基础</a><time datetime="2024-09-10T16:00:00.000Z" title="发表于 2024-09-11 00:00:00">2024-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/07/MyBatis%E7%AC%94%E8%AE%B0/" title="MyBatis学习笔记">MyBatis学习笔记</a><time datetime="2024-09-06T16:00:00.000Z" title="发表于 2024-09-07 00:00:00">2024-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/07/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" title="Java后端学习笔记">Java后端学习笔记</a><time datetime="2024-09-06T16:00:00.000Z" title="发表于 2024-09-07 00:00:00">2024-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/07/MySQL%E7%AC%94%E8%AE%B0/" title="MySQL学习笔记">MySQL学习笔记</a><time datetime="2024-09-06T16:00:00.000Z" title="发表于 2024-09-07 00:00:00">2024-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/12/JavaSE/" title="JavaSE">JavaSE</a><time datetime="2024-08-11T16:00:00.000Z" title="发表于 2024-08-12 00:00:00">2024-08-12</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2024 By <a class="footer-bar-link" href="/" title="Matrix" target="_blank">Matrix</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.zymatrix.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>1</sup></a><a href="/tags/CTF/" style="font-size: 0.88rem;">CTF<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>2</sup></a><a href="/tags/JavaSE/" style="font-size: 0.88rem;">JavaSE<sup>1</sup></a><a href="/tags/Linux-Kernel/" style="font-size: 0.88rem;">Linux Kernel<sup>1</sup></a><a href="/tags/OS/" style="font-size: 0.88rem;">OS<sup>2</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>1</sup></a><a href="/tags/Web%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">Web后端<sup>1</sup></a><a href="/tags/csapp/" style="font-size: 0.88rem;">csapp<sup>1</sup></a><a href="/tags/%E5%93%B2%E5%AD%A6/" style="font-size: 0.88rem;">哲学<sup>5</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%9D%82%E8%AE%B0/" style="font-size: 0.88rem;">杂记<sup>3</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">汇编语言<sup>1</sup></a><a href="/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/" style="font-size: 0.88rem;">马列毛<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/06/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Matrix 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/06/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>