<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matrix&#39;s blog</title>
  
  
  <link href="http://blog.zymatrix.top/atom.xml" rel="self"/>
  
  <link href="http://blog.zymatrix.top/"/>
  <updated>2024-11-01T14:04:42.840Z</updated>
  <id>http://blog.zymatrix.top/</id>
  
  <author>
    <name>Matrix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rCore-ch1</title>
    <link href="http://blog.zymatrix.top/2024/10/30/2024-10-30-rCore-ch1/"/>
    <id>http://blog.zymatrix.top/2024/10/30/2024-10-30-rCore-ch1/</id>
    <published>2024-10-29T16:00:00.000Z</published>
    <updated>2024-11-01T14:04:42.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用程序与基本执行环境"><a href="#应用程序与基本执行环境" class="headerlink" title="应用程序与基本执行环境"></a>应用程序与基本执行环境</h1><h2 id="应用程序执行环境"><a href="#应用程序执行环境" class="headerlink" title="应用程序执行环境"></a>应用程序执行环境</h2><p><img src="https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/app-software-stack.png" alt="../_images/app-software-stack.png"></p><blockquote><p>All problems in computer science can be solved by another level of indirection。</p><p>– David Wheeler</p></blockquote><p>在计算机领域中，抽象是一种深刻的哲学、深入软件开发的指导思想。</p><p>应用程序通过调用编程语言提供的标准库或者其他三方库的API接口，仅需少量代码就能完成复杂的功能。</p><p>从操作系统内核的角度看来，它上面的一切都属于用户态软件，而它自身属于内核态软件。无论用户态应用如何编写，是手写汇编代码，还是基于某种高级编程语言调用其标准库或三方库，某些功能总要直接或间接的通过操作系统内核提供的 <strong>系统调用</strong> (System Call) 来实现。因此系统调用充当了用户和内核之间的边界。内核作为用户态软件的执行环境，它不仅要提供系统调用接口，还需要对用户态软件的执行进行监控和管理。</p><p>从硬件的角度来看，它上面的一切都属于软件。硬件可以分为三种： 处理器 (Processor，也称CPU)，内存 (Memory) 还有 I&#x2F;O 设备。其中处理器无疑是其中最复杂，同时也最关键的一个。它与软件约定一套 <strong>指令集体系结构</strong> (ISA, Instruction Set Architecture)，使得软件可以通过 ISA 中提供的机器指令来访问各种硬件资源。软件当然也需要知道处理器会如何执行这些指令，以及指令执行后的结果。当然，实际的情况远比这个要复杂得多，为了适应现代应用程序的场景，处理器还需要提供很多额外的机制（如特权级、页表、TLB、异常&#x2F;中断响应等）来管理应用程序的执行过程，而不仅仅是让数据在 CPU 寄存器、内存和 I&#x2F;O 设备三者之间流动。</p><h2 id="内核与裸机平台"><a href="#内核与裸机平台" class="headerlink" title="内核与裸机平台"></a>内核与裸机平台</h2><p>由于我们要在裸机平台编写内核LibOS,而不是在OS上编写应用程序,而Rust标准库std需要依赖操作系统提供的系统调用, 这就导致我们无法使用std.不过, Rust提供了一个不需要任何操作系统支持的核心库core,可以满足我们的大部分开发需求.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><p><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/index.html#">rCore-ch1</a></p></li><li><p><a href="https://os.phil-opp.com/freestanding-rust-binary/">BlogOS</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;应用程序与基本执行环境&quot;&gt;&lt;a href=&quot;#应用程序与基本执行环境&quot; class=&quot;headerlink&quot; title=&quot;应用程序与基本执行环境&quot;&gt;&lt;/a&gt;应用程序与基本执行环境&lt;/h1&gt;&lt;h2 id=&quot;应用程序执行环境&quot;&gt;&lt;a href=&quot;#应用程序执行环境&quot;</summary>
      
    
    
    
    <category term="cs" scheme="http://blog.zymatrix.top/categories/cs/"/>
    
    
    <category term="Rust" scheme="http://blog.zymatrix.top/tags/Rust/"/>
    
    <category term="OS" scheme="http://blog.zymatrix.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>rCore-ch3</title>
    <link href="http://blog.zymatrix.top/2024/10/30/2024-10-30-rCore-ch3/"/>
    <id>http://blog.zymatrix.top/2024/10/30/2024-10-30-rCore-ch3/</id>
    <published>2024-10-29T16:00:00.000Z</published>
    <updated>2024-10-30T16:18:32.692Z</updated>
    
    
    
    
    <category term="cs" scheme="http://blog.zymatrix.top/categories/cs/"/>
    
    
    <category term="Rust" scheme="http://blog.zymatrix.top/tags/Rust/"/>
    
    <category term="OS" scheme="http://blog.zymatrix.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>rCore-ch3</title>
    <link href="http://blog.zymatrix.top/2024/10/11/rCore-lab1/"/>
    <id>http://blog.zymatrix.top/2024/10/11/rCore-lab1/</id>
    <published>2024-10-10T16:00:00.000Z</published>
    <updated>2024-10-13T08:21:32.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter3-编程作业"><a href="#chapter3-编程作业" class="headerlink" title="chapter3  编程作业"></a>chapter3  编程作业</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><h3 id="获取任务信息"><a href="#获取任务信息" class="headerlink" title="获取任务信息"></a>获取任务信息</h3><p>ch3 中，我们的系统已经能够支持多个任务分时轮流运行，我们希望引入一个新的系统调用 <code>sys_task_info</code> 以获取当前任务的信息，定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_task_info</span>(ti: *<span class="keyword">mut</span> TaskInfo) <span class="punctuation">-&gt;</span> <span class="type">isize</span></span><br></pre></td></tr></table></figure><ul><li>syscall ID: 410</li><li>查询当前正在执行的任务信息，任务信息包括任务控制块相关信息（任务状态）、任务使用的系统调用及调用次数、系统调用时刻距离任务第一次被调度时刻的时长（单位ms）。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskInfo</span> &#123;</span><br><span class="line">    status: TaskStatus,</span><br><span class="line">    syscall_times: [<span class="type">u32</span>; MAX_SYSCALL_NUM],</span><br><span class="line">    time: <span class="type">usize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>参数：</p><ul><li>ti: 待查询任务信息</li></ul></li><li><p>返回值：执行成功返回0，错误返回-1</p></li><li><p>说明：</p><ul><li>相关结构已在框架中给出，只需添加逻辑实现功能需求即可。</li><li>在我们的实验中，系统调用号一定小于 500，所以直接使用一个长为 <code>MAX_SYSCALL_NUM=500</code> 的数组做桶计数。</li><li>运行时间 time 返回系统调用时刻距离任务第一次被调度时刻的时长，也就是说这个时长可能包含该任务被其他任务抢占后的等待重新调度的时间。</li><li>由于查询的是当前任务的状态，因此 TaskStatus 一定是 Running。（助教起初想设计根据任务 id 查询，但是既不好定义任务 id 也不好写测例，遂放弃 QAQ）</li><li>调用 <code>sys_task_info</code> 也会对本次调用计数。</li></ul></li><li><p>提示：</p><ul><li>大胆修改已有框架！除了配置文件，你几乎可以随意修改已有框架的内容。</li><li>程序运行时间可以通过调用 <code>get_time()</code> 获取，注意任务运行总时长的单位是 ms。</li><li>系统调用次数可以考虑在进入内核态系统调用异常处理函数之后，进入具体系统调用函数之前维护。</li><li>阅读 TaskManager 的实现，思考如何维护内核控制块信息（可以在控制块可变部分加入需要的信息）。</li><li>虽然系统调用接口采用桶计数，但是内核采用相同的方法进行维护会遇到什么问题？是不是可以用其他结构计数？</li></ul></li></ul><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p><strong>tutorial中给出的提示非常重要，仔细阅读提示，对完成实验的帮助非常大！</strong></p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>首先对<code>sys_task_info</code>这个系统调用的应用场景和触发条件进行分析。</p><p>在测试文件中可以看到以下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/bin/ch3_taskinfo.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">t1</span> = <span class="title function_ invoke__">get_time</span>() <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">info</span> = TaskInfo::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="title function_ invoke__">get_time</span>();</span><br><span class="line">    <span class="title function_ invoke__">sleep</span>(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t2</span> = <span class="title function_ invoke__">get_time</span>() <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="comment">// 注意本次 task info 调用也计入</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, <span class="title function_ invoke__">task_info</span>(&amp;<span class="keyword">mut</span> info));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t3</span> = <span class="title function_ invoke__">get_time</span>() <span class="keyword">as</span> <span class="type">usize</span>;</span><br></pre></td></tr></table></figure><p>对这里的<code>get_time</code>和<code>task_info</code>两个函数进行源码追踪</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_time</span>() <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">time</span> = TimeVal::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">sys_get_time</span>(&amp;<span class="keyword">mut</span> time, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; ((time.sec &amp; <span class="number">0xffff</span>) * <span class="number">1000</span> + time.usec / <span class="number">1000</span>) <span class="keyword">as</span> <span class="type">isize</span>,</span><br><span class="line">        _ =&gt; -<span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">task_info</span>(info: &amp;<span class="keyword">mut</span> TaskInfo) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">sys_task_info</span>(info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_task_info</span>(info: &amp;<span class="keyword">mut</span> TaskInfo) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_TASK_INFO, [info <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_get_time</span>(time: &amp;<span class="keyword">mut</span> TimeVal, tz: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_GETTIMEOFDAY, [time <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>, tz, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::arch::asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这两个函数都调用了<code>syscall.rs</code>里的函数，利用系统调用来完成任务。</p><p>在第二章的文档中有如下的一段话</p><blockquote><p>在子模块 <code>syscall</code> 中我们来通过 <code>ecall</code> 调用批处理系统提供的接口， 由于应用程序运行在用户态（即 U 模式）， <code>ecall</code> 指令会触发名为 <code>Environment call from U-mode</code> 的异常， 并 Trap 进入 S 模式执行批处理系统针对这个异常特别提供的服务程序。 这个接口被称为 ABI 或者系统调用。</p></blockquote><p>进入Trap后会被<code>trap_handler</code>捕获，然后调用内核中的syscall根据<code>syscall_id</code>调用相应的函数。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>user级的应用调用<code>task_info</code> -&gt; user级的<code>sys_task_info</code> -&gt; 调用系统调用syscall -&gt; <code>ecall</code>指令触发中断异常，Trap进入S模式，trap被<code>trap_handler</code>捕获 -&gt; 根据syscall_id调用处理函数</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>系统调用次数考虑在进入内核态系统调用异常处理函数之后，进入具体系统调用函数之前维护。</p><p>一开始的想法是在<code>os/src/trap/mod.rs</code>的<code>trap_handler</code>函数中，利用一个静态全局变量来维护。实操了一下，笔者初学Rust, 大概不到二十小时，包的引用和静态全局变量这方面的维护也不太会处理。遂放弃，后来发现其实在<code>TaskManager</code>中已经有了很好的处理方式，也有一个静态全局变量，那就利用已有代码，在结构体中添加一些成员变量，对应sys_taskinfo中所需的信息。</p><h4 id="syscall-times"><a href="#syscall-times" class="headerlink" title="syscall_times"></a>syscall_times</h4><p>在syscall函数里，进入具体系统维护函数之前统计对应syscall_id的调用次数。在<code>TaskControlBlock</code>中维护即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"><span class="comment">/// YOUR JOB: Finish sys_task_info to pass testcases</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_task_info</span>(_ti: *<span class="keyword">mut</span> TaskInfo) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    trace!(<span class="string">&quot;kernel: sys_task_info&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> _ti.<span class="title function_ invoke__">is_null</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *_ti = TaskInfo &#123;</span><br><span class="line">            status: <span class="title function_ invoke__">get_task_status</span>(),</span><br><span class="line">            syscall_times: <span class="title function_ invoke__">get_syscall_times</span>(),</span><br><span class="line">            time: <span class="title function_ invoke__">get_run_time</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/mod.rs</span></span><br><span class="line"><span class="keyword">use</span> crate::task::count_syscall;</span><br><span class="line"><span class="comment">/// handle syscall exception with `syscall_id` and other arguments</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">syscall</span>(syscall_id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">count_syscall</span>(syscall_id);</span><br><span class="line">    <span class="keyword">match</span> syscall_id &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">       <span class="comment">/// When a syscall is called, we need to increase the syscall_times</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">count_syscall</span>(&amp;<span class="keyword">self</span>, syscall_id: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> syscall_id &lt; MAX_SYSCALL_NUM &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">current</span> = inner.current_task;</span><br><span class="line">            inner.tasks[current].syscall_times[syscall_id] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"><span class="comment">/// The task control block (TCB) of a task.</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">/// The task status in it&#x27;s lifecycle</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="comment">/// The task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="comment">/// The task syscall times</span></span><br><span class="line">    <span class="keyword">pub</span> syscall_times: [<span class="type">u32</span>; MAX_SYSCALL_NUM],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="task-status"><a href="#task-status" class="headerlink" title="task_status"></a>task_status</h4><p>虽然当前task的状态一定是Running，但是要借助代码获取，而不是用硬编码固定状态。思路就和统计syscall的调用次数一样，只需要在<code>TaskManager</code>中维护一个<code>get_task_status</code>函数，获取当前任务的状态即可</p><h4 id="run-time"><a href="#run-time" class="headerlink" title="run_time"></a>run_time</h4><p>在系统中只有获取当前时间的方法，要计算程序运行时间，应该用当前时间减去程序开始时间，那么在TaskControlBlock里面维护一个<code>start_time</code>就可以了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The task control block (TCB) of a task.</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">/// The task status in it&#x27;s lifecycle</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="comment">/// The task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="comment">/// The task syscall times</span></span><br><span class="line">    <span class="keyword">pub</span> syscall_times: [<span class="type">u32</span>; MAX_SYSCALL_NUM],</span><br><span class="line">    <span class="comment">/// The start time of task</span></span><br><span class="line">    <span class="keyword">pub</span> start_time: <span class="type">Option</span>&lt;<span class="type">usize</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>start_time</code>在每个程序运行之前记录一下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run_first_task</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;task0.task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">        task0.start_time = <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">get_time_ms</span>());</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Switch current `Running` task to the task we have found,</span></span><br><span class="line">    <span class="comment">/// or there is no `Ready` task and we can exit with all applications completed</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run_next_task</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = <span class="keyword">self</span>.<span class="title function_ invoke__">find_next_task</span>() &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;inner.tasks[next].task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">            <span class="keyword">if</span> inner.tasks[next].start_time.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">                inner.tasks[next].start_time = <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">get_time_ms</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Get the task run time </span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_run_time</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current</span> = inner.current_task;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current_time</span> = <span class="title function_ invoke__">get_time_ms</span>();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(start_time) = inner.tasks[current].start_time &#123;</span><br><span class="line">            <span class="keyword">return</span> current_time - start_time;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;chapter3-编程作业&quot;&gt;&lt;a href=&quot;#chapter3-编程作业&quot; class=&quot;headerlink&quot; title=&quot;chapter3  编程作业&quot;&gt;&lt;/a&gt;chapter3  编程作业&lt;/h1&gt;&lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; c</summary>
      
    
    
    
    <category term="cs" scheme="http://blog.zymatrix.top/categories/cs/"/>
    
    
    <category term="Rust" scheme="http://blog.zymatrix.top/tags/Rust/"/>
    
    <category term="os" scheme="http://blog.zymatrix.top/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>并发Bugs</title>
    <link href="http://blog.zymatrix.top/2024/04/09/JYYOS%E5%B9%B6%E5%8F%91bugs/"/>
    <id>http://blog.zymatrix.top/2024/04/09/JYYOS%E5%B9%B6%E5%8F%91bugs/</id>
    <published>2024-04-08T16:00:00.000Z</published>
    <updated>2024-08-12T09:20:11.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发Bug"><a href="#并发Bug" class="headerlink" title="并发Bug"></a>并发Bug</h1><p>笔记内容来自蒋炎岩老师的<a href="https://jyywiki.cn/OS/2024/">OS课程以及slides</a></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="AA-Deadlock"><a href="#AA-Deadlock" class="headerlink" title="AA-Deadlock"></a>AA-Deadlock</h3><p>unlock之前出现中断，然后lock()，此时会出现spin</p><h3 id="ABBA-Deadlock（最常见）"><a href="#ABBA-Deadlock（最常见）" class="headerlink" title="ABBA-Deadlock（最常见）"></a>ABBA-Deadlock（最常见）</h3><blockquote><p>T-&gt;lock(A)-&gt;lock(B)</p><p>T-&gt;lock(B)-&gt;lock(A)</p></blockquote><p>当一个线程lock AB后才能执行，但如果T1lock(A),T2lock(B)，此时无法满足条件，死锁</p><h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><ol><li>Lock ordering</li></ol><ul><li>任意时刻系统中的锁都是有限的</li><li>给所有锁编号 (Lock Ordering)<ul><li>严格按照从小到大的顺序获得锁</li></ul></li></ul><ol start="2"><li>Proof (sketch)</li></ol><ul><li>任意时刻，总有一个线程获得 “编号最大” 的锁</li><li>这个线程总是可以继续运行</li></ul><h2 id="数据竞争-Data-Race"><a href="#数据竞争-Data-Race" class="headerlink" title="数据竞争(Data Race)"></a>数据竞争(Data Race)</h2><p>不同的线程同时访问同一内存，且至少有一个是写</p><p>例子：</p><p>Case 1: 上错了锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_1</span><span class="params">()</span> &#123; </span><br><span class="line">    spin_lock(&amp;A); </span><br><span class="line">    sum++; </span><br><span class="line">    spin_unlock(&amp;A); </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">T_2</span><span class="params">()</span> &#123; </span><br><span class="line">    spin_lock(&amp;B); </span><br><span class="line">    sum++; </span><br><span class="line">    spin_unlock(&amp;B); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>Case 2: 忘记上锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_1</span><span class="params">()</span> &#123; </span><br><span class="line">    spin_lock(&amp;A); </span><br><span class="line">    sum++; </span><br><span class="line">    spin_unlock(&amp;A); </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">T_2</span><span class="params">()</span> &#123; </span><br><span class="line">    sum++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子性-顺序违反"><a href="#原子性-顺序违反" class="headerlink" title="原子性&#x2F;顺序违反"></a>原子性&#x2F;顺序违反</h2><h3 id="“ABA”-代码被别人-“强势插入”"><a href="#“ABA”-代码被别人-“强势插入”" class="headerlink" title="“ABA”: 代码被别人 “强势插入”"></a>“ABA”: 代码被别人 “强势插入”</h3><ul><li>即便分别上锁 (消除数据竞争)，依然是 AV<ul><li>Diablo I 里复制物品的例子</li><li>Therac-25 中 “移动 Mirror + 设置状态”</li></ul></li></ul><h3 id="“BA”-事件未按预定的顺序发生"><a href="#“BA”-事件未按预定的顺序发生" class="headerlink" title="“BA”: 事件未按预定的顺序发生"></a>“BA”: 事件未按预定的顺序发生</h3><ul><li>例子：concurrent use-after-free</li><li><a href="https://www.vusec.net/projects/ghostrace/">GhostRace</a> (USENIX Sec’24)</li></ul><h1 id="应对并发Bugs"><a href="#应对并发Bugs" class="headerlink" title="应对并发Bugs"></a>应对并发Bugs</h1><h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><p><strong>我们可以在运行时检查一切明确的 Specification！</strong></p><ul><li>严格按照编号执行</li><li>运行时lockorder的检查(lockdep)</li><li>ThreadSanitizer: 运行时的数据竞争检查</li></ul><h2 id="应对死局-Sanitizers"><a href="#应对死局-Sanitizers" class="headerlink" title="应对死局: Sanitizers"></a>应对死局: Sanitizers</h2><h3 id="现代复杂软件系统必备的支撑工具"><a href="#现代复杂软件系统必备的支撑工具" class="headerlink" title="现代复杂软件系统必备的支撑工具"></a>现代复杂软件系统必备的支撑工具</h3><ul><li><p><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a>(asan);<a href="https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany">(paper)</a>: 非法内存访问</p><ul><li><p>Buffer (heap&#x2F;stack&#x2F;global) overflow, use-after-free, use-after-return, double-free, …;</p></li><li><p>没有 <a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html">KASAN</a>, Linux Kernel 的质量&#x2F;安全性直接崩盘</p></li></ul></li><li><p><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">ThreadSanitizer</a> (tsan): 数据竞争</p><ul><li>KCSAN: <a href="https://lwn.net/Articles/816850/">Concurrency bugs should fear the big bad data-race detector</a></li></ul></li><li><p><a href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer</a> (msan), <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">UBSanitizer</a> (ubsan), …</p></li><li><p>SpecSanitizer: 基于 AI&#x2F;LLM 的 “specification 检查”</p><ul><li>就等你来开发了</li></ul></li></ul><h2 id="应对死线：防御性编程"><a href="#应对死线：防御性编程" class="headerlink" title="应对死线：防御性编程"></a>应对死线：防御性编程</h2><h3 id="Full-Sanitizer-很难实现"><a href="#Full-Sanitizer-很难实现" class="headerlink" title="Full Sanitizer 很难实现"></a>Full Sanitizer 很难实现</h3><ul><li>不如换一种思路</li><li>我们可以 “编程”！</li></ul><h3 id="Best-effort-is-better-than-no-effort"><a href="#Best-effort-is-better-than-no-effort" class="headerlink" title="Best-effort is better than no-effort!"></a>Best-effort is better than no-effort!</h3><ul><li>不实现 “完整” 的检查 (允许存在误报&#x2F;漏报)</li><li>但实现简单、非常有用——而且有惊喜<ul><li>我们不是一直都在写 assertions 吗？<ul><li>Peterson 算法：<code>assert(nest == 1);</code></li><li>链表：<code>assert(u-&gt;prev-&gt;next == u);</code></li><li>spinlock: <code>if (holding(&amp;lk)) panic();</code></li></ul></li></ul></li></ul><h3 id="Buffer-Overrun检查"><a href="#Buffer-Overrun检查" class="headerlink" title="Buffer Overrun检查"></a>Buffer Overrun检查</h3><ul><li>Canary: “牺牲” 内存单元，预警 memory error</li><li>例如：Stack Guard（栈溢出），缓冲区溢出</li></ul><h3 id="低配版Lockdep"><a href="#低配版Lockdep" class="headerlink" title="低配版Lockdep"></a>低配版Lockdep</h3><p><strong>高配版 lockdep 太复杂？</strong></p><ul><li>统计当前的 spin count</li><li>如果超过某个明显不正常的数值 (100,000,000) 就报告<ul><li>你感觉到 “hang” 了</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> spin_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (xchg(&amp;lk, ❌) == ❌) &#123;</span><br><span class="line">    <span class="keyword">if</span> (spin_cnt++ &gt; SPIN_LIMIT) &#123;</span><br><span class="line">        panic(<span class="string">&quot;Spin limit exceeded @ %s:%d\n&quot;</span>,</span><br><span class="line">            __FILE__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配合调试器和线程 backtrace 一秒诊断死锁</li></ul><h3 id="低配版AddressSanitizer"><a href="#低配版AddressSanitizer" class="headerlink" title="低配版AddressSanitizer"></a>低配版AddressSanitizer</h3><p><strong>L1 内存分配器的 specification</strong></p><ul><li>已分配内存 <em>S</em>&#x3D;[ℓ0,<em>r</em>0)∪[ℓ1,<em>r</em>1)∪…<em>S</em>&#x3D;[ℓ0,<em>r</em>0)∪[ℓ1,<em>r</em>1)∪…</li><li>kalloc(<em>s</em>) 返回的 [ℓ,<em>r</em>)[ℓ,<em>r</em>) 必须满足 [ℓ,<em>r</em>)∩<em>S</em>&#x3D;∅[ℓ,<em>r</em>)∩<em>S</em>&#x3D;∅</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocation</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; (i + <span class="number">1</span>) * <span class="keyword">sizeof</span>(u32) &lt;= size; i++) &#123;</span><br><span class="line">    panic_on(((u32 *)ptr)[i] == MAGIC, <span class="string">&quot;double-allocation&quot;</span>);</span><br><span class="line">    arr[i] = MAGIC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; (i + <span class="number">1</span>) * <span class="keyword">sizeof</span>(u32) &lt;= alloc_size(ptr); i++) &#123;</span><br><span class="line">    panic_on(((u32 *)ptr)[i] == <span class="number">0</span>, <span class="string">&quot;double-free&quot;</span>);</span><br><span class="line">    arr[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="低配版ThreadSanitizer"><a href="#低配版ThreadSanitizer" class="headerlink" title="低配版ThreadSanitizer"></a>低配版ThreadSanitizer</h3><p>直接观测状态影响</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Suppose x is lock-protected</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> observe1 = x;</span><br><span class="line">delay();</span><br><span class="line"><span class="type">int</span> observe2 = x;</span><br><span class="line"></span><br><span class="line">assert(observe1 == observe2);</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><a href="https://www.usenix.org/legacy/events/osdi10/tech/full_papers/Erickson.pdf">Effective data-race detection for the Kernel</a> (OSDI’10)</li></ul><h3 id="SemanticSanitizer"><a href="#SemanticSanitizer" class="headerlink" title="SemanticSanitizer"></a>SemanticSanitizer</h3><p><strong>两个看似平常的检查</strong></p><ul><li>检查整数是否在某个范围</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_INT(x, cond) \</span></span><br><span class="line"><span class="meta">    (&#123; panic_on(!((x) cond), \</span></span><br><span class="line"><span class="meta">       <span class="string">&quot;int check fail: &quot;</span> \</span></span><br><span class="line"><span class="meta">       #x <span class="string">&quot; &quot;</span> #cond); \</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br></pre></td></tr></table></figure><ul><li>检查指针是否位于堆区</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_HEAP(ptr) \</span></span><br><span class="line"><span class="meta">    (&#123; panic_on(!IN_RANGE((ptr), heap)); &#125;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发Bug&quot;&gt;&lt;a href=&quot;#并发Bug&quot; class=&quot;headerlink&quot; title=&quot;并发Bug&quot;&gt;&lt;/a&gt;并发Bug&lt;/h1&gt;&lt;p&gt;笔记内容来自蒋炎岩老师的&lt;a href=&quot;https://jyywiki.cn/OS/2024/&quot;&gt;OS课程以及sl</summary>
      
    
    
    
    <category term="cs" scheme="http://blog.zymatrix.top/categories/cs/"/>
    
    
    <category term="OS" scheme="http://blog.zymatrix.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>The Problems of Using OpenEuler WSL</title>
    <link href="http://blog.zymatrix.top/2024/03/09/The%20Problems%20of%20Using%20OpenEuler%20WSL/"/>
    <id>http://blog.zymatrix.top/2024/03/09/The%20Problems%20of%20Using%20OpenEuler%20WSL/</id>
    <published>2024-03-08T16:00:00.000Z</published>
    <updated>2024-08-12T09:20:23.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Problems-of-Using-OpenEuler-WSL"><a href="#The-Problems-of-Using-OpenEuler-WSL" class="headerlink" title="The Problems of Using OpenEuler WSL"></a>The Problems of Using OpenEuler WSL</h1><p>记录一下在OS课上使用OpenEuler WSL遇到的坑</p><p>OpenEuler 官方下载WSL系统的脚本十分炸裂，能在x86架构的机器上安装MIPS架构的结果，建议避雷，使用微软商店的软件包下载</p><p>本次实验的要求：</p><blockquote><p>1.向OpenEuler系统，或者OpenKylin系统中，增加一个系统<br>调用&#x2F;或内核模块，鼓励程序逻辑的多样化<br>2.撰写一个应用测试程序调用该系统调用&#x2F;测试该内核模块<br>3.使用trace&#x2F;ptrace&#x2F;strace,或类似的系统跟踪工具来对该测试<br>程序进行跟踪调试</p></blockquote><h2 id="内核问题"><a href="#内核问题" class="headerlink" title="内核问题"></a>内核问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>实验环境是在WSL2下使用OpenEuler，CentOS套壳</p><p>借鉴了一些网络上的代码后，对源码进行编译，下面是Makefile文件内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">obj-m:=syscall.o</span></span><br><span class="line">PWD:= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KERNELDIR:= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">EXTRA_CFLAGS= -O0</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C <span class="variable">$(KERNELDIR)</span>  M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure><p>make后报错：</p><blockquote><p>&#x2F;lib&#x2F;modules&#x2F;5.15.146.1-microsoft-standard-WSL2&#x2F;build: No such file or directory. </p></blockquote><p>搜索后可知，WSL2的内核是修改过的，无法使用CentOS上游的内核头文件和modules文件，因此，我们需要手动编译并安装一个版本。</p><h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><h4 id="下载对应版本内核代码"><a href="#下载对应版本内核代码" class="headerlink" title="下载对应版本内核代码"></a>下载对应版本内核代码</h4><p>首先查看系统内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure><blockquote><p>5.15.146.1-microsoft-standard-WSL2</p></blockquote><p>到<a href="https://github.com/microsoft/WSL2-Linux-Kerne">WSL git仓库</a>，找到对应的release</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/microsoft/WSL2-Linux-Kernel</span><br></pre></td></tr></table></figure><h4 id="编译和安装"><a href="#编译和安装" class="headerlink" title="编译和安装"></a>编译和安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> WSL2-Linux-Kernel</span><br><span class="line">LOCALVERSION= make KCONFIG_CONFIG=Microsoft/config-wsl -j8</span><br><span class="line">sudo LOCALVERSION= make KCONFIG_CONFIG=Microsoft/config-wsl modules_install -j8</span><br></pre></td></tr></table></figure><p>这个阶段会遇到较多报错，由于我使用的是CentOS和网络上大多资料使用的Ubuntu不同，因此需要安装的依赖也不一样，这里就直接放出一部分报错和安装的全部命令</p><blockquote><p>fatal error: openssl&#x2F;bio.h: No such file or directory<br>fatal error: libelf.h: No such file or directory<br>BTF: .tmp_vmlinux.btf: pahole (pahole) is not available Failed to generate BTF for vmlinux<br>Try to disable CONFIG_DEBUG_INFO_BTF<br>Warning: ‘make modules_install’ requires depmod. Please install it.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install bison flex openssl-devel elfutils-libelf-devel dwarves kmod</span><br></pre></td></tr></table></figure><p>安装完这些以后，再重新运行上面的指令，这个时候就能发现没有问题了。</p><h3 id="insmod问题"><a href="#insmod问题" class="headerlink" title="insmod问题"></a>insmod问题</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>当编译成功后，需要加载内核模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod randomizer.ko</span><br></pre></td></tr></table></figure><p>这个时候终端抛出问题：</p><blockquote><p>ERROR: could not insert module mymodule.ko: Invalid parameters</p></blockquote><p>但是一番搜索后发现根本没有解决我的问题的方法，这时候查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | <span class="built_in">tail</span></span><br></pre></td></tr></table></figure><p>可以发现出现了这样的错误：</p><blockquote><p>BPF:[xxxxx] Invalid name_offset:xxxxxx failed to validate module [mymodule] BTF: -22</p></blockquote><p>在一篇博客中有这样的记录：</p><blockquote><p>“rocky linux 9上面，内核编译设置默认打开了DEBUG_INFO_BTF_MODULES，这样所有模块里面都带有BTF信息。</p><p>运行时内核的BTF这个机制，如果模块缺少BTF信息（ELF的BTF段）那可以加载成功，但如果BTF的版本不匹配就拒绝加载。 使用源码自己编译内核时，虽然内核源码是一样的但生成的BTF还是不匹配的。 这样自己使用内核源码目录（ 不是系统的&#x2F;lib&#x2F;modules&#x2F;<code>uname -r</code>&#x2F;build ） 编译一个模块出来， 在rocky linux的官方内核系统里面就没法使用了， modprobe 会返回“ bpf invalid name btf -22”错误。 但通常编译模块时，如果make bzImage 之后make clean 删掉vmlinux 后 编译模块时找不到vmlinux就不会BTF信息，通常还是可以正常使用的。 但有的模块使用了 register_btf_kfunc_id_set 函数 向系统注册BTF函数的，这种一定要求BTF 信息的就不行了。</p><p>反正这个BTF这个东西，自己编译第三方模块时最好就不要把BTF编译进去了，不然不同的内核小版本都没法兼容，即使同样的内核源码也是不行的。”</p></blockquote><p>可以看到其实是BTF的问题，联系到上面出现的一个报错：</p><blockquote><p>BTF: .tmp_vmlinux.btf: pahole (pahole) is not available Failed to generate BTF for vmlinux<br>Try to disable CONFIG_DEBUG_INFO_BTF<br>Warning: ‘make modules_install’ requires depmod. Please install it.</p></blockquote><p>我们就要在这上面下文章，一开始，我们借助下载dwarves解决了这个报错</p><p>而在这里，我们就需要去disable CONFIG_DEBUG_INFO_BTF</p><p>因此引出一种可行办法，也就是：</p><blockquote><p>make menuconfig </p><p>配置内核，生成.config文件</p></blockquote><p>然后在.config文件中修改</p><blockquote><p>CONFIG_DEBUG_INFO_BTF&#x3D;n</p></blockquote><p>但是由于一些奇怪的原因，我无法使用 make menuconfig，于是，<del>我借助了另一种思路</del></p><blockquote><p> 删掉vmlinux 后 编译模块时找不到vmlinux就不会BTF信息</p></blockquote><p>实际上是阴差阳错地，我在WSL2-Linux-Kernel目录下执行make clean，清除了所有*.o文件，然后make重新编译了一次，这时候神奇的事情发生了，尽管我仍然没有.config文件，但是当我使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod randomizer.ko</span><br></pre></td></tr></table></figure><p>并没有任何报错出现，这时候再用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | <span class="built_in">tail</span></span><br></pre></td></tr></table></figure><p>查看内核日志和分配给模块的主设备号时</p><blockquote><p>BPF:[xxxxx] Invalid name_offset:xxxxxx failed to validate module [mymodule] BTF: -22</p><p>module has been loaded: xxx</p></blockquote><p>BTF的问题没有消失，但是我们绕开了</p><p>接着创建设备文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mknod /dev/mymodule c xxx 0</span><br></pre></td></tr></table></figure><p>运行测试程序就可以发现成功了。</p><p>参考资料：</p><p><a href="https://blog.csdn.net/weixin_45668903/article/details/128019077">WSL 运行make提示&#x2F;lib&#x2F;modules&#x2F;xxx&#x2F;build: No such file or directory. Stop.错误解决办法</a></p><p><a href="https://gmd20.github.io/blog/BTF%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D%E5%AF%BC%E8%87%B4%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/">Btf版本不匹配导致内核模块加载失败的问题 </a></p><p><a href="https://www.cnblogs.com/xia-dong/p/13553787.html"><a href="https://www.cnblogs.com/xia-dong/p/13553787.html">kernel 源码升级</a></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;The-Problems-of-Using-OpenEuler-WSL&quot;&gt;&lt;a href=&quot;#The-Problems-of-Using-OpenEuler-WSL&quot; class=&quot;headerlink&quot; title=&quot;The Problems of Using </summary>
      
    
    
    
    <category term="cs" scheme="http://blog.zymatrix.top/categories/cs/"/>
    
    
    <category term="OS" scheme="http://blog.zymatrix.top/tags/OS/"/>
    
    <category term="Linux Kernel" scheme="http://blog.zymatrix.top/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>2023年小记</title>
    <link href="http://blog.zymatrix.top/2024/01/01/2023/"/>
    <id>http://blog.zymatrix.top/2024/01/01/2023/</id>
    <published>2023-12-31T16:00:00.000Z</published>
    <updated>2024-08-12T09:18:51.088Z</updated>
    
    <content type="html"><![CDATA[<p>新年伊始，日历的数字又换了一代，满大街都是人，狂欢显得他们对帝国的危机没有表现出任何兴奋或是担忧的情绪，仿佛日历变化或是口头言语就能把古旧的社会简单化新，时间在他们那里是不连续的。 “每天早上，当我在阴暗的天空下再次醒来时，我都会觉得对我来说是新年。”——葛兰西</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;新年伊始，日历的数字又换了一代，满大街都是人，狂欢显得他们对帝国的危机没有表现出任何兴奋或是担忧的情绪，仿佛日历变化或是口头言语就能把古旧的社会简单化新，时间在他们那里是不连续的。 “每天早上，当我在阴暗的天空下再次醒来时，我都会觉得对我来说是新年。”——葛兰西&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="杂记" scheme="http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《帝国主义是资本主义的最高阶段》</title>
    <link href="http://blog.zymatrix.top/2023/05/11/%E3%80%8A%E5%B8%9D%E5%9B%BD%E4%B8%BB%E4%B9%89%E6%98%AF%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E7%9A%84%E6%9C%80%E9%AB%98%E9%98%B6%E6%AE%B5%E3%80%8B/"/>
    <id>http://blog.zymatrix.top/2023/05/11/%E3%80%8A%E5%B8%9D%E5%9B%BD%E4%B8%BB%E4%B9%89%E6%98%AF%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E7%9A%84%E6%9C%80%E9%AB%98%E9%98%B6%E6%AE%B5%E3%80%8B/</id>
    <published>2023-05-10T16:00:00.000Z</published>
    <updated>2024-08-12T09:16:44.652Z</updated>
    
    <content type="html"><![CDATA[<ul><li>铁路网的分布，这种分布的不平衡，铁路网发展的不平衡，是全世界现代资本主义即垄断资本主义造成的结果。这种结果表明，只要生产资料私有制还存在，在上述这样的经济基础上，帝国主义战争是绝对不可避免的。</li><li>很明显，这种大量的超额利润（因为它是在资本家从“自己”国家工人身上榨取的利润之外得来的）可以用来收买工人领袖和工人贵族这个上层。</li><li>这个资产阶级化了的工人阶层即“工人贵族”阶层，这个按生活方式、工资数额和整个世界观来说已经完全小市民化的工人阶层，是第二国际的主要支柱，现在是资产阶级的主要社会支柱。因为这是资产阶级在工人运动中的真正代理人，是资本家阶级的工人帮办，是改良主义和沙文主义的真正传播者。在无产阶级同资产阶级的国内战争中，他们有不少人必然会站在资产阶级方面，站在“凡尔赛派”方面来反对“公社战士”。</li><li>帝国主义阶段的资本主义紧紧接近最全面的生产社会化，它不顾资本家的愿望和意识，可以说是把他们拖进一种从完全的竞争自由向完全的社会化过渡的新的社会秩序。</li><li>生产社会化了，但是占有仍然是私人的。社会化的生产资料仍旧是少数人的私有财产。在形式上被承认的自由竞争的一般架子依然存在，而少数垄断者对其余居民的压迫却更加百倍地沉重、显著和令人难以忍受了。</li><li>为数众多的普通中介人成为极少数垄断者的这种转变，是资本主义发展成为资本帝国主义的基本过程之一。</li><li>生产的集中；从集中生长起来的垄断；银行和工业日益融合或者说长合在一起，——这就是金融资本产生的历史和这一概念的内容。</li><li>垄断既然已经形成，而且操纵着几十亿资本，它就绝对不可避免地要渗透到社会生活的各个方面去，而不管政治制度或其他任何“细节”如何。</li><li>资本主义的一般特性，就是资本的占有同资本在生产中的运用相分离，货币资本同工业资本或者说生产资本相分离，全靠货币资本的收入为生的食利者同企业家及一切直接参与运用资本的人相分离，帝国主义，或者说金融资本的统治，是资本主义的最高阶段，这时候，这种分离达到了极大的程度。金融资本对其他一切形式的资本的优势，意味着食利者和金融寡头占统治地位，意味着少数拥有金融“实力”的国家处于和其余一切国家不同的特殊地位。</li><li>对自由竞争占完全统治地位的旧资本主义来说，典型的是商品输出。对垄断占统治地位的最新资本主义来说，典型的则是资本输出。</li><li>金融资本是一种存在于一切经济关系和一切国际关系中的巨大力量，可以说是起决定作用的力量，它甚至能够支配而且实际上已经支配着一些政治上完全独立的国家。</li><li>资本主义愈发达，原料愈感缺乏，竞争和追逐全世界原料产地的斗争愈尖锐，抢夺殖民地的斗争也就愈激烈。</li><li>在金融资本的基础上生长起来的非经济的上层建筑，即金融资本的政策和意识形态，加强了夺取殖民地的趋向。</li><li>试问，在资本主义基础上，要消除生产力发展和资本积累同金融资本对殖民地和“势力范围”的瓜分这两者之间不相适应的状况，除了用战争以外，还能有什么其他办法呢？</li><li>帝国主义有一种趋势，就是在工人中间也分化出一些特权阶层，并且使他们脱离广大的无产阶级群众。（分化出工人贵族，这些人将是反对无产阶级革命的一部分，但是由于他们仍然是无产阶级，在危机来临之时，现实将会把他们从大梦中拍醒）</li><li>例如，恩格斯在1858年10月7日给马克思的信中说：“英国无产阶级实际上日益资产阶级化了，因而这一所有民族中最资产阶级化的民族，看来想把事情最终弄到这样的地步，即除了资产阶级，它还要有资产阶级化的贵族和资产阶级化的无产阶级。”</li><li>考茨基的 “理论”的客观即真正的社会意义只有一个，就是拿资本主义制度下可能达到永久和平的希望，对群众进行最反动的安慰，其方法就是使人们不去注意现代的尖锐矛盾和尖锐问题，而去注意某种所谓新的将来的 “超帝国主义”的虚假前途。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;铁路网的分布，这种分布的不平衡，铁路网发展的不平衡，是全世界现代资本主义即垄断资本主义造成的结果。这种结果表明，只要生产资料私有制还存在，在上述这样的经济基础上，帝国主义战争是绝对不可避免的。&lt;/li&gt;
&lt;li&gt;很明显，这种大量的超额利润（因为它是在资本家从“自</summary>
      
    
    
    
    <category term="my love" scheme="http://blog.zymatrix.top/categories/my-love/"/>
    
    
    <category term="哲学" scheme="http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="马列毛" scheme="http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"/>
    
  </entry>
  
  <entry>
    <title>建站小记</title>
    <link href="http://blog.zymatrix.top/2023/04/06/first/"/>
    <id>http://blog.zymatrix.top/2023/04/06/first/</id>
    <published>2023-04-05T16:00:00.000Z</published>
    <updated>2024-08-12T09:20:03.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建站原因"><a href="#建站原因" class="headerlink" title="建站原因"></a>建站原因</h2><p>在b站上看到了一个搭建个人博客网站的视频，心血来潮以及作为Geek必备的博客作为驱动力，于是查找了一些资料最终找到了以github + hexo 的方式建立博客。感谢朋友（畅姐我的神）的<del>倾情</del>推荐，给了我一个好<a href="https://oceanwang.top/personal-website-1/">教程</a>。</p><hr><h2 id="曲折的建站过程"><a href="#曲折的建站过程" class="headerlink" title="曲折的建站过程"></a>曲折的建站过程</h2><p><del>说到这个，不得不吐槽一下我这令人愤怒的电脑。从我大一上学期配C语言环境开始，再到虚拟机和linux ssh远端连接，这玩意就没让我省心过。</del><br>吐槽结束，现在是问题时间。</p><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>由于初次上手个人网站搭建，所知甚少。而且最开始时，没有如此系统的教程，都是用的零七碎八的教程，难免遇到各种问题。</p><ul><li><p>npm node hexo 安装完成后出现类似command not found的问题，用Google搜索、在stackoverflow上找相关问题，都没能解决这个问题，最后尝试了csdn上的一个说法，即设置环境变量,在path下面加上npm node hexo等的路径，成功解决问题。<del>（多少有点zz了）</del><br>路径问题占据了我建站的绝大多数时间。</p></li><li><p>设置部署仓库和分支出现 “FATAL YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key (107:14)” 的问题。这个问题是因我在更改hexo源码根目录下的_config.yml中的deploy部分直接复制粘贴引起的。参考下图，在repo:以及branch:的冒号后面要加上’ ‘空格。<br><img src="https://oceanwang.top/personal-website-7/9.png" alt="代码"></p></li><li><p>目前尚未解决的问题。GitHub Actions自动部署，按照教程上传workflow文件到github上，但是目前还没成功，也没查原因。</p></li><li><p>在执行hexo generate和hexo deploy命令时可能会出现kex_exchange_identification: Connection closed by remote host Connection closed by 20.205.243.166 port 22 fatal: Could not read from remote repository的错误信息，这个时候需要改变一下自己的vpn节点，或者在vpn速度较好时再重新执行hexo d的命令。</p></li></ul><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>建站完成之后，就是要对网站进行个性化的修改，对样式进行处理</p><ul><li>在文章的头部部分增加一下内容能够达到对文章进行分类的效果。<br>这些内容可以在_config.yml文件中找到对应的部分。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: #文章标题</span><br><span class="line">cover: #文章封面的图片的链接或者地址</span><br><span class="line">category: #文章在子页中的分类</span><br><span class="line">tag: </span><br><span class="line"> - #文章的标签</span><br><span class="line">id: #文章的序号</span><br><span class="line">date: #文章写作的时间</span><br><span class="line">toc: true #是否包含目录</span><br><span class="line">timeline: #在时间线中的分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建站原因&quot;&gt;&lt;a href=&quot;#建站原因&quot; class=&quot;headerlink&quot; title=&quot;建站原因&quot;&gt;&lt;/a&gt;建站原因&lt;/h2&gt;&lt;p&gt;在b站上看到了一个搭建个人博客网站的视频，心血来潮以及作为Geek必备的博客作为驱动力，于是查找了一些资料最终找到了以git</summary>
      
    
    
    
    <category term="cs" scheme="http://blog.zymatrix.top/categories/cs/"/>
    
    
    <category term="杂记" scheme="http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《哥达纲领批判》</title>
    <link href="http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%93%A5%E8%BE%BE%E7%BA%B2%E9%A2%86%E6%89%B9%E5%88%A4%E3%80%8B/"/>
    <id>http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%93%A5%E8%BE%BE%E7%BA%B2%E9%A2%86%E6%89%B9%E5%88%A4%E3%80%8B/</id>
    <published>2023-04-05T16:00:00.000Z</published>
    <updated>2024-08-12T09:16:56.871Z</updated>
    
    <content type="html"><![CDATA[<ul><li>劳动不是一切财富的源泉。自然界同劳动一样也是使用价值（而物质财富就是由使用价值构成的！）的源泉，劳动本身不过是一种自然力即人的劳动力的表现</li><li>只有一个人一开始就以所有者的身份来对待自然界这个一切劳动资料和劳动对象的第一源泉，把自然界当做属于他的东西来处置，他的劳动才成为使用价值的源泉，因而也成为财富的源泉。</li><li>在一个集体的、以生产资料公有为基础的社会中，生产者不交换自己的产品；用在产品上的劳动，在这里也不表现为这些产品的价值，不表现为这些产品所具有的某种物的属性，因为这时，同资本主义社会相反，个人的劳动不再经过迂回曲折的道路，而是直接作为总劳动的组成部分存在着。</li><li>权利决不能超出社会的经济结构以及由经济结构制约的社会的文化发展</li><li>庸俗的社会主义仿效资产阶级经济学家把分配看成并解释成一种不依赖于生产方式的东西，从而把社会主义描写为主要是围绕着分配兜圈子。（由此可见，所谓依靠政府进行再分配的温和社会主义，即社会民主主义国家并不能称作是代表无产阶级的国家，它并未改变资本主义社会的经济基础因而也没有改变无产阶级被剥削的事实。）</li><li>在资本主义社会和共产主义社会之间，有一个从前者变为后者的革命转变时期。同这个时期相适应的也有一个政治上的过渡时期，这个时期的国家只能是无产阶级的革命专政。</li><li>自由就在于把国家由一个高踞社会之上的机关变成完全服从这个社会的机关；而且就在今天，各种国家形式比较自由或比较不自由，也取决于这些国家形式把“国家的自由”限制到什么程度。</li><li>在按照不同的年龄阶段严格调节劳动时间并采取其他保护儿童的预防措施的条件下，生产劳动和教育的早期结合是改造现代社会的最强有力的手段之一。</li><li>当无产阶级还需要国家的时候，它需要国家不是为了自由，而是为了镇压自己的敌人，一到有可能谈自由的时候，国家本身就不存在了。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;劳动不是一切财富的源泉。自然界同劳动一样也是使用价值（而物质财富就是由使用价值构成的！）的源泉，劳动本身不过是一种自然力即人的劳动力的表现&lt;/li&gt;
&lt;li&gt;只有一个人一开始就以所有者的身份来对待自然界这个一切劳动资料和劳动对象的第一源泉，把自然界当做属于他的东</summary>
      
    
    
    
    <category term="my love" scheme="http://blog.zymatrix.top/categories/my-love/"/>
    
    
    <category term="哲学" scheme="http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="马列毛" scheme="http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"/>
    
  </entry>
  
  <entry>
    <title>《德意志意识形态（节选）》</title>
    <link href="http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%BE%B7%E6%84%8F%E5%BF%97%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81%EF%BC%88%E8%8A%82%E9%80%89%EF%BC%89%E3%80%8B%E9%A9%AC%E5%85%8B%E6%80%9D%20%E6%81%A9%E6%A0%BC%E6%96%AF/"/>
    <id>http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%BE%B7%E6%84%8F%E5%BF%97%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81%EF%BC%88%E8%8A%82%E9%80%89%EF%BC%89%E3%80%8B%E9%A9%AC%E5%85%8B%E6%80%9D%20%E6%81%A9%E6%A0%BC%E6%96%AF/</id>
    <published>2023-04-05T16:00:00.000Z</published>
    <updated>2024-08-12T09:15:56.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一卷第一章"><a href="#第一卷第一章" class="headerlink" title="第一卷第一章"></a>第一卷第一章</h1><h3 id="费尔巴哈"><a href="#费尔巴哈" class="headerlink" title="费尔巴哈"></a>费尔巴哈</h3><h4 id="唯物主义观点和唯心主义观点的对立"><a href="#唯物主义观点和唯心主义观点的对立" class="headerlink" title="唯物主义观点和唯心主义观点的对立"></a>唯物主义观点和唯心主义观点的对立</h4><ul><li>因此，他们是什么样的，这同他们的生产是一致的——既和他们生产什么一致，又和他们怎样生产一致。</li><li>各民族之间的相互关系取决于每一个民族的生产力、分工和内部交往的发展程度。</li><li>一个民族的生产力发展的水平，最明显地表现于该民族分工的发展程度。任何新的生产力，只要它不是迄今已知的生产力单纯的量的扩大(例如，开垦土地)，都会引起分工的进一步发展。</li><li>一个民族内部的分工，首先引起工商业劳动同农业劳动的分离，从而也引起城乡的分离和城乡利益的对立。分工的进一步发展导致商业劳动同工业劳动的分离。</li><li>如果他们把哲学、神学、实体和一切废物消融在“自我意识”中，如果他们把“人”从这些词句的统治下——而人从来没有受过这些词句的奴役——解放出来，那么“人”的“解放”也并没有前进一步；只有在现实的世界中并使用现实的手段才能实现真正的解放<a href="https://www.marxists.org/chinese/marx/marxist.org-chinese-marx-1846.htm#_ftn16">[16]</a>；没有蒸汽机和珍妮走锭精纺机就不能消灭奴隶制；没有改良的农业就不能消灭农奴制；<strong>当人们还不能使自己的吃喝住穿在质和量方面得到充分保证的时候，人们就根本不能获得解放</strong></li><li>我们谈的是一些没有任何前提的德国人，因此我们首先应当确定一切人类生存的第一个前提，也就是一切历史的第一个前提<a href="https://www.marxists.org/chinese/marx/marxist.org-chinese-marx-1846.htm#_ftn30">[30]</a>，这个前提是：人们为了能够“创造历史”，必须能够生活<a href="https://www.marxists.org/chinese/marx/marxist.org-chinese-marx-1846.htm#_ftn31">[31]</a>。但是为了生活，首先就需要吃喝住穿以及其他一些东西。因此第一个历史活动就是生产满足这些需要的资料，即生产物质生活本身，而且这是这样的历史活动，一切历史的一种基本条件，人们单是为了能够生活就必须每日每时去完成它，现在和几千年前都是这样。</li><li>由此可见，一开始就表明了人们之间是有物质联系的。这种联系是由需要和生产方式决定的，它和人本身有同样长久的历史；这种联系不断采取新的形式，因而就表现为“历史”，它不需要有专门把人们联合起来的任何政治的或宗教的呓语。</li><li>其次，生产力的这种发展之所以是绝对必需的实际前提，还因为：只有随着生产力的这种普遍发展，人们的普遍交往才能建立起来；普遍交往，一方面，可以产生一切民族中同时都存在着“没有财产的”群众这一现象(普遍竞争)，使每一民族都依赖于其他民族的变革；最后，地域性的个人为世界历史性的、经验上普遍的个人所代替。不这样，(1)共产主义就只能作为某种地域性的东西而存在；(2)交往的力量本身就不可能发展成为一种普遍的因而是不堪忍受的力量：它们会依然处于地方的、笼罩着迷信气氛的“状态”；(3)交往的任何扩大都会消灭地域性的共产主义。共产主义只有作为占统治地位的各民族“一下子”同时发生的行动，在经验上才是可能的，而这是以生产力的普遍发展和与此相联系的世界交往为前提的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一卷第一章&quot;&gt;&lt;a href=&quot;#第一卷第一章&quot; class=&quot;headerlink&quot; title=&quot;第一卷第一章&quot;&gt;&lt;/a&gt;第一卷第一章&lt;/h1&gt;&lt;h3 id=&quot;费尔巴哈&quot;&gt;&lt;a href=&quot;#费尔巴哈&quot; class=&quot;headerlink&quot; title=&quot;费</summary>
      
    
    
    
    <category term="my love" scheme="http://blog.zymatrix.top/categories/my-love/"/>
    
    
    <category term="哲学" scheme="http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="马列毛" scheme="http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"/>
    
  </entry>
  
  <entry>
    <title>《法德农民问题》</title>
    <link href="http://blog.zymatrix.top/2023/04/06/%E6%B3%95%E5%BE%B7%E5%86%9C%E6%B0%91%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.zymatrix.top/2023/04/06/%E6%B3%95%E5%BE%B7%E5%86%9C%E6%B0%91%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-05T16:00:00.000Z</published>
    <updated>2024-08-12T09:20:39.209Z</updated>
    
    <content type="html"><![CDATA[<ul><li>作为政治力量的要素，农民至今在多数场合下仅仅表现出自己的那种生根于农村生活孤僻状况中的冷漠态度。广大居民群众的这种冷漠态度，不仅是巴黎和罗马国会腐败情况的强有力支柱，而且是俄罗斯专制主义的强有力的支柱。</li><li>社会党夺取政权已成为最近将来的事情。然而，为了夺取政权，这个政党应当首先从城市跑到农村，应当成为农村中的力量。</li><li>那末我们对待小农的态度是怎样的呢？在我们夺得国家权力的那一天，我们应该怎样对待他们呢？<br>　　第一，法国纲领的原理是绝对正确的：我们预见到小农必然灭亡，但我们无论如何不要以自己的干预去加速其灭亡。<br>　　第二，同样明显的，当我们掌握了国家权力的时候，我们根本不能设想用强制的办法去剥夺小农（不论有无报偿，都是一样），像我们将不得不如此对待大土地占有者那样。我们对于小农的任务，首先是把他们的私人生产和私人占有变为合作社的生产和占有，但不是用强制的办法，而是通过示范和为此提供社会帮助。<br>　- 我们永远也不能许诺小农给他保持个体经济和个人财产去反对资本主义生产的优势力量。我们只能许诺他们说，我们不会违反他们的意志而用强力干预他们的财产关系。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;作为政治力量的要素，农民至今在多数场合下仅仅表现出自己的那种生根于农村生活孤僻状况中的冷漠态度。广大居民群众的这种冷漠态度，不仅是巴黎和罗马国会腐败情况的强有力支柱，而且是俄罗斯专制主义的强有力的支柱。&lt;/li&gt;
&lt;li&gt;社会党夺取政权已成为最近将来的事情。然而</summary>
      
    
    
    
    <category term="my love" scheme="http://blog.zymatrix.top/categories/my-love/"/>
    
    
    <category term="哲学" scheme="http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="马列毛" scheme="http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"/>
    
  </entry>
  
  <entry>
    <title>《国家与革命》</title>
    <link href="http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%9B%BD%E5%AE%B6%E4%B8%8E%E9%9D%A9%E5%91%BD%E3%80%8B%20%E5%88%97%E5%AE%81/"/>
    <id>http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%9B%BD%E5%AE%B6%E4%B8%8E%E9%9D%A9%E5%91%BD%E3%80%8B%20%E5%88%97%E5%AE%81/</id>
    <published>2023-04-05T16:00:00.000Z</published>
    <updated>2024-08-12T09:17:09.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><ol><li>如果不同“国家”问题上的机会主义偏见作斗争，使劳动群众摆脱资产阶级影响、特别是摆脱帝国主义资产阶级影响的斗争就无法进行。</li><li>无产阶级社会主义革命对国家的态度问题不仅具有政治实践的意义，而且具有最迫切的意义，这个问题是要向群众说明，为了使自己从资本的枷锁下解放出来，他们在最近的将来应当做些什么。</li></ol><hr><h2 id="第一章-阶级社会与国家"><a href="#第一章-阶级社会与国家" class="headerlink" title="第一章 阶级社会与国家"></a>第一章 阶级社会与国家</h2><h4 id="国家是阶级矛盾不可调和的产物"><a href="#国家是阶级矛盾不可调和的产物" class="headerlink" title="国家是阶级矛盾不可调和的产物"></a>国家是阶级矛盾不可调和的产物</h4><ul><li>当伟大的革命家在世时，压迫阶级总是不断迫害他们，以最恶毒的敌意、最疯狂的仇恨、最放肆的造谣和诽谤对待他们的学说。在他们逝世以后，便试图把他们变为无害的神像，可以说把他们偶像化，赋予他们的名字某种荣誉，以便“安慰”和愚弄被压迫阶级，同时却阉割革命学说的内容，磨去它的革命锋芒，把它庸俗化。</li><li>国家是阶级矛盾不可调和的产物和表现。在阶级矛盾客观上不能调和的地方、时候和条件下，便产生国家。反过来说，国家的存在证明阶级矛盾不可调和。</li><li>在马克思看来，国家是阶级统治的机关，是一个阶级压迫另一个阶级的机关，是建立一种“秩序”来抑制阶级冲突，使这种压迫合法化、固定化。</li><li>既然国家是阶级矛盾不可调和的产物，既然它是凌驾于社会之上并且“日益同社会相异化”的力量，那么很明显，被压迫阶级要求得解放，不仅非进行暴力革命不可，而且非消灭统治阶级所建立的、体现这种“异化”的国家政权机构不可。</li></ul><h3 id="国家是剥削被压迫阶级的工具"><a href="#国家是剥削被压迫阶级的工具" class="headerlink" title="国家是剥削被压迫阶级的工具"></a>国家是剥削被压迫阶级的工具</h3><ul><li>他们自己相信而且要人民也相信这种荒谬的想法：普选制“在现今的国家里”能够真正体现大多数劳动者的意志，并保证实现这种意志。</li><li>目前，在任何民主共和国中，帝国主义和银行统治都把这两种维护和实现财富的无限权力的方法“发展”到了非常巧妙的地步。</li></ul><h3 id="国家“自行消亡”和暴力革命"><a href="#国家“自行消亡”和暴力革命" class="headerlink" title="国家“自行消亡”和暴力革命"></a>国家“自行消亡”和暴力革命</h3><ul><li>当国家终于真正成为整个社会的代表时，它就使自己成为多余的了。——恩格斯</li><li>那时，对人的统治将由对物的管理和对生产过程的领导所代替。国家不是“被废除的”，它是自行消亡的。——恩格斯</li><li>按恩格斯的看法，资产阶级国家不是“自行消亡”的，而是由无产阶级在革命中来“消灭”的。在这个革命以后，自行消亡的是无产阶级的国家或半国家。</li><li>显然，以一种（无产阶级的）“特殊力量”来代替另一种（资产阶级的）“特殊力量”，这样一种更替是决不能通过“自行消亡”来实现的。</li><li>因此任何国家都不是自由的，都不是人民的。</li></ul><hr><h2 id="第二章-国家与革命。1848-1851年的经验"><a href="#第二章-国家与革命。1848-1851年的经验" class="headerlink" title="第二章 国家与革命。1848-1851年的经验"></a>第二章 国家与革命。1848-1851年的经验</h2><h3 id="革命的前夜"><a href="#革命的前夜" class="headerlink" title="革命的前夜"></a>革命的前夜</h3><ul><li>无产阶级需要国家政权，中央集权的强力组织，暴力组织，既是为了镇压剥削者的反抗，也是为了领导广大民众即农民、小资产阶级和半无产者来“调整”社会主义经济。</li><li>马克思主义教育工人的党，也就是教育无产阶级的先锋队，使它能够夺取政权并引导全体人民走向社会主义，指导并组织新制度，成为所有被剥削劳动者在不要资产阶级并反对资产阶级而建设自己社会生活的事业中的导师、领导者和领袖。</li></ul><h3 id="1852年马克思对问题的提法"><a href="#1852年马克思对问题的提法" class="headerlink" title="1852年马克思对问题的提法"></a>1852年马克思对问题的提法</h3><ul><li>把马克思主义局限于阶级斗争学说，就是阉割马克思主义，歪曲马克思主义，把马克思主义变为资产阶级可以接受的东西。只有承认阶级斗争、同时也承认无产阶级专政的人，才是马克思主义者。</li></ul><hr><h2 id="第三章-国家与革命。1871年巴黎公社的经验。马克思的分析"><a href="#第三章-国家与革命。1871年巴黎公社的经验。马克思的分析" class="headerlink" title="第三章 国家与革命。1871年巴黎公社的经验。马克思的分析"></a>第三章 国家与革命。1871年巴黎公社的经验。马克思的分析</h2><h3 id="取消议会制"><a href="#取消议会制" class="headerlink" title="取消议会制"></a>取消议会制</h3><ul><li>我们不是空想主义者。我们并不“幻想”一下子就可以不要任何管理，不要任何服从；这种由于不懂得无产阶级专政的任务而产生的无政府主义幻想，与马克思主义根本不相容，实际上只会把社会主义革命拖延到人们变成另一种人的时候。</li><li>但是所需要的服从，是对一切被剥削劳动者的武装先锋队——无产阶级的服从。</li></ul><h2 id="第五章-国家消亡的经济基础"><a href="#第五章-国家消亡的经济基础" class="headerlink" title="第五章 国家消亡的经济基础"></a>第五章 国家消亡的经济基础</h2><h3 id="从资本主义到共产主义的过渡"><a href="#从资本主义到共产主义的过渡" class="headerlink" title="从资本主义到共产主义的过渡"></a>从资本主义到共产主义的过渡</h3><ul><li>产生违反公共生活规则的极端行动的根本社会原因是群众受剥削和群众贫困。这个主要原因一消除，极端行动就必然开始“消亡”。</li></ul><h3 id="共产主义社会的第一阶段"><a href="#共产主义社会的第一阶段" class="headerlink" title="共产主义社会的第一阶段"></a>共产主义社会的第一阶段</h3><ul><li>任何权利都是把同一标准应用在不同的人身上，即应用在事实上各不相同、各不同等的人身上，因而“平等的权利”就是破坏平等，就是不公平。</li><li>可见，在共产主义第一阶段还不能做到公平和平等，因为富裕的程度还会不同，而不同就是不公平。</li><li>可见，在共产主义下，在一定的时期内，不仅会保留资产阶级权利，甚至还会保留资产阶级国家，——但没有资产阶级！</li><li>其实，，无论在自然界或在社会中，实际生活随时随地都能使我们看到新事物中有旧的残余。马克思并不是随便把一小块“资产阶级”权利塞到共产主义中去，而是抓住了从资本主义脱胎出来的社会里那种在经济上和政治上不可避免的东西。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;如果不同“国家”问题上的机会主义偏见作斗争，使劳动群众摆脱资产阶级影响、特别是摆脱帝国主义资产阶级影响的斗争就无法进行。&lt;/li</summary>
      
    
    
    
    <category term="my love" scheme="http://blog.zymatrix.top/categories/my-love/"/>
    
    
    <category term="哲学" scheme="http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="马列毛" scheme="http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"/>
    
  </entry>
  
  <entry>
    <title>2022年度总结</title>
    <link href="http://blog.zymatrix.top/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.zymatrix.top/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-30T16:00:00.000Z</published>
    <updated>2024-08-12T09:15:39.418Z</updated>
    
    <content type="html"><![CDATA[<p>第一次对自己人生的十八分之一进行总结，不知是出于这一年自己太过庸常，还是波澜起伏的大事太多,<br>总之，我总算是愿意花上一点时间坐在电脑前，回顾一下这一年的纷扰，同时展望一下不可展望的未来。<br>马克·吐温说:“现实比小说荒诞多了，虚构还要在一定逻辑下进行，而现实往往毫无逻辑可言。”我愿意<br>用荒诞这样一个无法言说荒诞的词来概括这一年。这一年，我看到的我所认为魔幻的事件以一种难以预料<br>到的方式出现，以致所有人吹嘘其重要性的高考显得那么平常。<br>六月初的两天，我只是在安详之中度过，尽管身边的每一个人所展现出来的神态、语言和动作，都在明确<br>地告诉我这是我目前的人生中最重要的大事，但是我总会不屑地告诉自己，十八年前的那一天显然更为重<br>要。依照今日马后炮的回忆，它所带来的心情波动，甚至不及我填报志愿的几日和我住进宿舍的那一天。<br>我甚至不愿意再花上一分钟去回忆那段时光，因为只有同学、师长、亲人和书本值得被我记录。<br>这一年，我去到了大学，一个曾经令我魂牵梦萦的圣地。我厌倦了高中那重复难以获得新知的枯燥，度过<br>的日子就像是在沙漠里每日以沙子充饥。我说:“对于高中，回忆是痛苦的，最后在回忆里留下的一定是<br>一群值得怀念的人。”很多事只有当它出现在面前的时候，才能知道真正的模样。大学也是如此。毫无意<br>义的会议、毫无意义的课程、毫无意义的内耗这些是只有身在围城中的人才能深切知晓的。我只会把大学<br>丑陋的一面讲述给自己，至于那些美好的画面，在那之前我已经幻想得足够多了。<br>这一年，无能的官僚资产阶级在无产阶级爆发出的怨气和对乌鲁木齐火灾中不幸罹难的同胞的同情中被迫<br>让步，全国各地此起彼伏的游行示威宣示着对官僚资产阶级的不满。我很高兴能够见到这一切，我仍然记<br>得那天我是怎样的激动，看着手机上的新闻，身体有些微微颤抖。这样一件大事，对我的鼓舞比这一年里<br>任何事情都更加明显。这一年，我下定决心，开始学习马列毛主义思想，这些人类历史长河中闪耀的明<br>星，他们将是我未来精神上的导师。<br>这一年，我第一次深刻地领悟到了自己在行动上如何地侏儒。那个决心在暑假阅遍数十书的书虫不见了<br>取而代之的是无营养的知乎;那个决心要好好学习的“卷怪”不见了，取而代之的是无尽的游戏;那个决<br>心要动笔写作的想象者不见了，我看到了自己荒芜的想象世界和波澜不惊的感情世界。简单来说，我缺失<br>了爱的能力。生动的小说世界和情感丰沛的诗再也没有出现在生活之中，我曾经用来思考的碎片时间被智<br>能手机填充，稍稍空闲下来的间隙，眼睛盯着的不是空气而是屏幕，本就不够深邃的思维愈发迟钝，质问<br>和怀疑之后剩下的不是重新行动，而是一地鸡毛。<br>这一年，“我年华虚度，空余一身疲惫，和所有以梦为马的诗人一样，岁月易逝，一滴不剩”<br>很奇怪，漫长的一年值得纪念的寥寥数语就能概括，而短暂的一天我却怎么也过不好。<br>至于对未来的期望，不过是些老调重弹的东西，写下对这一年的回顾后，我不想对未来再有什么幻想了,<br>只送给2023年一句毛泽东同志的话:“好好学习，天天向上”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一次对自己人生的十八分之一进行总结，不知是出于这一年自己太过庸常，还是波澜起伏的大事太多,&lt;br&gt;总之，我总算是愿意花上一点时间坐在电脑前，回顾一下这一年的纷扰，同时展望一下不可展望的未来。&lt;br&gt;马克·吐温说:“现实比小说荒诞多了，虚构还要在一定逻辑下进行，而现实往往毫</summary>
      
    
    
    
    
    <category term="杂记" scheme="http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
