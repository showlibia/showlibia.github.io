{"meta":{"title":"Matrix's blog","subtitle":"","description":"那时她还年轻，不知道命运馈赠的礼物都在暗中标好了价格","author":"Matrix","url":"http://blog.zymatrix.top","root":"/"},"pages":[{"title":"分类","date":"2024-08-12T09:23:00.000Z","updated":"2024-08-12T09:23:46.204Z","comments":true,"path":"categories/index.html","permalink":"http://blog.zymatrix.top/categories/index.html","excerpt":"","text":""},{"title":"建站小记","date":"2023-04-05T16:00:00.000Z","updated":"2024-01-01T16:58:53.557Z","comments":true,"path":"about/index.html","permalink":"http://blog.zymatrix.top/about/index.html","excerpt":"","text":"建站原因在b站上看到了一个搭建个人博客网站的视频，心血来潮以及作为Geek必备的博客作为驱动力，于是查找了一些资料最终找到了以github + hexo 的方式建立博客。感谢朋友（畅姐我的神）的倾情推荐，给了我一个好教程。 曲折的建站过程说到这个，不得不吐槽一下我这令人愤怒的电脑。从我大一上学期配C语言环境开始，再到虚拟机和linux ssh远端连接，这玩意就没让我省心过。吐槽结束，现在是问题时间。 一由于初次上手个人网站搭建，所知甚少。而且最开始时，没有如此系统的教程，都是用的零七碎八的教程，难免遇到各种问题。 npm node hexo 安装完成后出现类似command not found的问题，用Google搜索、在stackoverflow上找相关问题，都没能解决这个问题，最后尝试了csdn上的一个说法，即设置环境变量,在path下面加上npm node hexo等的路径，成功解决问题。（多少有点zz了）路径问题占据了我建站的绝大多数时间。 设置部署仓库和分支出现 “FATAL YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key (107:14)” 的问题。这个问题是因我在更改hexo源码根目录下的_config.yml中的deploy部分直接复制粘贴引起的。参考下图，在repo:以及branch:的冒号后面要加上’ ‘空格。 目前尚未解决的问题。GitHub Actions自动部署，按照教程上传workflow文件到github上，但是目前还没成功，也没查原因。 在执行hexo generate和hexo deploy命令时可能会出现kex_exchange_identification: Connection closed by remote host Connection closed by 20.205.243.166 port 22 fatal: Could not read from remote repository的错误信息，这个时候需要改变一下自己的vpn节点，或者在vpn速度较好时再重新执行hexo d的命令。 二建站完成之后，就是要对网站进行个性化的修改，对样式进行处理 在文章的头部部分增加一下内容能够达到对文章进行分类的效果。这些内容可以在_config.yml文件中找到对应的部分。 1234567891011---title: #文章标题toc: true #是否包含目录cover: #文章封面的图片的链接或者地址category: #文章在子页中的分类tag: - #文章的标签id: #文章的序号date: #文章写作的时间timeline: #在时间线中的分类---"},{"title":"标签","date":"2024-08-11T16:00:00.000Z","updated":"2024-08-12T09:22:38.009Z","comments":false,"path":"tags/index.html","permalink":"http://blog.zymatrix.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++基础","slug":"C++基础","date":"2024-09-10T16:00:00.000Z","updated":"2024-09-17T12:01:59.255Z","comments":true,"path":"2024/09/11/C++基础/","link":"","permalink":"http://blog.zymatrix.top/2024/09/11/C++%E5%9F%BA%E7%A1%80/","excerpt":"","text":"学习思路 学习误区 太注重C++语言本身 喜欢量化学习的程度 太注重方向，做出的项目不通用，错失offer 学习思路 做的项目要有产品化的思维 需要开箱即用 多长时间，换工作 一年半：应届生，前半年学生转为职场人士，经过半年能独立做开发 之前没有系统性的从头开始学习C++，因此此博客仅用于记录快速系统学习C++语法知识。 C++基础基本特性程序执行过程程序被执行后就被称为一个进程，一个进程可以被划分为很多区域，这门课我们只需要理解以下的四个区就可以了。 代码区与常量区：进程按照代码区的代码执行，真正的常量也存储在这里，比如“abc”字符串，“1”，“88”等数字。这些是真正的常量。再看一下const关键字。const只不过是让编译器将变量视为常量罢了，和真正的常量有本质上的区别。 栈区：函数的执行所需的空间，注意，当函数执行完毕，函数对应的栈内存全部销毁。 堆区：进程用来灵活分配内存的地方，只有手动释放时才会销毁内存。 静态变量区：用来存储静态变量与全局变量的区域 (1) 静态变量：常常需要一些局部作用范围，生命周期却很长的变量 (2) 全局变量：重要性就不必说了，在c语言程序中经常用到，但在C++中不推荐使用，因为会破坏封装性。 具体的存储方式如图所示： 堆区和栈区，是程序运行的主要地方。 至于堆区，主要意义在于灵活的生命周期。 如果需要创建的对象有几十M，每次调用函数都需要创建一个这么大的对象，再复制到对应的容器中，那就太过耗费内存了。而且栈内存非常的小，通常不超过8M。 而使用堆内存，每调用一次函数就可以在堆内存中创建一个对象，容器中只要存储指针就可以了，极大的提高了程序效率。 而静态变量区： 有很多情况下，我们需要作用范围局限在函数之内，但生命周期却很长的变量，比如统计一个函数被调用的次数。 总结：栈区是函数执行的区域，堆区是函数内灵活分配内存的地方，二者缺一不可。 为什么不能只在栈上运行程序，因为当函数运行结束时，栈是要销毁的，其上分配的内存全部失效。 也不能只在堆上运行程序，因为堆的唯一寻址方式就是指针，如果没有栈，根本无法使用堆。 栈区远远小于堆区，一般不超过8M，所以主要的内容都在对堆区上。堆区很大，虚拟内存剩下的都是堆区。 const关键字const关键字介绍：const是让编译期将变量视为常量，用const修饰的变量和真正的常量有本质的区别。 真正的常量存储在常量区或代码区，比如“abcdefg”这个字符串就存储在常量区，而“3”，“100”这些数字就存储在代码区中，这些都是真正的常量，无法用任何方式修改。 const修饰的变量仍然存储在堆区或栈区中，从内存分布的角度讲，和普通变量没有区别。const修饰的变量并非不可更改的，C++本身就提供了mutable关键字用来修改const修饰的变量，从汇编的角度讲，const修饰的变量也是可以修改的。 auto关键字auto是C++11新加入的关键字，就是为了简化一些写法。 使用auto推断类型确实简单方便，但有个基本要求，就是在使用auto时清楚的知道编译器会给auto推断出什么类型。 auto需要注意以下几点： auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号。 auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。 auto关键字在推断类型时，如果没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。 auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留。 其实3，4为什么会出现这种情况，因为在传递值时，修改这个值并不会对原有的值造成影响。而传递引用时，修改这个值会直接对原有的值造成影响。 当然，我们可以在前面加上const，这样永远都有const的含义。 auto不会影响编译速度，甚至会加快编译速度。因为编译器在处理XX a &#x3D; b时，当XX是传统类型时，编译期需要检查b的类型是否可以转化为XX。当XX为auto时，编译期可以按照b的类型直接给定变量a的类型，所以效率相差不大，甚至反而还有提升。 auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先。 auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题。 静态变量 指针 引用变量的存储位置有三种，分别是静态变量区，栈区，堆区。 静态变量区在编译时就已经确定地址，存储全局变量与静态变量。 指针都是存储在栈上或堆上，不管在栈上还是堆上，都一定有一个地址。 本质上说，指针和普通变量没有区别。 在32位系统中，int变量和指针都是32位。指针必须和“&amp;”，“*”这两个符号一起使用才有意义。 &amp;a代表的a这个变量的地址，a代表的a对应地址存储的值，*a代表对应地址存储的值作为地址对应的值。 所以指针才可以灵活的操作内存，但这也带来了严重的副作用，比如指针加加减减就可以操作内存，所以引用被发明了，引用就是作用阉割的指针（可以视为“类型const”，所以引用必须上来就赋初值，不能设置为空），编译器不将其视作对象，操作引用相当于操作引用指向的对象。*也就从根本是杜绝了引用篡改内存的能力。 左右值左值右值从C++11开始就是一个很重要的概念了，但想要真正理解左值，右值不是一件容易的事。 **C++**任何一个对象要么是左值，要么是右值。 比如int i &#x3D; 10，i和10都是对象 左值：拥有地址属性的对象就叫左值，左值来源于c语言的说法，能放在“&#x3D;”左面的就是左值，注意，左值也可以放在“&#x3D;”右面。 右值：不是左值的对象就是右值。或者说无法操作地址的对象就叫做右值。一般来说，判断一个对象是否为右值，就看它是不是左值，有没有地址属性，不是左值，那就是右值。 比如临时对象，就都是右值，临时对象的地址属性无法使用。 **注意：左值也可以放在“&#x3D;”右面，但右值绝对不可以放在等号左面 接下来就是大量举例了，说明那些是左值，哪些是右值。 比如++i是对i自增然后返回i，是左值，i++是先复制一个i返回临时对象，再自增，是右值 引用分类 (1) 普通左值引用：就是一个对象的别名，只能绑定左值，无法绑定常量对象。 (2) const左值引用：可以对常量起别名，可以绑定左值和右值。 (3) 右值引用：只能绑定右值的引用。 (4) 万能引用： move函数(1) 右值看重对象的值而不考虑地址，move函数可以对一个左值使用，使操作系统不再在意其地址属性，将其完全视作一个右值。 (2) move函数让操作的对象失去了地址属性，所以我们有义务保证以后不再使用该变量的地址属性，简单来说就是不再使用该变量，因为左值对象的地址是其使用时无法绕过的属性。 临时对象：右值都是不体现地址的对象。那么，还有什么能比临时对象更加没有地址属性呢？右值引用主要负责处理的就是临时对象。 程序执行时生成的中间对象就是临时对象，注意，所有的临时对象都是右值对象，因为临时对象产生后很快就可能被销毁，使用的是它的值属性。 可调用对象如果一个对象可以使用调用运算符“()”，()里面可以放参数，这个对象就是可调用对象。 可调用对象的分类： 1. 函数：函数自然可以调用()运算符，是最典型的可调用对象。 2. 仿函数：具有operator()函数的类对象，此时类对象可以当做函数使用，因此称为仿函数。 3. lambda表达式：就是匿名函数，普通的函数在使用前需要找个地方将这个函数定义，于是C++提供了lambda表达式，需要函数时直接在需要的地方写一个lambda表达式，省去了定义函数的过程，增加开发效率。 lambda表达式的格式：最少是“[] {}”，完整的格式为“[] () -&gt;ret {}”。 lambda各个组件介绍 []代表捕获列表：表示lambda表达式可以访问前文的哪些变量。 (1) []表示不捕获任何变量。 (2) [&#x3D;]：表示按值捕获所有变量。 (3) [&amp;]：表示按照引用捕获所有变量。 &#x3D;，&amp;也可以混合使用，比如 (4) [&#x3D;, &amp;i]：表示变量i用引用传递，除i的所有变量用值传递。 (5) [&amp;, i]：表示变量i用值传递，除i的所有变量用引用传递。 当然，也可以捕获单独的变量 (6) [i]：表示以值传递的形式捕获i (7) [&amp;i]：表示以引用传递的方式捕获i ()代表lambda表达式的参数，函数有参数，lambda自然也有。 -&gt;ret表示指定lambda的返回值，如果不指定，lambda表达式也会推断出一个返回值的。 {}就是函数体了，和普通函数的函数体功能完全相同。 C++的可调用对象主要就这三个，当然，这三个也可以衍生出很多写法。最常见的就是函数指针，函数指针的本质就是利用指针调用函数，本质还是函数，在C++11当中引入了std::function，可以起到和函数指针一样的效果。使用function函数，可以在lambda为调用的函数时捕获变量。函数指针要细分也可以分为指向类成员函数的指针，指向普通函数的指针。 类this，常成员函数与常对象 this关键字： (1) this是什么： 编译器将this解释为指向函数所作用的对象的指针。C++类的本质就是C语言的结构体外加几个类外的函数，C++最后都要转化为C语言来实现，类外的函数就是通过this来指向这个类的。 当然，这么说并非完全准确，this是一个关键字，只是我们将它当做指针理解罢了。 this有很多功能是单纯的指针无法满足的。比如每个类函数的参数根本没有名 叫this的指针。这不过是编译器赋予的功能罢了。 常成员函数和常对象 常成员函数和常对象很多人并不在意，确实，都写普通变量也可以。但是，在大型程序中，尽量加上const关键字可以减少很多不必要的错误。 (1) const关键字含义：这里说一下常成员函数和常对象。 常成员函数就是无法修改成员变量的函数。可以理解为将this指针指向对象用const修饰的函数。 常对象就是用const修饰的对象，定义好之后就再也不需要更改成员变量的值了。常对象在大型程序中还是很有意义的。 (2) 常成员函数注意事项： 因为类的成员函数已经将this指针省略了，只能在函数后面加const关键字来实现无法修改类成员变量的功能了 注意：常函数无法调用了普通函数，否则常函数的这个“常”字还有什么意义。 成员函数能写作常成员函数就尽量写作常成员函数，可以减少出错几率。 同名的常成员函数和普通成员函数是可以重载的，常量对象会优先调用常成员函数，普通对象会优先调用普通成员函数 (1) 常对象注意事项： 常对象不能调用普通函数。 常函数在大型程序中真的很重要，很多时候我们都需要创建好就不再改变的对象。 (2) 总结：常成员函数和常对象要多用，这真的是一个非常好的习惯，写大项目可以少出很多bug 一些关键字 inline关键字 (1) inline关键字的有什么作用： 在函数声明或定义中函数返回类型前加上关键字inline就可以把函数指定为内联函数。关键字inline必须与函数定义放在一起才能使函数成为内联，仅仅将inline放在函数声明前不起任何作用。 内联函数的作用，普通函数在调用时需要给函数分配栈空间以供函数执行，压栈等操作会影响成员运行效率，于是C++提供了内联函数将函数体放到需要调用函数的地方，用空间换效率。 (2) inline关键字的注意事项：inline关键字只是一个建议，开发者建议编译器将成员函数当做内联函数，一般适合搞内联的情况编译器都会采纳建议。 (3) Inline关键字的总结。使用inline关键字就是一种提高效率，但加大编译后文件大小的方式，现在随着硬件性能的提高，inline关键字用的越来越少了。 mutable关键字 (1) mutable关键字的作用： Mutable意为可变的，与const相对，被mutable修饰的成员变量，永远处于可变的状态，即便处于一个常函数中，该变量也可以被更改。 这个关键字在现代C++中使用情况并不多，一般来说只有在统计函数调用次数时才会用到。 (2) mutable关键字的注意事项 mutable是一种万不得已的写法，一个程序不得不使用mutable关键字时，可以认为这部分程序是一个糟糕的设计。 mutable不能修饰静态成员变量和常成员变量。 (3) 总结：mutable关键字是一种没有办法的办法，设计时应该尽量避免，只有在统计函数调用次数这类情况下才推荐使用。这个关键字也称不上是重点。 default关键字 (1) default关键字的作用：default关键字的作用很简单。 在编译时不会生成默认构造函数时便于书写。 也可以对默认复制构造函数，默认的赋值运算符和默认的析构函数使用，表示使用的是系统默认提供的函数，这样可以使代码更加明显。 现代C++中，哪怕没有构造函数，也推荐将构造函数用default关键字标记，可以让代码看起来更加直观，方便。 总结：default关键字还是推荐使用的，在现代C++代码中，如果需要使用一些默认的函数，推荐用default标记出来。 delete关键字 (1) Delete关键字的作用：C++会为程序生成默认构造函数，默认复制构造函数，默认重载赋值运算符（重载部分会详细讲解）。 在很多情况下，我们并不希望这些默认的函数被生成，在C++11以前，只能有将此 函数声明为私有函数或是将函数只声明不定义两种方式。 C++11于是提供了delete关键字，只要在函数最后加上“&#x3D;delete”就可以明确告诉 编译期不要默认生成该函数。 总结：delete关键字还是推荐使用的，在现代C++代码中，如果不希望一些函数默认生成，就用delete表示，这个功能还是很有用的，比如在单例模式中， 重载运算符重载运算符在整个C++中拥有非常重要的地位，这一节非常重要。 重载运算符的作用： (1) 很多时候我们想让类对象也能像基础类型的对象一样进行作基础操作，比如“+”，“-”，“*”，“\\”，也可以使用某些运算符“&#x3D;”，“()”，“[]”,“&lt;&lt;”，“&gt;&gt;”。但是一般的类即使编译器可以识别这些运算符，类对象也无法对这些运算符做出应对，我们必须对类对象定义处理这些运算符的方式。 (2) C++提供了定义这些行为的方式，就是“operator 运算符”来定义运算符的行为，operator是一个关键字，告诉编译器我要重载运算符了。 注意： (1) 我们只能重载C++已有的运算符，所有无法将“”这个运算符定义为指数的形式，因为C++根本没有“”这个运算符。 (2) C++重载运算符不能改变运算符的元数，“元数”这个概念就是指一个运算符对应的对象数量，比如“+”必须为“a + b”，也就是说“+”必须有两个对象，那么“+”就是二元运算符。比如“++”运算符，必须写为“a++”，也就是一元运算符。 重载运算符举例 (1) 一元运算符重载 ① “++”，“–”, ② “[]” ③ “()” ④ “&lt;&lt;”，“&gt;&gt;” (2) 二元运算符重载 ① “+”，“-”，“*”，“&#x2F;” ② “&#x3D;”， ③ “&gt;”，“&lt;”，“&#x3D;&#x3D;” 至于唯一的三元运算符“?:”，不能重载 (3) 类类型转化运算符：“operator 类型” (4) 特殊的运算符：new，delete，new[]，delete[] 注意：“&#x3D;”类会默认进行重载，如果不需要可以用“delete关键字进行修饰”。 总结：重载运算符非常重要，C++类中几乎都要定义各种各种的重载运算符。 继承 C++继承介绍：C++非继承的类相互是没有关联性的，假设现在需要设计医生，教师，公务员三个类，需要定义很多重复的内容而且相互没有关联，调用也没有规律。如果这还算好，那一个游戏有几千件物品，调用时也要写几千个函数。这太要命了。于是继承能力就应运而生了。 C++继承原理：C++的继承可以理解为在创建子类成员变量之前先创建父类的成员变量，实际上，C语言就是这么模仿出继承功能的。 C++继承的注意事项。 (1) C++子类对象的构造过程。先调用父类的构造函数，再调用子类的构造函数，也就是说先初始化父类的成员，再初始化子类的成员。 (2) 若父类没有默认的构造函数，子类的构造函数又未调用父类的构造函数，则无法编译。 (3) C++子类对象的析构过程。先调用父类的析构函数，再调用子类的析构函数。 总结：面向对象三大特性的继承就这么简单，很多人觉得类继承很复杂，其实完全不是这样的，只要明白子类在内存上其实就相当于把父类的成员变量放在子类的成员变量前面罢了。构造和析构过程也是为了这个机制而设计的。 虚函数 虚函数介绍： (1) 虚函数就是面向对象的第三大特点：多态。多态非常的重要，它完美解决了上一课设计游戏装备类的问题，我们可以只设计一个函数，函数参数是基类指针，就可以调用子类的功能。比如射击游戏，所有的枪都继承自一个枪的基类，人类只要有一个开枪的函数就可以实现所有枪打出不同的子弹。 (2) 父类指针可以指向子类对象，这个是自然而然的，因为子类对象的内存前面就是父类成员，类型完全匹配。 (3) 当父类指针指向子类对象，且子类重写父类某一函数时。父类指针调用该函数，就会产生以下的可能 ① 该函数为虚函数：父类指针调用的是子类的成员函数。 ② 该函数不是虚函数：父类指针调用的是父类的成员函数。 虚函数的注意事项： (1) 子父类的虚函数必须完全相同，为了防止开发人员一不小心将函数写错，于是C++11添加了override关键字。 (2) 父类的析构函数必须为虚函数：这一点很重要，当父类对象指向子类对象时，容易使独属于子类的内存泄露。会造成内存泄露的严重问题。 overide关键字的作用：前面已经说过了，为了防止开发人员将函数名写错了，加入了override关键字。 4. 虚函数实现多态的原理介绍 (1) 动态绑定和静态绑定： ① 静态绑定：程序在编译时就已经确定了函数的地址，比如非虚函数就是静态绑定。 ② 动态绑定：程序在编译时确定的是程序寻找函数地址的方法，只有在程序运行时才可以真正确定程序的地址，比如虚函数就是动态绑定。 (2) 虚函数是如何实现动态绑定的呢？ ① 每个有虚函数的类都会有一个虚函数表，对象其实就是指向虚函数表的指针，编译时编译器只告诉了程序会在运行时查找虚函数表的对应函数。每个类都会有自己的虚函数表，所以当父类指针引用的是子类虚函数表时，自然调用的就是子类的函数。 总结：虚函数是C++类的重要特性之一，很简单，但使用频率非常高，至于如何实现的也要掌握。 RTTI RTTI介绍： (1) RTTI（Run Time Type Identification）即通过运行时类型识别，程序能够通过基类的指针或引用来检查这些指针或引用所指向的对象的实际派生类。 (2)C++为了支持多态，C++的指针或引用的类型可能与它实际指向对象的类型不相同，这时就需要rtti去判断类的实际类型了，rtti是C++判断指针或引用实际类型的唯一方式。 RTTI的使用场景：可能有很多人会疑惑RTTI的作用，所以单独拿出来说一下。 (1) 异常处理：这是RTTI最主要的使用场景，具体作用在异常处理章节会详细讲解。 (2) IO操作：具体作用等到IO章节会详细讲解。 RTTI的使用方式：RTTI的使用过程就两个函数 (1) typeid函数：typeid函数返回的一个叫做type_info的结构体，该结构体包括了所指向对象的实际信息，其中name()函数就可以返回函数的真实名称。type_info结构体其他函数没什么用. (2) dynamic_cast函数：C++提供的将父类指针转化为子类指针的函数。 RTTI的注意事项： (1)当使用typeid函数时，父类和子类必须有虚函数（父类有了虚函数，子类自然会有虚函数），否则类型判断会出错。 RTTI总结：就是C++在运行阶段判断对象实际类型的唯一方式。 移动构造函数与移动赋值运算符 对象移动的概念： (1) 对一个体积比较大的类进行大量的拷贝操作是非常消耗性能的，因此C++11中加入了“对象移动”的操作 (2) 所谓的对象移动，其实就是把该对象占据的内存空间的访问权限转移给另一个对象。比如一块内存原本属于A，在进行“移动语义”后，这块内存就属于B了。 移动语义为什么可以提高程序运行效率。因为我们的各种操作经常会进行大量的“复制构造”，“赋值运算”操作。这两个操作非常耗费时间。移动构造是直接转移权限，这是不是就快多了。 注意：在进行转移操作后，被转移的对象就不能继续使用了，所以对象移动一般都是对临时对象进行操作（因为临时对象很快就要销毁了）。 注意这里的右值引用不能是const的，因为你用右值引用函数参数就算为了让其绑定到一个右值上去的！就是说这个右值引用是一定要变的，但是你一旦加了const就没法改变该右值引用了。 3. 默认移动构造函数和默认移动赋值运算符 会默认生成移动构造函数和移动赋值运算符的条件： 只有一个类没有定义任何自己版本的拷贝操作（拷贝构造，拷贝赋值运算符），且类的每个非静态成员都可以移动，系统才能为我们合成。 可以移动的意思就是可以就行移动构造，移动赋值。所有的基础类型都是可以移动的，有移动语义的类也是可以移动的。 智能指针 为什么要有智能指针：直接使用new和delete运算符极其容易导致内存泄露，而且非常难以避免。于是人们发明了智能指针这种可以自动回收内存的工具。 智能指针一共就三种：普通的指针可以单独一个指针占用一块内存，也可以多个指针共享一块内存。 (1) 共享型智能指针：shared_ptr，同一块堆内存可以被多个shared_ptr共享。 (2) 独享型智能指针：unique_ptr，同一块堆内存只能被一个unique_ptr拥有。 (3) 弱引用智能指针：weak_ptr，也是一种共享型智能指针，可以视为对共享型智能指针的一种补充 智能指针和裸指针不要混用 shared_ptr1.shared_ptr的工作原理 (1) 我们在动态分配内存时，堆上的内存必须通过栈上的内存来寻址。也就是说栈上的指针（堆上的指针也可以指向堆内存，但终究是要通过栈来寻址的）是寻找堆内存的唯一方式。 (2) 所以我们可以给堆内存添加一个引用计数，有几个指针指向它，它的引用计数就是几，当引用计数为0是，操作系统会自动释放这块堆内存。 2.常用操作 (1) 初始化 使用new运算符初始化 一般来说不推荐使用new进行初始化，因为C++标准提供了专门创建shared_ptr的函数“make_shared”，该函数是经过优化的，效率更高。 ② 使用make_shared函数进行初始化： 注意：千万不要用裸指针初始化shared_ptr，容易出现内存泄露的问题。 ③ 当然使用复制构造函数初始化也是没有问题的。 (2)shared_ptr的引用计数： 智能指针就是通过引用计数来判断释放堆内存时机的。 use_count()函数可以得到shared_ptr对象的引用计数。 3. 智能指针可以像普通指针那样使用，”share_ptr”早已对各种操作进行了重载，就当它是普通指针就可以了。 4. shared_ptr的常用函数 (3) unique函数：判断该shared_ptr对象是否独占若独占，返回true。否则返回false。 (4) reset函数： ① 当reset函数有参数时，改变此shared_ptr对象指向的内存。 ② 当reset函数无参数时，将此shared_ptr对象置空，也就是将对象内存的指针设置为nullptr。 (5) get函数，强烈不推荐使用： 如果一定要使用，那么一定不能delete返回的指针。 (6) swap函数：交换两个智能指针所指向的内存 ① std命名空间中全局的swap函数 ② shared_ptr类提供的swap函数 关于智能指针创建数组的问题。 用智能指针作为参数传递时直接值传递就可以了。shared_ptr的大小为固定的8或16字节（也就是两倍指针的的大小，32位系统指针为4个字节，64位系统指针为8个字节，shared_ptr中就两个指针），所以直接值传递就可以了。 总结：在现代程序中，当想要共享一块堆内存时，优先使用shared_ptr，可以极大的减少内存泄露的问题。 weak_ptr1.weak_ptr介绍： (1) 这个智能指针是在C++11的时候引入的标准库，它的出现完全是为了弥补shared_ptr天生有缺陷的问题，其实shared_ptr可以说近乎完美。 (2) 只是通过引用计数实现的方式也引来了引用成环的问题，这种问题靠它自己是没办法解决的，所以在C++11的时候将shared_ptr和weak_ptr一起引入了标准库，用来解决循环引用的问题。 shared_ptr的循环引用问题： weak_ptr的作用原理：weak_ptr的对象需要绑定到shared_ptr对象上，作用原理是weak_ptr不会改变shared_ptr对象的引用计数。只要shared_ptr对象的引用计数为0，就会释放内存，weak_ptr的对象不会影响释放内存的过程。 4. weak_ptr的总结：weak_ptr使用较少，就是为了处理shared_ptr循环引用问题而设计的。 unique_ptr uniqe_ptr介绍：独占式智能指针，在使用智能指针时，我们一般优先考虑独占式智能指针，因为消耗更小。如果发现内存需要共享，那么再去使用“shared_ptr”。 unique_ptr的初始化：和shared_ptr完全类似 (1) 使用new运算符进行初始化 (2) 使用make_unique函数进行初始化 3.unique_ptr的常用操作 (1) unque_ptr禁止复制构造函数，也禁止赋值运算符的重载。否则独占便毫无意义。、 (2) unqiue_ptr允许移动构造，移动赋值。移动语义代表之前的对象已经失去了意义，移动操作自然不影响独占的特性。 (3) reset函数： ① 不带参数的情况下：释放智能指针的对象，并将智能指针置空。 ② 带参数的情况下：释放智能指针的对象，并将智能指针指向新的对象。 将unque_ptr的对象转化为shared_ptr对象，当unique_ptr的对象为一个右值时，就可以将该对象转化为shared_ptr的对象。 这个使用的并不多，需要将独占式指针转化为共享式指针常常是因为先前设计失误。 注意：shared_ptr对象无法转化为unique_ptr对象。 模板与泛型编程模板介绍，类模板与模板实现原理1. 模板的介绍： (1) 模板能够实现一些其他语法难以实现的功能，但是理解起来会更加困难，容易导致新手摸不着头脑。 (2) 模板分为类模板和函数模板，函数模板又分为普通函数模板和成员函数模板。 2. 类模板基础： (1) 类模板的写法与使用十分固定 3. 模板的实现原理： 模板需要编译两次，在第一次编译时仅仅检查最基本的语法，比如括号是否匹配。等函数真正被调用时，才会真正生成需要的类或函数。 所以这直接导致了一个结果，就是不论是模板类还是模板函数，声明与实现都必须放在同一个文件中。因为在程序在编译期就必须知道函数的具体实现过程。如果实现和声明分文件编写，需要在链接时才可以看到函数的具体实现过程，这当然会报错。 于是人们发明了.hpp文件来存放模板这种声明与实现在同一文件的情况。 initializer_list与typename initializer_list的用法 initializer_list介绍：initializer_list其实就是初始化列表，我们可以用初始化列表初始化各种容器，比如“vector”，“数组”。 typename的用法 (1) 在定义模板时表示这个一个待定的类型 (2) 在类外表明自定义类型时使用 在C++的早期版本，为了减少关键字数量，用class来表示模板的参数，但是后来因为第二个原因，不得不引入typename关键字。 模板的重载，全特化和偏特化 模板的重载 (1) 函数模板是可以重载的（类模板不能被重载），通过重载可以应对更加复杂的情况。比如在处理char和string对象时，虽然都可以代表字符串，但char在复制时直接拷贝内存效率明显更高，string就不得不依次调用构造函数了。所以在一些比较最求效率的程序中对不同的类型进行不同的处理还是非常有意义的。 其实函数模板的重载和普通函数的重载没有什么区别。 模板的特化 (1) 模板特化的意义：函数模板可以重载以应对更加精细的情况。类模板不能重载，但可以特化来实现类似的功能。 (2) 模板的特化也分为两种，全特化和偏特化。模板的全特化：就是指模板的实参列表与与相应的模板参数列表一一对应。 (3) 模板的偏特化：偏特化就是介于普通模板和全特化之间，只存在部分类型明确化，而非将模板唯一化。 (4) 其实对于函数模板来说，特化与重载可以理解为一个东西。 STL简介 stl的介绍： (1) stl就是（standard template library）的简称，定义在std命名空间中，定义了C++常用的容器与算法等。 stl极大的提高了我们的程序开发效率。 在C++开发中，可以说：不会用stl的人，会用stl但不懂stl实现原理的人，既会使用stl，又懂得stl实现原理的人是完完全全的三个档次。 (2) 泛型编程的概念：用模板进行编程，可以实现一些其它方式难以实现的功能，但对于新手来说，泛型编程可能会难以理解，摸不着头脑。 也就是说，模板是学习泛型编程的基础。 注意：泛型编程不属于面向对象编程的范畴，泛型编程和面向对象编程是并列的。 (3) stl作为泛型编程的最典型代表，它实现了其它编程方式难以实现的效果，比如将整个模板库分为六个部分，每个部分可以单独设计。举个最简单的例子，vector和map在数据结构方面完全不一样，但stl可以设计出“迭代器”这个模块，让该模块可以在不同的数据结构中按照同样的方式运行。这种技术没有泛型编程是难以实现的。 学习stl的注意事项 (1) 学习stl一定要有全局观念，不要局限于单个容器，重点在于明白六大组件之间的联系。 (2) 当然，如果只是单纯为了应付当前的业务，单独学一下某个容器的用法也没有问题。 SLT的六大容器介绍： (1) 容器（container）：是一种数据结构，也就是真正用来存储数据的地方。分为三类 ① 顺序式容器： ② 关联式容器： ③ 无序式容器：其实无序式容器也是一种关联式容器，但是既然C++标准委员会将无序容器与关联式容器平行的列了出来，那么我们这里也就让无序式容器和关联式容器平行吧。 (2) 迭代器（iterator）：提供了可以访问任何容器的方法。 (3) 算法（alogorithm）：用来操作容器中的数据的模板函数。 (4) 仿函数（functor） (5) 适配器（adaptor） (6) 分配器（allocator） 容器1. 顺序容器（sequence container）：每个元素都有固定的位置，位置取决于插入时间和地点，与元素的值无关 (1) vector：将元素置于一个动态数组中，可以随机存储元素（也就是用索引直接存取）。 数组尾部添加或删除元素非常迅速。但在中部或头部就比较费时。 (2) deque：“double end queue”的缩写，也就是双端队列。deque的实现相比于vector有些复杂，但本质仍然是优化过的动态数组，只不过相比于单纯的动态数组，在前面添加或删除元素非常快了。 可以随机存储元素。头部和尾部添加或删除元素都非常快（略慢与vector）。但在 中间插入元素比较费时（和vector差不多）。 (3) list：本质就是链表，所以自然具有了链表的属性。 不能随机存取元素（也就是lis无法用索引存取元素）。在任何位置插入和删除元 素都比较迅速。（在任何位置插入删除元素的时间相同，在元素头部操作慢于deque，在元素尾部操作慢于deque和vector） (4) string：把普通字符串封装了一下 (5) forward_list：单项链表，简单来说就是受限的list，凡是list不支持的功能，它都不支持。做各种支持的操作效率都会高于list，最典型的就排序算法了，forword_list要优于list。 ① ForwordList 只提供前向迭代器，而不是双向迭代器。因此它也不支持反向迭代器。 ② ForwordList不提供成员函数 size()。 ③ ForwordList 没有指向最末元素的锚点。基于这个原因，不提供用以处理最末元素的成员 back(),push_back(),pop_back()。 2. 关联容器（associated container）：元素位置取决于元素的值，和插入顺序无关。 (1) set&#x2F;multiset：使用“红黑树”实现，是一种高度平衡的二叉树，如果大家不了解红黑树，可以去百度一下。了解个大概就可以了。二叉树的本质决定了**set&#x2F;multiset的元素存取值取决于元素本身的值，和插入顺序无关。 内部元素的值依据元素的值自动排列，与插入顺序无关。set内部相同数值的元素只能出现一次，multiset内部相同数值的元素可出现多次。容器用二叉树实现，便于查找。 (2) map&#x2F;multimap：使用“红黑树”实现，是一种高度平衡的二叉树。 内部元素是成对的“key&#x2F;value”，也就是“键值&#x2F;实值”，内部元素依据其键值自动排序，map内部相同的键值只能出现一次，multimap则可以出现多次。 无序式容器（unordered container）： (1) unordered_map&#x2F;unordered_multimap：使用“哈希表”实现的，由于哈希表的特性，实现了真正的无序。如果不理解为什么使用“哈希表”就是真正无序的，可以去百度一下“哈希表”，或者干脆直接记住就可以了。 使用方法也是“key&#x2F;value”，和map&#x2F;multimap类似。 (2) unordered_set&#x2F;unorder_multiset：同样使用“哈希表”实现的。自然具有了哈希表实现的容器的特点。 使用方法和setl&#x2F;multiset类似。 关联式容器和无序式容器的对比： (1) 关联式容器都是有序的，对于那些对顺序有要求的操作，关联式容器效率会高很多。（比如增加元素，删除元素） (2) 无序容器都是真正的无序，在查找数据方面有着优势。（比如修改特定元素，查找元素） (3) 从内存消耗的角度讲，无序容器要高于关联容器不过这并不重要。 一句话来说，如果从这两类容器中选一个使用的话。如果是增加，删除元素比较频繁，就使用关联式容器。如果修改元素，查找元素比较平凡，就使用无序容器。 5. 我们在处理数据时应该选择什么容器呢？ (1) 在我们需要使用存储“key&#x2F;value”的容器时，只能使用map&#x2F;multimap&#x2F;unoredered_map&#x2F;unordered_multimap。如果增加删除频繁，就使用map&#x2F;multimap，修改，查找频繁，就使用unordered_map&#x2F;unoredered_multimap。 (2) 在处理普通元素： ① 当元素需要频繁插入删除时，选择顺序容器。 1) 如果在尾部插入删除，选择vector 2) 在头部，尾部插入删除，选择deque 3) 在中间插入，删除，选择list ② 当元素需要频繁查找时，选择.set&#x2F;multiset&#x2F;unorder_set&#x2F;unorder_multiset。 1) 频繁增加，删除时，选set 2) 频繁查找，修改时，选ordered_set 我们发现，对于普通元素，容器的选择不怎么容易判断。 其实在真正的大型项目中，要对各种容器进行测试的，普通练习一般选择vector或set就可以了。 IO库介绍 io就是input，output的简写，也就是输入输出功能。io功能的本质，数据在内存，磁盘，输入输出设备之间移动就是io功能。 io库组成部分： (1) C++定义了ios这个基类来定义输入输出的最基本操作，C++io库所有的类都继承自这个类即可。 (2) istream，ostream这两个类直接继承自ios类。 ① ostream类定义了从内存到输出设备（比如显示器）的功能，我们最常使用的cout就是ostream类的对象。 ② istream类定义了从输入设备比如键盘）到内存的功能，我们最常用的cin就是istream类的对象。 ③ iostream文件定义了ostream和istream类的对象，就是cout和cin。所以我们只要简单的引入iostream这个头文件，就可以方便的使用这两个对象 注意：这个输入，输入时相对于内存来说的，输入到内存，是istream。 (3) ifstream，ofstream类分别继承自istream类和ostream类。 ① ifstream定义了从磁盘到内存的功能。因为istream重载了“&lt;&lt;”运算符，所以ifstream对象也可以用“&lt;&lt;”运算符来将文件数据写入内存。除了“&#x3D;”的所有重载运算符都是可以被继承的。 ② ofstream定义了从内存到磁盘的功能。与ifstream同理，也可以用“&gt;&gt;”操作数据流。 ③ fstream文件引入了ifstream和ofstream，所以我们只要引入ftream这个头文件，就可以使用文件流功能了。 注意：这个输入输出同样是相对内存来说的。 内存与输入输出设备的数据流动，磁盘与内存的数据流动已经介绍完了。磁盘和输入输出设备直接无法直接交互，必须通过内存。 io库还为我们额外定义了字符串的输入输出类，因为对字符串的操作极为频繁，所以这个库还是很有意义的。 (4) istringstream，ostringstream分别继承自istream类和ostream类 ① istringstream定义了从指定字符串到特定内存的功能。与ifstream同理，也可以用“&lt;&lt;”运算符操作数据。 ② ostringstream定义了从特定内存到指定字符串的功能。可以用“&gt;&gt;”操作数据。 ③ sstream头文件就引入了istringstream和ostringstream，所以我们只要引入sstream这个头文集，就可以使用字符串与内存直接交互数据的功能。 注意事项1. io对象无法使用拷贝构造函数和赋值运算符 所以我们使用流对象无法使用值传递，一般使用引用进行传递。 2. Io对象的状态 (1) io操作是非常容易出现错误的操作，一些错误是可以修复的，另一部分则发生在系统更深处，已经超出了应用程序可以修正的范围。 比如我们使用cin向一个int类型的数中输入一个字符串，会使cin这个对象出现错误。 所以我们在使用io对象时都应该判断io对象的状态。 比如：while(cin &gt;&gt; val) **或if(cin &gt;&gt; val)**（不要只用这两个进行控制，最好搭配iostate来使用） (2) 我们需要知道流对象错误的原因，因为不同的错误需要不同的处理方法。 io库定义了iostate类型，可以完整的表示io对象当前的状态。在不同的平台中， iostate实现方法略有区别，在vs中直接用int来代表iostate类型，将不同的位置1 以表示不同的状态。可以与位操作符一起使用来一次检测或设置多个标志位。 可以用rdstat函数来获得io对象当前用iostat类型来表示的状态： (3) iostata类型有以下状态 ① badbit状态，系统级错误，一旦表示badbit的位被置为1，流对象就再也无法使用了。 ② failbit状态，代表可恢复错误，比如想读取一个数字却读取了一个字符，这种错误就是可以恢复的。当badbit位被置1时，failbit位也会被置1。 ③ eofbit状态，当到达文件结束位置时，eofbit和failbit位都会被置1。 ④ goodbit状态，表示流对象没有任何错误。 只要badbit，failbit，eofbit有一位被置为1，则检测流状态的条件就会失败。 (4) 标准库还定义了一组成员函数来查询这些标志位的状态 ① good()函数在所有错误位均未置1的情况下返回true。 ② bad()，fail()，eof()函数在对应位被置1的情况下返回true。因为badbit位被置1或eofbit位被置1时，failbit位也会被置为1。所以用fail()函数可以准确判断出流对象是否出现错误。 ③ 实际上，我们将流对象当做条件使用的代码就等价于“!fail()” (5) 流对象的管理 ① rdstate函数，返回一个iostate值，对应当前流状态 ② setstate(flag) 函数，将流对象设置为想要的状态 ③ clear函数：是一个重载的函数。 clear()，将所有位置0，也就是goodbit状态。 clear(flag)，将对应的条件状态标志位复位。 ④ ignore函数： 作用：提取输入字符并丢弃他们。 函数原型：istream&amp; ignore (streamsize n &#x3D; 1, int delim &#x3D; EOF) 读取到前n个字符或在读这n个字符进程中遇到delim字符就停止，把读取的这些东西丢掉 内存输入输出设备的交互（iostream）1. getline： 其实iostream已经没什么好讲的了，比较常用的就是这个getline了，getline其实并不复杂，不过是按行接收数据罢了，因为存储string对象中，所以不容易出现格式错误，但仍然可能出现系统错误，所以在企业级程序中，还是应当对bad的情况进行处理。 2. get: 还有个不怎么常用的get函数。get函数的用法和getline类似，只不过get是以字符的格式进行接收。在企业级代码中仍然需要对bad的情况进行处理。 内存与磁盘的交互（fstream） fstream相对于iostream。多了很多自己独有的操作 (1)io库默认没有给ifstream和ofstream类提供对象，需要我们自己去定义。 (2) fstream对象创建方式有三种 ① 可以使用默认构造函数进行定义。例如： ifstream fstrm， ② 也可以在创建流对象时打开想要打开的文件。例如ifstream fstrm(s)。s可以是字符串，也可以是c风格的字符串指针。文件的mode依赖于流对象的类型。 ③ 也可以在打开文件时就指定文件的mode。例如ifstream fstrm(s, mode) (3) fstrm.open(s)函数，打开名为s的文件，并将文件与fsrm绑定，s可以是一个string，也可以是一个c风格的字符串指针。 (4) fstrm.close()函数，关闭文件。注意，一定不要忘了。 (5) fstrm.is_open()函数，返回一个bool值，指出与fstrm关联的文件是否成功打开且尚未关闭。 文件模式： (1) in以读的方式打开 (2) out以写的方式打开 (3) app在进行写操作时定位到文件末尾 (4) ate打开文件后立即定位到文件末尾 (5) trunc截断文件（也就是文件已有的全部删除，重新开始写） (6) binary以二进制方式打开文件 文件模式需要强调以下几点 (1) 与ifstream关联的文件默认in模式打开。 (2) 与ofstream关联的文件默认out模式打开 (3) 与fstream关联的文件默认in和out模式打开 (4) 默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保持以out模式打开的文件的内容，我们必须同时指定app模式或in模式。 (5) 只可以对ifstream或fstream的对象设定in的模式 (6) 只可以对ofstream或fstream的对象设定out的模式 (7) 只有当out模式被设置时才可以设置trunc模式 (8) ate和binary模式可以应用与任何类型的文件流对象，且可以与任何其它文件模式组合使用。 内存之中对于字符串的操作（sstream） string流介绍：string流可以向string对象写入数据，也可以从string对象读取数据。与文件操作类似，只不过数据交互变成了从内存到内存。 string流有哪些 (1) istringstream从string对象读取数据 (2) ostringstream向string对象写数据 (3) stringstream既可以从string对象读取数据，也可以向string对象写数据 string流对象继承自iostream对象，除了继承得来的操作，string流对象还有自己的成员来管理流相关的string。 (1) 对于string流，io库是没有像cout，cin这样的自定流对象的。流对象需要我们自己去定义 ① sstream strm：sstream代表一个string流对象的类型，以下同理。strm是一个未绑定的stringstream对象。 ② Sstream strm(s)：strm是一个绑定了s的拷贝的string流对象。s是一个string对象 (2) strm.str()：返回strm所保存的string的拷贝。 (3) strm.str(s)：将s拷贝到strm中，返回void string流对象的作用 (1) 对数据类型进行转化，也就是string和其它类型的转化，这是string流对象最重要的功能。 ① string转化为int等类型。 ② int等类型转化为string。 (2) 用于对空格分隔的字符串的切分， 多线程1. 多线程基本概念介绍1. 多线程的重要性： (1) 对于一个专业的C++开发来说，多线程是必须掌握的模块。 (2) 现代程序都是多线程程序了。因为单核处理器的性能早已经达到了瓶颈，只能往多核方向发展。现代的个人计算机都是4核起步，工作站，服务器就更不用说了。 (3) 工作站可以理解为处理能力更强的大型个人计算机，常见的12核，16核。服务器有48核的，甚至更多。 (4) 对于一个计算机来说，是不是说核越多好呢？不是，多核会导致单核的工作性能下降。当核数多到一定程度后，反而总体运行效率下降了。不过，这并不影响现代计算机核数越来越多的趋势。 (5) 传统的单线程程序同时只能在一个核上运行，这是不是太浪费资源了。计算机有8个核，你就用了一个，暴殄天物啊。多线程程序可以使用多个核，极大提高程序运行效率。现在网络通信，音频，视频，游戏服务都是多线程程序。 2. 并发与并行的概念介绍： (1) 一句话来说：并行是同时在不同的处理器上处理不同的任务，并发是“同时”在一个处理器上处理多个任务。 解释一下： ① 并行是指有多个处理器。每个处理器各执行一个线程，互不抢占cpu资源，如果线程数量多于CPU，也没有办法，只能将处理器的时间划分为多个时间段，再将时间段分配给各个线程。 ② 并发是指只有一个处理器，但多个线程被轮换快速执行，使得宏观上有了同时执行的效果。作用原理是将单处理器的时间划分为多个时间段，再分配给不同的线程。同一时间段只能有一个线程在运行，其它线程均处于挂起状态。 3. 进程的概念： (1) 进程的概念在面向进程设计的操作系统（就是unix，也包括后面衍生出的linux，mac）和面向线程设计的操作系统（说的就是windows）上有很大区别，两种设计方式的共同点与不同点还是需要理解的。 ① 进程是计算机中的程序对某些数据集合的一次运行活动，是系统进行资源分配和调度的最基本单位，是操作系统的结构基础。再用大白话说一遍，一个可执行程序执行起来，就是一个进程。当然，一个程序要执行起来需要各种资源，这些资源就是数据集合。 ② 在面向进程设计的计算机结构中，进程是程序的基本执行单位，进程包括程序执行的所有资源，同时自己也可以执行。 ③ 在面向线程设计的计算机结构中，线程才是程序的基本执行单位，进程不过是线程的容器罢了。进程就像一个仓库，里面存放了程序的所有资源，进程中的线程才是真正执行程序的单元。 4. 线程的概念： (1) linux的线程和windows的线程还是有很大区别的。 (2) linux的线程就是一种轻量级的进程，只有依靠进程才可以存在。也模拟出了windows线程的方式，让线程成为真正的执行单元。 (3) windows的线程就简单多了，真正执行程序的最小单元。 2.线程的创建 主线程介绍：一个程序执行起来就是一个进程。而main函数就是主线程，一旦主线程执行完毕，主线程结束，整个进程就会结束。 子线程介绍：在一个线程执行时，我们可以创建出另外一个线程。两个线程各自执行，互补干涉。注意，当主线程执行完毕，就会强制结束所有子线程，然后进程结束，从这个角度来说，可以认为子线程是主线程的辅助线程。但是要明白主线程和子线程是平级的，只不过主线程执行完毕后会给所有子线程发送一个信号，使所有子线程强制结束。 子线程的创建方式：很简单，直接使用thread类就可以了。 子线程创建后如果就不管了，那么会出现非常严重的问题。 (1) 有些子线程负责对部分数据的处理，主线程必须要等到子线程处理完毕才能继续执行，所以join函数就诞生了。 使用了join函数后，主线程就会处于挂起状态，直到子线程执行完毕才可以继续执行。 (2) 有些子线程和主线程完全分离，各自执行各自的。但主线程执行完毕，子线程就会立马被强制结束，容易导致各种bug，查都不知道从哪里开始查。于是deatch函数就诞生了。 detach()函数可以让子线程被C++运行库接管，就算主线程执行完毕，子线程也会由C++运行时库清理相关资源。保证不会出现各种意想不到的bug。 3.传递线程参数(1) 传递子线程函数的参数：直接传递即可，注意：传递参数分为三种方式，值传递，引用传递，指针传递。 (2) 传递参数注意事项： ① 在使用detach时不要传递指针，或者说在设置子线程函数时，不要设置指针参数。因为值传递和引用传递并未直接传递地址，而指针传递却直接传递地址。所以当使用deatch时，传指针就会导致错误，指针已经被系统回收，所以不要千万不要传指针。 ② 在使用detach时不要使用隐式类型转化，因为很有可能子线程参数还没来的及将参数转化为自己的类型，主线程就已经执行完毕了。 (3) 总结： ① 普通类型在传递子线程函数参数时，直接值传递即可。 ② 类类型传递引用就可以了，类类型传递引用会首先调用一次复制构造函数生成一个临时变量，故而导致地址不相同。如果采用值传递，需要两次复制构造函数，开销更大。 (4) std::ref的用法： 使用普通的引用传递会调用一次复制构造函数，导致函数无法对引用对象进行修改，于是std::ref诞生了，它可以使子线程在传递参数时不再调用复制构造函数。 4.线程id的概念： 线程id定义：每个线程都有自己的id，不管是主线程还是子线程都有自己的id。直接使用std::this_thread::get_id()就可以获得当前线程的id。 注意：线程是依附于进程存在的，所以不同的进程可以有相同的线程id。 5. 数据共享与数据保护 多个线程的执行顺序是乱的，具体执行方法和处理器的调度机制有关系。从开发者的角度讲，就是没有规律的。 在讲数据保护问题之前，为了帮助大家理解数据保护问题，这里额外扩展一些关于汇编的知识。 一个进程运行时，数据存储在内存中。如果一个数据要进行运算，必须先将数据拷贝到寄存器中。比如要对栈上的一个int i进行“++”操作，需要将i的值拷贝到寄存器中，将该值自加后再拷贝到原来的内存。 如果此时有两个线程均进行的是这样的操作，可能出现两个进程都拷贝了i原来的值到寄存器，然后各种加一，再拷贝到i对应内存的情况，最终导致i这个变量只自加了一次。 这是同时写数据的情况，那么一读一写呢？这也是有问题的，谁知道读数据时写数据步骤已经到了哪里，谁知道读出来的是个什么东西。 数据保护问题： (1) 数据保护问题总共有三种情况： ① 至少两个线程对共享数据均进行读操作，完全不会出现数据安全问题。 ② 至少两个线程对共享数据均进行写操作，会出现数据安全问题，需要数据保护。 ③ 至少两个线程对共享数据有的进行读，有的进行写，也会出现数据安全问题，需要进行数据保护。 数据保护的方法一共就两种：互斥锁，原子操作。 4. 互斥锁： (1) 互斥锁的作用原理很简单，对共享数据加锁，当一个线程对这块数据进行操作时，别的线程就无法对该区域数据进行操作。 (2) 这种方式的互斥锁有个弊端，就是lock()之后容易忘记unlock()，就和指针类似。于是和智能指针类似，也有了lock_guard，用来防止开发人员忘了解锁。 原子操作：（使用频率远远不及互斥锁） (3) 原子操作的原理：将一个数据设置为原子状态，使得该数据处于无法被分割的状态，意思就是处理器在处理被设置为原子状态的数据时，其它处理器无法处理该段数据，该处理器也会保证在处理完该数据之前不会处理其他数据。 总结：在编写多线程代码时，数据保护是一个必须考虑，非常常用的功能。互斥锁的使用频率是远远高于原子操作，原子操作看似简单，但当需要保护的数据很多时，就会极其复杂。 所以：对于单个数据，可以使用原子操作，其它的使用互斥锁就可以了。 6. 死锁死锁就像两个人在互相等对方。A说，等B来了就去B现在所在的地方；B说，等A来了我就去A所在的地方，结果就是A和B都在等对面过来才能去对面。这就导致了一个死循环，放在多线程中，就是死锁。 举个例子： 解决方法也很简单。 只要让两个锁顺序一致就可以了。 但是让两个锁顺序一致常常是说起来容易，做起来难。于是C++11提供了std::lock。这个模板可以保证多个互斥锁绝对不会出现死锁的问题。同时提供了std::adopt_lock的功能来避免忘记释放锁的问题。 总结：死锁是一个比较常见的bug，面试时也经常询问死锁相关的知识。 异常处理异常处理的前情提要：很多人不喜欢使用异常处理，认为它麻烦，应对可能出现的错误要写那么多代码，会非常麻烦。 但实际上不是这样的，我们只需要在一些开发人员难以控制，比较容易出错的地方对异常进行处理就可以了，需要进行异常处理的地方并不多。 举几个例子。 接收传递过来的被除数，我们难以判断被除数是否为0，此时异常处理就很有意义了。 接收文件名，如果文件不存在，我们可以按照之前的写法要求重发一遍，也可以直接报异常，异常就是文件不存在。 我们在动态分配内存时，经常出现内存不足的情况（在大型程序中，这是非常常见）。比如我们需要动态分配一个未知大小的数组，数组大小等待传入。使用new操作符会直接抛出bad_alloc的异常。 对new的处理非常重要，大家如果做专业的C++开发，会经常用到。 此外使用智能指针时如果内存分配不够也会抛出bad_alloc的异常 有个vector，我们需要接受一个参数，然后取出参数对应的数组元素。此时就经常出现数组的越界问题。 1. 异常处理的介绍： 异常是程序在执行期间产生的问题（编译期出现的错误在写代码时开发环境就有提示）。C++的异常是指程序运行时发生的特殊情况。 异常提供了一种转移程序控制权的方式。C++的异常处理涉及到三个关键字：try，catch，throw。 (1) throw：当问题出现时，程序会抛出一个异常。这是通过throw关键字来完成的。 (2) catch：在你想要处理问题的地方，通过异常处理程序捕获异常。catch关键字用于捕获异常。 (3) try：try块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个catch块。 如果有一个块抛出一个异常，捕获异常的方法会使用try和catch关键字。try块中放可能抛出异常的代码，try块中的代码被称为保护代码。常见的异常处理格式如图所示。 抛出异常：throw语句可以在代码块的任何地方抛出异常，throw抛出的表达式的结果决定了抛出的异常的类型。 2. C++的标准异常 C++提供了一系列标准的异常，定义在头文件“”中，它们是以父子层次结构组织起来的，如下图所示。 别看图很复杂，异常种类有很多，但经常使用的其实就几个。 (1) bad_alloc错误，使用new分配内存失败就会抛出bad_alloc错误。 (2) out_of_range错误，在使用at时，容器越界就会抛出这个错误，这也是“at”比“[]”更加优秀的原因。 (3) runtime_error错误，运行时错误，只有在程序运行时才能检测到的错误。这是一个相对的概念，和logic_error形成对比。logic_error可以读代码读出来，runtime_error就不行。 我们也经常将一些读代码无法判断的异常标识为runtime_error。 (4) … 错误，可以接受任何错误，我们一般都会在catch最后加上“…”，这样就可以接受所有类型的异常了。 自定义异常类型，其实需要自定义异常类型的情况真的非常少，这里就不介绍了，其实和标准异常也是一样的。 各种难以归类但有使用价值的知识点1. 万能引用与引用折叠 万能引用的概念： (1) C++11除了带来了右值引用，还带来了万能引用，也就是既能当做左值，又能当做右值的引用。 注意：万能引用是既可以被编译期处理为左值引用，又可以被编译期处理为右值引用。不是既是左值引用又是右值引用，不违背C++一个引用不是左值引用，就是右值引用的基本说法，万能引用会在编译期被当做左值引用或右值引用处理。 万能引用的格式：万能引用的格式有两种 (1) 模板型： 123template&lt;typename T&gt;void func(T&amp;&amp; parm) 这个T&amp;&amp; 就是万能引用类型。 注意：只有T&amp;&amp; 是万能引用类型 以下的写法均不是万能引用： const T&amp;&amp; parm 这就是普通的右值引用。 vector &amp;&amp; parm 这也是右值引用。 12345template&lt;typename T&gt;class MyVector &#123;public: void push_back(T&amp;&amp; elem);｝ 注意：此时T&amp;&amp; 不是万能引用，因为T影响的是MyVector的类型。 只有这样写，才是万能引用。 123456template&lt;typename T&gt;class MyVector &#123;public: template&lt;typename T2&gt; void push_back(T2&amp;&amp; elem);｝ 此时T2&amp;&amp; 的类型完全独立于MyVector类了，每调用一次push_back函数，都要推断T2的类型。 (2) auto型： auto &amp;&amp; var &#x3D; var2； 这个auto&amp;&amp; 就是万能引用。 const auto&amp;&amp; var 就不是万能引用了。 万能引用的作用，就是当参数为左值时。T&amp;&amp;为左值。当参数为右值时，T&amp;&amp; 为右值。就这么简单。 引用折叠：引用折叠其实概念很简单 一个引用不是左值引用就是右值引用，当一个万能引用被认为左值引用时，类型应该是T&amp; &amp;&amp;，此时类型就会折叠为T&amp;。 简单来说，就是引用符号太多了，折叠为“&amp;”或“&amp;&amp;” 2. 完美转发 C++完美转发的定义：完美转发是什么呢？说到底，它描述的其实就是一个参数传递的过程，能够将一个传递到一个函数的参数，再通过该函数原封不动的传递给另一个函数（这里的原封不动不单是指参数的值，更包括参数的类型，参数的限定符） 我们发现以前的传递参数的方法都无法在万能引用中解决完美转发的问题。 于是C++提供了forward模板来解决完美转发的问题，forward模板可以使参数推断出它原来的类型，实现了完美转发。 4. 总结：完美转发就是一个专门配合万能引用的知识点，专门用来在使用万能引用的地方原封不动的传递参数。其实记住它是和万能引用配合使用的就掌握的差不多了，","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://blog.zymatrix.top/tags/C/"}]},{"title":"MyBatis学习笔记","slug":"MyBatis笔记","date":"2024-09-06T16:00:00.000Z","updated":"2024-09-17T12:04:19.415Z","comments":true,"path":"2024/09/07/MyBatis笔记/","link":"","permalink":"http://blog.zymatrix.top/2024/09/07/MyBatis%E7%AC%94%E8%AE%B0/","excerpt":"","text":"MyBatis MyBatis官网：mybatis – MyBatis 3 | 简介 1）创建spingboot工程 2）配置mybatis的相关依赖，以及数据库连接信息 3）配置数据库表user，以及实体类User 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.itheima.entity;public class User &#123; private Integer id; private String name; private Short age; private Short gender; public User() &#123; &#125; public User(Integer id, String name, Short age, Short gender, String phone) &#123; this.id = id; this.name = name; this.age = age; this.gender = gender; this.phone = phone; &#125; private String phone; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Short getAge() &#123; return age; &#125; public void setAge(Short age) &#123; this.age = age; &#125; public Short getGender() &#123; return gender; &#125; public void setGender(Short gender) &#123; this.gender = gender; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @java.lang.Override public java.lang.String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&quot; + gender + &quot;, phone=&#x27;&quot; + phone + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 4）配置mapper接口，UserMapper.java 1234567891011121314151617package com.itheima.mapper;import com.itheima.entity.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;// @Mapper注解，声明这是一个Mapper接口，在运行时会动态生成该接口的实现类对象（代理对象），并且将该对象交给Spring容器管理@Mapperpublic interface UserMapper &#123; // 查询全部用户信息 @Select(&quot;select * from user&quot;) public List&lt;User&gt; list();&#125; 5）spring单元测试，SpringbootMybatisQuickstartApplicationTests.java 12345678910111213141516171819202122232425262728package com.itheima;import com.itheima.entity.User;import com.itheima.mapper.UserMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;// @SpringBootTest注解，用于SpringBoot整合单元测试的注解@SpringBootTestclass SpringbootMybatisQuickstartApplicationTests &#123; // @Autowired注解，自动注入UserMapper接口的代理对象 @Autowired private UserMapper userMapper; @Test public void testListUser()&#123; // 调用代理对象的方法，执行SQL语句 List&lt;User&gt; userList = userMapper.list(); // 遍历输出查询结果 userList.stream().forEach(user -&gt; &#123; System.out.println(user); &#125;); &#125;&#125;","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.zymatrix.top/tags/Java/"},{"name":"后端","slug":"后端","permalink":"http://blog.zymatrix.top/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Java后端学习笔记","slug":"Java后端开发","date":"2024-09-06T16:00:00.000Z","updated":"2024-09-17T12:05:27.507Z","comments":true,"path":"2024/09/07/Java后端开发/","link":"","permalink":"http://blog.zymatrix.top/2024/09/07/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/","excerpt":"","text":"Web前端AjaxAjax(Asynchronous JavaScript and XML),用来给服务器发送请求，并获取服务器响应的数据，可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，例如：搜索联想、用户名是否可用的校验，也就是异步交互技术。 原生Ajax: 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div id=&quot;demo&quot;&gt; &lt;h2&gt;让 AJAX 更改这段文本&lt;/h2&gt; &lt;button type=&quot;button&quot; onclick=&quot;loadDoc()&quot;&gt;更改文本&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112Function loadDoc()function loadDoc() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(&quot;demo&quot;).innerHTML = this.responseText; &#125; &#125;; xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, true); xhttp.send();&#125; Axios:对原生Ajax封装，简化书写 前端工程化可以利用YApi生成api文档 Element组件库，利用这个组件库来实现前端页面美化 nginx部署前端页面 Springboot请求响应123456789101112131415@RestController@SpringBootApplicationpublic class MyApplication &#123; @RequestMapping(&quot;/home&quot;) String home(String name, Integer age) &#123; System.out.println(name + &quot; : &quot; + age); return &quot;OK&quot;; &#125; public static void main(String[] args) &#123; SpringApplication.run(MyApplication.class, args); &#125;&#125; @RestController 和 @RequestMapping 注解 MyApplication 类上的第一个注解是 @RestController 。 这被称为 stereotype 注解。 它为阅读代码的人和Spring提供了提示，说明这个类扮演了一个特定的角色。 在本例中，我们的类是一个web @Controller ，所以Spring考虑使用它来处理客户端的web请求。 @RequestMapping 注解提供了 “routing” （路由）信息。 它告诉Spring，任何带有 / 路径的HTTP请求都应该被映射到 home 方法。 @RestController 注解告诉 Spring将返回的结果字符串直接响应给客户端。 Springboot中， 简单参数：参数名和形参变量名相同，定义形参即可接收参数,如果形参名称和请求参数名称不匹配，可以使用@RequestParam完成映射 实体参数：通过对象封装参数，请求参数名与形参对象属性名相同，即可直接通过POJO接收 还有数组参数、日期参数、json参数、路径参数等，可以通过查阅文档来了解 响应：@ResponseBody，可以将实体对象&#x2F;集合转变为JSON格式响应 Result(code, msg, data)类来统一响应结果 分层解耦三层架构controller：控制层，接收前端发送到请求，对请求进行处理，并响应数据。 service：业务逻辑层，处理具体的业务逻辑。 dao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查 分层解耦内聚：软件中各个功能模块内部的功能联系。 耦合：衡量软件中各个层&#x2F;模块之间的依赖、关联程度。 控制反转：Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。 依赖注入：Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称为依赖注入。 Bean对象：IOC容器中创建、管理的对象，称之为bean。 IOC &amp; DI入门步骤： Service层及Dao层的实现类，交给IOC容器管理。（在这两个层的每个类中加入@Component注释） 为Controller及Service注入运行时，依赖的对象。（在这两个层中加入@Autowired注释） IOC详解bean的声明 bean组件声明 DI详解@Autowired注解，默认是按照类型进行，如果存在多个相同类型的bean，将会报错。 解决方法： @Primary @Qualifier+@Autowired @Resource 增删改查 新建实体类在pojo下，使用注解实现实体类的构造 1234567891011121314151617181920212223242526272829/** * 部门实体类,Dept */@Data@NoArgsConstructor@AllArgsConstructorpublic class Dept &#123; private Integer id; //ID private String name; //部门名称 private LocalDateTime createTime; //创建时间 private LocalDateTime updateTime; //修改时间&#125;//Emp@Data@NoArgsConstructor@AllArgsConstructorpublic class Emp &#123; private Integer id; //ID private String username; //用户名 private String password; //密码 private String name; //姓名 private Short gender; //性别 , 1 男, 2 女 private String image; //图像url private Short job; //职位 , 1 班主任 , 2 讲师 , 3 学工主管 , 4 教研主管 , 5 咨询师 private LocalDate entrydate; //入职日期 private Integer deptId; //部门ID private LocalDateTime createTime; //创建时间 private LocalDateTime updateTime; //修改时间&#125; 新建Controller包，这里编写的是Controller层，用于实现和前端的交互 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// DeptController@Slf4j@RequestMapping(&quot;/depts&quot;)@RestControllerpublic class DeptController &#123; @Autowired private DeptService deptService; @GetMapping public Result list() &#123; log.info(&quot;查询全部部门数据&quot;); List&lt;Dept&gt; deptList = deptService.list(); return Result.success(deptList); &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public Result delete(@PathVariable Integer id) &#123; log.info(&quot;删除指定id数据:&#123;&#125;&quot;, id); deptService.delete(id); return Result.success(); &#125; @PostMapping public Result add(@RequestBody Dept dept) &#123; log.info(&quot;增加数据:&#123;&#125;&quot;,dept); deptService.add(dept); return Result.success(); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public Result get(@PathVariable Integer id) &#123; log.info(&quot;通过id:&#123;&#125;查询数据&quot;, id); Dept dept = deptService.getById(id); return Result.success(dept); &#125; @PutMapping public Result update(@RequestBody Dept dept) &#123; log.info(&quot;修改数据:&#123;&#125;&quot;, dept); deptService.update(dept); return Result.success(); &#125;&#125;//EmpController@Slf4j@RestController@RequestMapping(&quot;/emps&quot;)public class EmpController &#123; @Autowired private EmpService empService; @GetMapping public Result page(@RequestParam(defaultValue = &quot;1&quot;) Integer page, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize, String name, Short gender, @DateTimeFormat(pattern = &quot;yyyy-mm-dd&quot;) LocalDate begin, @DateTimeFormat(pattern = &quot;yyyy-mm-dd&quot;) LocalDate end) &#123; log.info(&quot;分页查询:&#123;&#125;,&#123;&#125;, &#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;, page, pageSize, name, gender, begin, end); PageBean pageBean = empService.page(page, pageSize, name, gender, begin, end); return Result.success(pageBean); &#125; @DeleteMapping(&quot;/&#123;ids&#125;&quot;) public Result delete(@PathVariable List&lt;Integer&gt; ids) &#123; log.info(&quot;删除数据:&#123;&#125;&quot;, ids); empService.delete(ids); return Result.success(); &#125; @PostMapping public Result save(@RequestBody Emp emp) &#123; log.info(&quot;新增数据:&#123;&#125;&quot;, emp); empService.save(emp); return Result.success(); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public Result getById(@PathVariable Integer id) &#123; log.info(&quot;通过id查询数据:&#123;&#125;&quot;, id); Emp emp = empService.getById(id); return Result.success(emp); &#125; @PutMapping public Result update(@RequestBody Emp emp) &#123; log.info(&quot;修改数据:&#123;&#125;&quot;, emp); empService.update(emp); return Result.success(); &#125;&#125; 新建Service包，其中有Service接口和实现类，负责处理业务逻辑和协调不同的组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Serviceclass DeptServiceImpl implements DeptService &#123; @Autowired private DeptMapper deptMapper; @Override public List&lt;Dept&gt; list() &#123; return deptMapper.list(); &#125; @Override public void delete(Integer id) &#123; deptMapper.deleteById(id); &#125; @Override public void add(Dept dept) &#123; dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.insert(dept); &#125; @Override public void update(Dept dept) &#123; dept.setUpdateTime(LocalDateTime.now()); deptMapper.update(dept); &#125; @Override public Dept getById(Integer id) &#123; return deptMapper.getById(id); &#125;&#125;@Servicepublic class EmpServiceImpl implements EmpService &#123; @Autowired private EmpMapper empMapper; @Override public PageBean page(Integer page, Integer pageSize, String name, Short gender, LocalDate begin, LocalDate end) &#123; PageHelper.startPage(page, pageSize); List&lt;Emp&gt; empList = empMapper.list(name, gender, begin, end); Page&lt;Emp&gt; p = (Page&lt;Emp&gt;) empList; return new PageBean(p.getTotal(), p.getResult()); &#125; @Override public void delete(List&lt;Integer&gt; ids) &#123; empMapper.delete(ids); &#125; @Override public void save(Emp emp) &#123; emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); empMapper.save(emp); &#125; @Override public Emp getById(Integer id) &#123; return empMapper.getById(id); &#125; @Override public void update(Emp emp) &#123; emp.setUpdateTime(LocalDateTime.now()); empMapper.update(emp); &#125;&#125; 新建Mapper包，用于操作数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Mapperpublic interface DeptMapper &#123; @Select(&quot;select * from dept&quot;) List&lt;Dept&gt; list(); @Delete(&quot;delete from dept where id = #&#123;id&#125;&quot;) void deleteById(Integer id); @Insert(&quot;insert into dept(name, create_time, update_time) values(#&#123;name&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;) void insert(Dept dept); @Select(&quot;select * from dept where id = #&#123;id&#125;&quot;) Dept getById(Integer id); @Update(&quot;update dept set name = #&#123;name&#125;,update_time = #&#123;updateTime&#125; where id = #&#123;id&#125;&quot;) void update(Dept dept);&#125;@Mapperpublic interface EmpMapper &#123;// @Select(&quot;select count(*) from emp&quot;)// public Long count();//// /**// * 分页查询// * @param start// * @param pageSize// * @return// */// @Select(&quot;select * from emp limit #&#123;start&#125;, #&#123;pageSize&#125;&quot;)// public List&lt;Emp&gt; page(Integer start, Integer pageSize);// @Select(&quot;select * from emp&quot;) public List&lt;Emp&gt; list(String name, Short gender, LocalDate begin, LocalDate end); void delete(List&lt;Integer&gt; ids); @Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) &quot; + &quot;values (#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;,#&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;) void save(Emp emp); @Select(&quot;select * from emp where id=#&#123;id&#125;&quot;) Emp getById(Integer id); void update(Emp emp);&#125; 在resources文件夹下新建依赖文件夹和同名xml文件，用来帮助mapper层实现动态sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;mapper namespace=&quot;com.springboot.tlias.mapper.EmpMapper&quot; &gt; &lt;select id=&quot;list&quot; resultType=&quot;com.springboot.tlias.pojo.Emp&quot;&gt; select * from emp &lt;where&gt; &lt;if test=&quot;name != null and name != &#x27;&#x27; &quot;&gt; name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt; and gender = #&#123;gender&#125; &lt;/if&gt; &lt;if test=&quot;begin != null and end != null&quot;&gt; and entrydate between #&#123;begin&#125; and #&#123;end&#125; &lt;/if&gt; &lt;/where&gt; order by update_time desc &lt;/select&gt; &lt;delete id=&quot;delete&quot;&gt; delete from emp where id in &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;update id=&quot;update&quot;&gt; update emp &lt;set&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; username = #&#123;username&#125;, &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; password = #&#123;password&#125;, &lt;/if&gt; &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt; gender = #&#123;gender&#125;, &lt;/if&gt; &lt;if test=&quot;image != null and image != &#x27;&#x27;&quot;&gt; image = #&#123;image&#125;, &lt;/if&gt; &lt;if test=&quot;job != null&quot;&gt; job = #&#123;job&#125;, &lt;/if&gt; &lt;if test=&quot;entrydate != null&quot;&gt; entrydate = #&#123;entrydate&#125;, &lt;/if&gt; &lt;if test=&quot;deptId != null&quot;&gt; dept_id = #&#123;deptId&#125;, &lt;/if&gt; &lt;if test=&quot;updateTime != null&quot;&gt; update_time = #&#123;updateTime&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 分页查询开发中，为了方便用户查看页面，经常会需要实现分页查询。在前端页面上展示大量数据时，通过分页展示可以提高页面的加载速度，优化用户体验。 使用原有的springboot框架代码来实现会比较繁琐，效率也低，因此可以使用类似PageHelp插件的分页查询工具来帮助实现。 一般来说，需要先封装一个PageBean对象，方便数据操作。 PageBean对象通常包含以下属性： currentPage：当前页码。 pageSize：每页显示的数据条数。 totalCount：总记录数。 totalPage：总页数。 dataList：当前页码的数据列表。 利用分页插件的改善： 修改操作对于一个数据的修改，需要先实现对应id的数据的查询(getById)，然后才能进行修改 配置文件使用aliyun时设置工具类的相关参数，直接硬编码对于管理项目不方便，相反，应该使用配置文件来进行修改 但是以上在更大的项目中非常不便，因此又引入了ConfigurationProperties注解 登录功能基础登录登录其实就是在数据库当中查询username&amp;password，如果存在，则登录成功，不存在就失败 12345678910111213141516171819@Slf4j@RestControllerpublic class LoginController &#123; @Autowired private EmpService empService; @PostMapping(&quot;/login&quot;) public Result login(@RequestBody Emp emp) &#123; log.info(&quot;登录:&#123;&#125;&quot;, emp); Emp e = empService.login(emp); return e != null ? Result.success():Result.error(&quot;用户名或密码错误&quot;); &#125;&#125; @Override public Emp login(Emp emp) &#123; return empMapper.getByUsnAndPwd(emp); &#125; @Select(&quot;select * from emp where username=#&#123;username&#125; and password=#&#123;password&#125;&quot;) Emp getByUsnAndPwd(Emp emp); 登录校验对用户状态进行校验，如果未登录则跳转到登录界面进行登录 http协议是无状态的，无法判断用户是否登录，这时就需要一个登录标记来进行记录。 对于用户的每个操作，都需要先判断是否登录，因此可以使用统一拦截技术 会话技术 JWT令牌 123456789101112131415@PostMapping(&quot;/login&quot;)public Result login(@RequestBody Emp emp) &#123; log.info(&quot;登录:&#123;&#125;&quot;, emp); Emp e = empService.login(emp); if (e != null) &#123; Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(&quot;id&quot;, e.getId()); claims.put(&quot;name&quot;, e.getName()); claims.put(&quot;username&quot;, e.getUsername()); String jwt = JwtUtils.generateJwt(claims); return Result.success(jwt); &#125; return Result.error(&quot;用户名或密码错误&quot;);&#125; 过滤器和拦截器 过滤器链 注解配置的Filter，优先级是按照过滤器类名字符串的自然排序 12345678910111213141516171819202122232425262728293031323334353637383940414243@Slf4j@WebFilter(urlPatterns = &quot;/*&quot;)public class LoginCheckFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; String url = request.getRequestURL().toString(); log.info(&quot;请求的url:&#123;&#125;&quot;, url); if (url.contains(&quot;login&quot;))&#123; log.info(&quot;登录操作，放行&quot;); filterChain.doFilter(servletRequest, servletResponse); return; &#125; String jwt = request.getHeader(&quot;token&quot;); if (StringUtil.isNullOrEmpty(jwt)) &#123; log.info(&quot;请求头token为空&quot;); Result error = Result.error(&quot;NOT_LOGIN&quot;); String notLogin = JSONObject.toJSON(error).toString(); log.info(&quot;notLogin:&#123;&#125;&quot;, notLogin); response.getWriter().write(notLogin); return; &#125; try &#123; JwtUtils.parseJWT(jwt); &#125; catch (Exception e) &#123; e.printStackTrace(); log.info(&quot;解析jwt失败&quot;); Result error = Result.error(&quot;NOT_LOGIN&quot;); String notLogin = JSONObject.toJSON(error).toString(); response.getWriter().write(notLogin); return; &#125; log.info(&quot;令牌合法，放行&quot;); filterChain.doFilter(servletRequest,servletResponse); &#125;&#125; 拦截器 拦截器需要在preHandle方法中对登录进行拦截，其逻辑与Filter类似，代码如下： 1234567891011121314151617181920212223242526272829303132333435@Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String url = request.getRequestURL().toString(); log.info(&quot;请求的url:&#123;&#125;&quot;, url); if (url.contains(&quot;login&quot;))&#123; log.info(&quot;登录操作，放行&quot;); return true; &#125; String jwt = request.getHeader(&quot;token&quot;); if (StringUtil.isNullOrEmpty(jwt)) &#123; log.info(&quot;请求头token为空&quot;); Result error = Result.error(&quot;NOT_LOGIN&quot;); String notLogin = JSONObject.toJSON(error).toString(); log.info(&quot;notLogin:&#123;&#125;&quot;, notLogin); response.getWriter().write(notLogin); return false; &#125; try &#123; JwtUtils.parseJWT(jwt); &#125; catch (Exception e) &#123; e.printStackTrace(); log.info(&quot;解析jwt失败&quot;); Result error = Result.error(&quot;NOT_LOGIN&quot;); String notLogin = JSONObject.toJSON(error).toString(); response.getWriter().write(notLogin); return false; &#125; log.info(&quot;令牌合法，放行&quot;); return true; &#125; 异常处理在之前的开发过程中，没有对异常的处理，出现错误只会返回springboot底层的异常信息，这并不符合开发规范，因此需要引入异常和错误处理。开发中常常使用的是全局异常处理器。 事务管理&amp;AOP事务管理在一次业务操作内部，可能有多个步骤，例如，在删除部门时，不仅要删除部门数据，还要删除部门下的员工数据，在两个步骤之间可能出现异常导致整个操作未完全成功，造成了数据不一致。示例如下： 删除部门数据后被中断，删除部门下员工数据的操作失败。这时候就需要进行事务操作。 事务传播行为：当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制 AOPAOP:Aspect Oriented Programming（面向切面编程，面向方面编程） 在SpringBoot中要运用AOP就需要先引入AOP依赖，使用@Aspect注解实现切面类 annotation可以自定义注解方便实现匹配特定方法 代码示例：用以记录增删改的相关接口日志， 需要记录操作的方法加上@Log即可 123456789101112131415161718192021222324252627282930313233343536@Slf4j@Component@Aspectpublic class LogAspect &#123; @Autowired OperateLogMapper operateLogMapper; @Autowired HttpServletRequest httpServletRequest; @Around(&quot;@annotation(com.springboot.tlias.anno.Log)&quot;) public Object recordLog(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; String jwt = httpServletRequest.getHeader(&quot;token&quot;); Claims claims = JwtUtils.parseJWT(jwt); Integer operateUser = (Integer) claims.get(&quot;id&quot;); LocalDateTime operateTime = LocalDateTime.now(); String className = proceedingJoinPoint.getTarget().getClass().getName(); String methodName = proceedingJoinPoint.getSignature().getName(); Object[] args = proceedingJoinPoint.getArgs(); String methodParams = Arrays.toString(args); Long begin = System.currentTimeMillis(); Object result = proceedingJoinPoint.proceed(); Long end = System.currentTimeMillis(); String returnValue = JSONObject.toJSONString(result); Long costTime = end - begin; OperateLog operateLog = new OperateLog(null, operateUser, operateTime, className, methodName, methodParams, returnValue, costTime); operateLogMapper.insert(operateLog); log.info(&quot;记录日志：&#123;&#125;&quot;, operateLog); return result; &#125;&#125; SpringBoot原理配置的优先级配置文件的优先级是properties &gt; yml &gt; yaml Bean 这三种方法，在默认条件下，同时使用时获取到的Bean对象都指向同一个地址，这与bean的作用域有关 bean的作用域，可以通过@Scope注解来定义 原理要在springboot启动时将第三方的依赖Bean注入到ioc容器中，需要先配置","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.zymatrix.top/tags/Java/"},{"name":"后端","slug":"后端","permalink":"http://blog.zymatrix.top/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"MySQL学习笔记","slug":"MySQL笔记","date":"2024-09-06T16:00:00.000Z","updated":"2024-09-17T12:04:07.012Z","comments":true,"path":"2024/09/07/MySQL笔记/","link":"","permalink":"http://blog.zymatrix.top/2024/09/07/MySQL%E7%AC%94%E8%AE%B0/","excerpt":"","text":"MySQL DDL（数据定义语言）数据定义语言 数据库操作查询所有数据库：SHOW DATABASES;查询当前数据库：SELECT DATABASE();创建数据库：CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];删除数据库：DROP DATABASE [ IF EXISTS ] 数据库名;使用数据库：USE 数据库名; 注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 表操作查询当前数据库所有表：SHOW TABLES;查询表结构：DESC 表名;查询指定表的建表语句：SHOW CREATE TABLE 表名; 添加字段：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];例：ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;; 修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];例：将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;; 删除字段：ALTER TABLE 表名 DROP 字段名; 修改表名：ALTER TABLE 表名 RENAME TO 新表名 删除表：DROP TABLE [IF EXISTS] 表名;删除表，并重新创建该表：TRUNCATE TABLE 表名; DML（数据操作语言）添加数据指定字段：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);全部字段：INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 更新和删除数据修改数据：UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];例：UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1; 删除数据：DELETE FROM 表名 [ WHERE 条件 ]; DQL（数据查询语言）基础查询查询多个字段：SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名; 设置别名：SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录：SELECT DISTINCT 字段列表 FROM 表名; 转义：SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;&#x2F; 之后的_不作为通配符 条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表; 聚合查询（聚合函数）语法：SELECT 聚合函数(字段列表) FROM 表名;例：SELECT count(id) from employee where workaddress = &quot;广东省&quot;; 分组查询语法：SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 注意事项 执行顺序：where &gt; 聚合函数 &gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 排序查询语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 注意事项 起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 DQL执行顺序FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT DCL管理用户查询用户： 12USE mysql;SELECT * FROM user; 创建用户:CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;; 修改用户密码：ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;; 删除用户：DROP USER &#39;用户名&#39;@&#39;主机名&#39;; 注意事项 主机名可以使用 % 通配 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库&#x2F;表&#x2F;视图 CREATE 创建数据库&#x2F;表 更多权限请看权限一览表 查询权限：SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;; 授予权限：GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;; 撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;; 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 函数 字符串函数 数值函数 日期函数 流程函数 字符串函数常用函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 REPLACE(column, source, replace) 替换字符串 使用示例： 1234567891011121314-- 拼接SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);-- 小写SELECT LOWER(&#x27;Hello&#x27;);-- 大写SELECT UPPER(&#x27;Hello&#x27;);-- 左填充SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- 右填充SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- 去除空格SELECT TRIM(&#x27; Hello World &#x27;);-- 切片（起始索引为1）SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5); 数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x&#x2F;y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子： 12-- DATE_ADDSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR); 流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子： 12345678select name, (case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)from employee;select name, (case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;from employee; 约束分类： 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。 常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子： 1234567create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age &gt; 0 and age &lt; 120), status char(1) default &#x27;1&#x27;, gender char(1)); 外键约束添加外键： 123456789CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id); 删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 删除&#x2F;更新行为 行为 说明 NO ACTION 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致） RESTRICT 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致） CASCADE 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录 SET NULL 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除&#x2F;更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为; 多表查询多表关系 一对多（多对一） 多对多 一对一 一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键 多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） 查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id; 内连接查询内连接查询的是两张表交集的部分 隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; 显式性能比隐式高 例子： 12345-- 查询员工姓名，及关联的部门的名称-- 隐式select e.name, d.name from employee as e, dept as d where e.dept = d.id;-- 显式select e.name, d.name from employee as e inner join dept as d on e.dept = d.id; 外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据 右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...; 例子： 12345-- 左select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样-- 右select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id; 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept 自连接查询当前表与自身的连接查询，自连接必须使用表别名 语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; 自连接查询，可以是内连接查询，也可以是外连接查询 例子： 1234-- 查询员工及其所属领导的名字select a.name, b.name from employee a, employee b where a.manager = b.id;-- 没有领导的也查询出来select a.name, b.name from employee a left join employee b on a.manager = b.id; 联合查询 union, union all把多次查询的结果合并，形成一个新的查询集 语法： 123SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ... 注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D; 例子： 123456789-- 查询销售部所有员工select id from dept where name = &#x27;销售部&#x27;;-- 根据销售部部门ID，查询员工信息select * from employee where dept = 4;-- 合并（子查询）select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);-- 查询xxx入职之后的员工信息select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;); 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： 123456-- 查询销售部和市场部的所有员工信息select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);-- 查询比财务部所有人工资都高的员工信息select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));-- 查询比研发部任意一人工资高的员工信息select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;)); 行子查询返回的结果是一行（可以是多列）。常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN 例子： 123-- 查询与xxx的薪资及直属领导相同的员工信息select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;); 表子查询返回的结果是多行多列常用操作符：IN 例子： 1234-- 查询与xxx1，xxx2的职位和薪资相同的员工select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);-- 查询入职日期是2006-01-01之后的员工，及其部门信息select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id; 事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 基本操作： 1234567891011121314151617181920212223-- 1. 查询张三账户余额select * from account where name = &#x27;张三&#x27;;-- 2. 将张三账户余额-1000update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 此语句出错后张三钱减少但是李四钱没有增加模拟sql语句错误-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#x27;李四&#x27;;-- 查看事务提交方式SELECT @@AUTOCOMMIT;-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效SET @@AUTOCOMMIT = 0;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;-- 设置手动提交后上面代码改为：select * from account where name = &#x27;张三&#x27;;update account set money = money - 1000 where name = &#x27;张三&#x27;;update account set money = money + 1000 where name = &#x27;李四&#x27;;commit; 操作方式二： 开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK; 操作实例： 12345start transaction;select * from account where name = &#x27;张三&#x27;;update account set money = money - 1000 where name = &#x27;张三&#x27;;update account set money = money + 1000 where name = &#x27;李四&#x27;;commit; 四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd 并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效 索引索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。 优缺点： 优点： 提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 缺点： 索引列也是要占用空间的 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 B+Tree 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引 语法创建索引：CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引 查看索引：SHOW INDEX FROM table_name; 删除索引：DROP INDEX index_name ON table_name; 案例： 1234567891011-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引create index idx_user_name on tb_user(name);-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引create unique index idx_user_phone on tb_user (phone);-- 为profession, age, status创建联合索引create index idx_user_pro_age_stat on tb_user(profession, age, status);-- 为email建立合适的索引来提升查询效率create index idx_user_email on tb_user(email);-- 删除索引drop index idx_user_email on tb_user; 使用规则最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like &#39;%工程&#39;;，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引：explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;不使用哪个索引：explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;必须使用哪个索引：explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 覆盖索引&amp;回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义：using index condition：查找使用了索引，但是需要回表查询数据using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name=&#39;xxx&#39;;，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name=&#39;xxx&#39;; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id, username, password from tb_user where username=&#39;itcast&#39;; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n));前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。求选择性公式： 12select count(distinct email) / count(*) from tb_user;select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 单列索引&amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况：explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;这句只会用到phone索引字段 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://blog.zymatrix.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"后端","slug":"后端","permalink":"http://blog.zymatrix.top/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"JavaSE","slug":"JavaSE","date":"2024-08-11T16:00:00.000Z","updated":"2024-08-16T03:34:56.845Z","comments":true,"path":"2024/08/12/JavaSE/","link":"","permalink":"http://blog.zymatrix.top/2024/08/12/JavaSE/","excerpt":"","text":"JavaSE日志日志能够方便程序员定位程序Bug，并且日志的开关很方便。 Logback利用Maven管理Logback下载，并且将logback.xml文件放入src路径下 关于Logback的使用，可以参考文档和教程 以下是一个简单示例： 123456789101112131415161718192021222324import org.sl4j.Logger;import org.sl4j.LoggerFactory; public class LogbackTest &#123; public static final logger LOGGER = LoggerFactory.getlogger(&quot;LogbackTest&quot;); public static void main(String[] args)&#123; try &#123; LOGGER.info(&quot;Division logging starts&quot;); divide(10, 0); LOGGER.info(&quot;Division succeeds&quot;); &#125; catch(Exception e) &#123; LOGGER.error(&quot;Division fails&quot;); &#125; &#125; public static void divide(int a, int b)&#123; LOGGER.debug(&quot;a&quot;: + a); LOGGER.debug(&quot;b&quot;: + b); int c = a / b; LOGGER.info(&quot;result:&quot; + c); &#125;&#125; 日志级别 只有日志的级别大于或等于核心配置文件（logback.xml）配置的日志级别，才会被记录，否则不记录。 多线程多线程的创建注意，不要把主线程任务放在启动子线程之前，并且使用start方法启动线程 继承Thread类：重写run方法。缺点是无法继承其他类，不利于功能扩展。 实现Runnable接口：重写run方法，这里实现的是一个任务对象，因此需要将任务对象使用new Thread(p)来创建线程。由于Runnable是一个函数式接口，因此可以利用Lamada简化实现。 实现Callable接口：前两个方法都是void方法，没有返回结果。重写call方法，将Callable的对象封装成FutureTask（实现了Runable）。将线程任务对象交给Thread对象。线程执行完毕后，通过FutureTask对象的get方法获取线程任务执行的结果，这里会等待任务执行完毕保证一定能获取到结果。 线程同步 同步代码块，同步方法，都是用synchronized，对于同步代码块，应当传入this参数确保加锁的是同一个对象，如果是静态方法，应该传入Object.class字节码。 Lock，注意要在finally当中确保解锁 线程通信当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以相互协调，并避免无效的资源争夺 生产者消费者模型 线程池一个可以复用线程的技术 核心线程数量配置： 计算密集型： CPU核数 + 1 IO密集型： CPU核数 * 2 ThreadPoolExecutor创建线程池 12345public class ThreadPoolTest &#123; public static void main(String[] args) &#123; ExecutorService pool = new ThreadPoolExecutor(3, 5, 8, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); &#125;&#125; 参数解析： 1public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize: 核心线程数量 这是线程池中始终保持活跃的线程数量。即使它们处于空闲状态，也不会被终止。 maximumPoolSize: 最大线程数量 这是线程池中允许的最大线程数量。如果任务数量超过了核心线程数量，并且工作队列已经填满，线程池会创建临时线程来处理任务。 keepAliveTime: 临时线程空闲存活时间 这是当线程池中的线程数量超过核心线程数量时，多余的线程在终止前可以保持空闲状态的最长时间。如果超过这个时间，多余的线程将被终止。 TimeUnit: 存活时间单位 这是keepAliveTime参数的时间单位，例如秒、分钟、小时等。 BlockingQueue&lt;Runnable&gt;: 工作队列 这是一个阻塞队列，用于存储等待执行的任务。当所有核心线程都在忙碌时，新任务会被放入这个队列中等待。 ThreadFactory: 线程工厂 这个参数允许你创建自定义的线程实例，可以用来设置线程的名称、优先级等属性。 RejectedExecutionHandler: 拒绝执行处理器 当任务太多，无法被线程池接受时，这个处理器会被调用。它定义了任务被拒绝时的处理策略，例如丢弃任务、抛出异常等。 线程池处理Runnable任务 12345678910111213141516171819202122232425public class ThreadPoolTest &#123; public static void main(String[] args) &#123; ExecutorService pool = new ThreadPoolExecutor( 3, 5, 8, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy() ); Runnable target = new MyRunnable(); pool.execute(target); pool.execute(target); pool.execute(target); //加入工作队列 pool.execute(target); pool.execute(target); pool.execute(target); pool.execute(target); //临时线程 pool.execute(target); pool.execute(target); // 由解决方案来决定下面的线程的后续 pool.execute(target); pool.shutdown(); //等到所有线程任务结束后退出程序 &#125;&#125; 处理Callable任务 1234567891011121314151617181920public class ThreadPoolTest1 &#123; public static void main(String[] args) throws Exception &#123; ExecutorService pool = new ThreadPoolExecutor( 3, 5, 8, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy() ); Future&lt;String&gt; f1 = pool.submit(new MyCallable(100)); Future&lt;String&gt; f2 = pool.submit(new MyCallable(200)); Future&lt;String&gt; f3 = pool.submit(new MyCallable(300)); Future&lt;String&gt; f4 = pool.submit(new MyCallable(400)); System.out.println(f1.get()); System.out.println(f2.get()); System.out.println(f3.get()); System.out.println(f4.get()); pool.shutdown(); &#125;&#125; Executors工具类实现线程池 1234static ExecutorService newCachedThreadPool()static ExecutorService newFixedThreadPool(int nThreads)static ExecutorService newSingleThreadExecutor()static ScheduledExecutorService newSingleThreadScheduledExecutor() 大型并发系统使用Executors可能的风险 线程池不允许使用 Executors去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式可以更加明确线程池的运行规则，规避资源耗尽的风险。说明:Executors返回的线程池对象的弊端如下: FixedThreadPool和singleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 00M。 CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致00M。 线程的生命周期Java为线程定义了6种状态，在Thread.State枚举类中： A thread state. A thread can be in one of the following states: NEWA thread that has not yet started is in this state. RUNNABLEA thread executing in the Java virtual machine is in this state. BLOCKEDA thread that is blocked waiting for a monitor lock is in this state. WAITINGA thread that is waiting indefinitely for another thread to perform a particular action is in this state. TIMED_WAITINGA thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state. TERMINATEDA thread that has exited is in this state 网络通信InetAddress UDP DatagramSocket:用于创建客户端、服务端 TCP: Socket类和ServerSocket类 如下是一个简易群聊，在本地创建客户端和服务端，利用服务端进行端口转发，接收来自客户端的消息并转发至其他客户端 12345678910111213141516171819202122//Server.javapackage tcp;import java.net.ServerSocket;import java.net.Socket;import java.util.ArrayList;import java.util.List;public class Server &#123; public static List&lt;Socket&gt; onlinesockets = new ArrayList&lt;&gt;(); public static void main(String[] args) throws Exception &#123; ServerSocket serversocket = new ServerSocket(6666); System.out.println(&quot;------Server is running------&quot;); while (true) &#123; Socket socket = serversocket.accept(); onlinesockets.add(socket); System.out.println(socket.getRemoteSocketAddress() + &quot; is online&quot;); new ServerReadThread(socket).start(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132// Client.javapackage tcp;import java.io.DataOutputStream;import java.io.OutputStream;import java.net.Socket;import java.util.Scanner;public class Client &#123; public static void main(String[] args) throws Exception &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;, 6666); new ClientReadThread(socket).start(); OutputStream os = socket.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); Scanner sc = new Scanner(System.in); while (true) &#123; System.out.println(&quot;Please enter：&quot;); String msg = sc.nextLine(); if (&quot;exit&quot;.equals(msg)) &#123; dos.close(); socket.close(); break; &#125; dos.writeUTF(msg); dos.flush(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//ServerReadThreadpackage tcp;import java.io.*;import java.net.Socket;public class ServerReadThread extends Thread&#123; private Socket socket; public ServerReadThread(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; InputStream is = socket.getInputStream(); DataInputStream dis = new DataInputStream(is); while (true) &#123; try &#123; String msg = dis.readUTF(); msg = socket.getRemoteSocketAddress() + &quot;:&quot; + msg; System.out.println(msg); sendMsgToAll(msg); &#125; catch (Exception e) &#123; System.out.println(&quot;the client &quot;+socket.getRemoteSocketAddress() + &quot; is closed&quot;); Server.onlinesockets.remove(socket); dis.close(); socket.close(); break; &#125; &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; // 发送消息至除自己外的所有客户端 private void sendMsgToAll(String msg) throws IOException &#123; for (Socket onlinesocket : Server.onlinesockets) &#123; if (onlinesocket.equals(socket)) &#123; continue; &#125; OutputStream os = onlinesocket.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); dos.writeUTF(msg); dos.flush(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536//ClientReadThreadpackage tcp;import java.io.DataInputStream;import java.io.InputStream;import java.net.Socket;//接收服务端分发的消息public class ClientReadThread extends Thread&#123; private Socket socket; public ClientReadThread(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; InputStream is = socket.getInputStream(); DataInputStream dis = new DataInputStream(is); while (true) &#123; try &#123; String msg = dis.readUTF(); System.out.println(msg); &#125; catch (Exception e) &#123; System.out.println(&quot;the client &quot;+socket.getRemoteSocketAddress() + &quot; itself is closed&quot;); dis.close(); socket.close(); break; &#125; &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 可以将上面的Server代码修改一下，变为BS架构的服务端，并且利用线程池来实现高并发 Java高级junit 测试junit 是一种用于Java开发的测试框架。 @Test注解,public void测试方法 断言机制，Assert.assertEquals() 反射 便于理解框架和源码 RTTI（Run-Time Type Identification）运行时类型识别，在运行时识别一个对象的类型和类的信息 获取Class对象、Constructor对象、成员变量(Field)和方法(Method) 并且使用 破坏封装性 Class类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。 注解使用Class类解析出对象含有的注解，利用条件语句选择执行，从而实现类junit框架的简易测试。","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://blog.zymatrix.top/tags/JavaSE/"}]},{"title":"DRF开发","slug":"DRF开发笔记","date":"2024-04-24T16:00:00.000Z","updated":"2024-09-17T12:04:34.459Z","comments":true,"path":"2024/04/25/DRF开发笔记/","link":"","permalink":"http://blog.zymatrix.top/2024/04/25/DRF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"DRF开发笔记在项目目录下的__init__.py文件中需要加入 123import pymysqlpymysql.install_as_MySQLdb() 来使用mysql views.py实现视图函数本文件下实现的是增删改查功能，也就是get post put delete 123456789# Viewset实现from rest_framework.viewsets import ReadOnlyModelViewSet,ModelViewSetclass BookViewSet(ReadOnlyModelViewSet): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer class BookViewSet(ModelViewSet): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer 12345678910111213141516171819202122232425262728293031323334353637383940414243# APIViewclass BookListAPIView(APIView): def get(self, request): books = BookInfo.objects.all() serializer = BookInfoSerializer(books, many=True) return Response(serializer.data) def post(self, request): serializer = BookInfoSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) # GenericAPIView + Mixin 实现接口class BookInfoView(GenericAPIView, CreateModelMixin, ListModelMixin): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer def get(self, request): return self.list(request) def post(self, request): return self.create(request)class BookInfoDetailView(GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer def get(self, request, pk): return self.retrieve(request, pk) def put(self, request, pk): return self.update(request, pk) def delete(self, request, pk): return self.destroy(request, pk) # GenericAPIView + Mixin 实现合成from rest_framework.generics import ListCreateAPIView, RetrieveUpdateDestroyAPIViewclass BookInfoView(ListCreateAPIView): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializerclass BookInfoDetailView(RetrieveUpdateDestroyAPIView): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer 自定义行为123456from rest_framework.decotators import action@action(method=[&#x27;get&#x27;], detail=False) # 使用这个装饰器才能在路由中加入本方法def latest(self, request): book = BookInfo.objects.latest(&#x27;id&#x27;) serializer = self.get_serializer(book) return Response(serializer.data) 重定向：1return redirect(reverse(&#x27;users:index&#x27;)) Cookie：12345def cookie(request): response = HttpResponse(&#x27;ok&#x27;) response.set_cookie(&#x27;name&#x27;, &#x27;zz&#x27;) response.delete_cookie(&#x27;name&#x27;) return response Session:123def session(request): request.session[&#x27;name&#x27;] = &#x27;zz&#x27; # 设置session return HttpResponse(&#x27;session&#x27;) 装饰器123456@method_decorator(decorator, name=&#x27;get&#x27;)# 装饰get方法，如果是dispatch装饰所有方法class DemoView(ModelViewSet): # 指定查询集 queryset = BookInfo.objects.all() serializer = BookInfoSerializer 12345serializer = BookInfoSerializer(data=data)serializer.is_valid(raise_exception=True) # 验证数据是否合法serializer.errors() # 返回验证错误信息serializer.validated_data() # 返回验证后的数据serializer.save() # 保存数据 models.py定义各类模型 1234567891011121314class BookInfo(models.Model): btitle = models.CharField(max_length=20, verbose_name=&#x27;名称&#x27;) bpub_date = models.DateField(verbose_name=&#x27;发布日期&#x27;, null=True) bread = models.IntegerField(default=0, verbose_name=&#x27;阅读量&#x27;) bcomment = models.IntegerField(default=0, verbose_name=&#x27;评论量&#x27;) is_delete = models.BooleanField(default=False, verbose_name=&#x27;逻辑删除&#x27;) class Meta: db_table = &#x27;bookinfo&#x27; verbose_name = &#x27;图书&#x27; verbose_name_plural = verbose_name def __str__(self): return self.btitle 数据库迁移 python manage.py makemigrations serializers.py1234567891011class BookInfoModelSerializer(serializers.ModelSerializer): class Meta: model = BookInfo # 指定映射字段 fields = &#x27;__all__&#x27; &quot;&quot;&quot;BookInfoSerializer(instance, data)传参给instance表示序列化,传给data表示反序列化serializer = BookInfoSerializer(instace = book)serializer.data 获取到序列化后的数据&quot;&quot;&quot; 12345678910111213141516171819202122# 上下等价class BookInfoSerializer(serializers.Serializer): id = serializers.IntegerField(label=&#x27;ID&#x27;,read_only=True) btitle = serializers.CharField(max_length=20, label=&#x27;名称&#x27;) bpub_date = serializers.DateField(label=&#x27;发布日期&#x27;) bread = serializers.IntegerField(label=&#x27;阅读量&#x27;) bcomment = serializers.IntegerField(label=&#x27;评论量&#x27;) is_delete = serializers.BooleanField(label=&#x27;逻辑删除&#x27;, required=False) image = serializers.ImageField(label=&#x27;图片&#x27;, required=False) hero = serializers.PrimaryKeyRelatedField(read_only=True) # 仅用于序列化输出 def validate_btitle(self, value): if &#x27;django&#x27; not in value: raise serializers.ValidationError(&#x27;图书不是关于Django的&#x27;) return value def validate(self, attrs): bread = attrs[&#x27;bread&#x27;] bcomment = attrs[&#x27;bcomment&#x27;] if bread &lt; bcomment: raise serializers.ValidationError(&#x27;阅读量小于评论量&#x27;) return attrs urls.py整个项目： 123456urlpatterns = [ path(r&#x27;^admin/&#x27;, admin.site.urls), path(&#x27;api-auth/&#x27;,include(&#x27;rest_framework.urls&#x27;)), path(r&#x27;^users/&#x27;, include(&#x27;users.urls&#x27;, namespace=&#x27;users&#x27;)), # 把users子应用的所有路由添加到根路由中，添加命名空间，为反向解析添加限制 url(r&#x27;^&#x27;, include(&#x27;books.urls&#x27;))] 每个app： 定义当前子应用下的所有路由 1234567891011# users app Django# 正则，视图函数名urlpatterns = [ path(r&#x27;^index/(?P&lt;city&gt;[a-z]+)/(?P&lt;year&gt;\\d&#123;4&#125;)/$&#x27;,views.index, name=&#x27;&#x27;), # 别名 # 类视图 path(r&#x27;^index/$&#x27;, views.Index.as_view())]# 定义路由后的&#x27;/&#x27; 要加上# ^：这个字符在正则表达式中表示字符串的开始。使用^确保URL模式匹配从URL的开始处进行。# $：这个字符在正则表达式中表示字符串的结束。使用$确保URL模式匹配到URL的末尾处。# 利用括号给正则分组，并利用?P&lt;&gt;为正则指定参数 1234# drf 只能在视图集时使用router = DefaultRouter()router.register(r&#x27;books&#x27;, views.BookInfoView)urlpatterns += router.urls # 拼接生成的路由 12345678# 当使用Viewset时,后续替换用上面的urlpatterns = [ path(r&#x27;^book/(?P&lt;pk&gt;\\d+)/$&#x27;,views.BookViewset.as_view(&#123;&#x27;get&#x27;:&#x27;retrieve&#x27;, &#x27;put&#x27;:&#x27;update&#x27;,&#x27;delete&#x27;:&#x27;destroy&#x27;&#125;), name=&#x27;&#x27;), # 别名 # 类视图 path(r&#x27;^book/$&#x27;, views.BookViewset.as_view(&#123;&#x27;get&#x27;:&#x27;list&#x27;, &#x27;post&#x27;:&#x27;create&#x27;&#125;)) url(r&#x27;^book/latest/$&#x27;, views.BookViewset.as_view(&#123;&#x27;get&#x27;:&#x27;latest&#x27;&#125;)) url(r&#x27;^book/(?P&lt;pk&gt;\\d+)/read/$&#x27;, views.BookViewset.as_view(&#123;&#x27;put&#x27;:&#x27;read&#x27;&#125;))] apps.pysettings.py123456789101112INSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;rest_framework&#x27;, &#x27;user.apps.UserConfig&#x27;, # 注册子应用] 1ALLOWED_HOSTS = [] # 允许访问的域名 123456DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;zq_new_notify&#x27;, &#125;&#125; 12345# 配置静态文件加载存储目录# 静态文件简单使用，一般不用STATICFILES_DIR = [ os.path.join(BASE_DIR, &#x27;static_files&#x27;)] 123456789101112# redis配置CACHES = &#123; &#x27;default&#x27;: &#123; &#x27;BACKEND&#x27;: &#x27;django_redis.cache.RedisCache&#x27;, &#x27;LOCATION&#x27;:&#x27;redis://127.0.0.1:6379/1&#x27;, &#x27;OPTIONS&#x27;: &#123; &#x27;CLIENT_CLASS&#x27;:&#x27;django_redis.client.DefaultClient&#x27;, &#125;, &#125;&#125;SESSION_ENGINE = &#x27;django.contrib.sessions.backends.cache&#x27;SESSION_CACHE_ALIAS = &#x27;default&#x27;","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.zymatrix.top/tags/Python/"},{"name":"后端","slug":"后端","permalink":"http://blog.zymatrix.top/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"并发Bugs","slug":"JYYOS并发bugs","date":"2024-04-08T16:00:00.000Z","updated":"2024-08-12T09:20:11.007Z","comments":true,"path":"2024/04/09/JYYOS并发bugs/","link":"","permalink":"http://blog.zymatrix.top/2024/04/09/JYYOS%E5%B9%B6%E5%8F%91bugs/","excerpt":"","text":"并发Bug笔记内容来自蒋炎岩老师的OS课程以及slides 死锁AA-Deadlockunlock之前出现中断，然后lock()，此时会出现spin ABBA-Deadlock（最常见） T-&gt;lock(A)-&gt;lock(B) T-&gt;lock(B)-&gt;lock(A) 当一个线程lock AB后才能执行，但如果T1lock(A),T2lock(B)，此时无法满足条件，死锁 如何避免死锁 Lock ordering 任意时刻系统中的锁都是有限的 给所有锁编号 (Lock Ordering) 严格按照从小到大的顺序获得锁 Proof (sketch) 任意时刻，总有一个线程获得 “编号最大” 的锁 这个线程总是可以继续运行 数据竞争(Data Race)不同的线程同时访问同一内存，且至少有一个是写 例子： Case 1: 上错了锁 12345678910void T_1() &#123; spin_lock(&amp;A); sum++; spin_unlock(&amp;A); &#125; void T_2() &#123; spin_lock(&amp;B); sum++; spin_unlock(&amp;B); &#125; Case 2: 忘记上锁 12345678void T_1() &#123; spin_lock(&amp;A); sum++; spin_unlock(&amp;A); &#125; void T_2() &#123; sum++; &#125; 原子性&#x2F;顺序违反“ABA”: 代码被别人 “强势插入” 即便分别上锁 (消除数据竞争)，依然是 AV Diablo I 里复制物品的例子 Therac-25 中 “移动 Mirror + 设置状态” “BA”: 事件未按预定的顺序发生 例子：concurrent use-after-free GhostRace (USENIX Sec’24) 应对并发Bugs死锁我们可以在运行时检查一切明确的 Specification！ 严格按照编号执行 运行时lockorder的检查(lockdep) ThreadSanitizer: 运行时的数据竞争检查 应对死局: Sanitizers现代复杂软件系统必备的支撑工具 AddressSanitizer(asan);(paper): 非法内存访问 Buffer (heap&#x2F;stack&#x2F;global) overflow, use-after-free, use-after-return, double-free, …; 没有 KASAN, Linux Kernel 的质量&#x2F;安全性直接崩盘 ThreadSanitizer (tsan): 数据竞争 KCSAN: Concurrency bugs should fear the big bad data-race detector MemorySanitizer (msan), UBSanitizer (ubsan), … SpecSanitizer: 基于 AI&#x2F;LLM 的 “specification 检查” 就等你来开发了 应对死线：防御性编程Full Sanitizer 很难实现 不如换一种思路 我们可以 “编程”！ Best-effort is better than no-effort! 不实现 “完整” 的检查 (允许存在误报&#x2F;漏报) 但实现简单、非常有用——而且有惊喜 我们不是一直都在写 assertions 吗？ Peterson 算法：assert(nest == 1); 链表：assert(u-&gt;prev-&gt;next == u); spinlock: if (holding(&amp;lk)) panic(); Buffer Overrun检查 Canary: “牺牲” 内存单元，预警 memory error 例如：Stack Guard（栈溢出），缓冲区溢出 低配版Lockdep高配版 lockdep 太复杂？ 统计当前的 spin count 如果超过某个明显不正常的数值 (100,000,000) 就报告 你感觉到 “hang” 了 1234567int spin_cnt = 0;while (xchg(&amp;lk, ❌) == ❌) &#123; if (spin_cnt++ &gt; SPIN_LIMIT) &#123; panic(&quot;Spin limit exceeded @ %s:%d\\n&quot;, __FILE__, __LINE__); &#125;&#125; 配合调试器和线程 backtrace 一秒诊断死锁 低配版AddressSanitizerL1 内存分配器的 specification 已分配内存 S&#x3D;[ℓ0,r0)∪[ℓ1,r1)∪…S&#x3D;[ℓ0,r0)∪[ℓ1,r1)∪… kalloc(s) 返回的 [ℓ,r)[ℓ,r) 必须满足 [ℓ,r)∩S&#x3D;∅[ℓ,r)∩S&#x3D;∅ 1234567891011// allocationfor (int i = 0; (i + 1) * sizeof(u32) &lt;= size; i++) &#123; panic_on(((u32 *)ptr)[i] == MAGIC, &quot;double-allocation&quot;); arr[i] = MAGIC;&#125;// freefor (int i = 0; (i + 1) * sizeof(u32) &lt;= alloc_size(ptr); i++) &#123; panic_on(((u32 *)ptr)[i] == 0, &quot;double-free&quot;); arr[i] = 0;&#125; 低配版ThreadSanitizer直接观测状态影响 12345678910// Suppose x is lock-protected...int observe1 = x;delay();int observe2 = x;assert(observe1 == observe2);... Effective data-race detection for the Kernel (OSDI’10) SemanticSanitizer两个看似平常的检查 检查整数是否在某个范围 12345#define CHECK_INT(x, cond) \\ (&#123; panic_on(!((x) cond), \\ &quot;int check fail: &quot; \\ #x &quot; &quot; #cond); \\ &#125;) 检查指针是否位于堆区 123#define CHECK_HEAP(ptr) \\ (&#123; panic_on(!IN_RANGE((ptr), heap)); &#125;)","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://blog.zymatrix.top/tags/OS/"}]},{"title":"The Problems of Using OpenEuler WSL","slug":"The Problems of Using OpenEuler WSL","date":"2024-03-08T16:00:00.000Z","updated":"2024-08-12T09:20:23.533Z","comments":true,"path":"2024/03/09/The Problems of Using OpenEuler WSL/","link":"","permalink":"http://blog.zymatrix.top/2024/03/09/The%20Problems%20of%20Using%20OpenEuler%20WSL/","excerpt":"","text":"The Problems of Using OpenEuler WSL记录一下在OS课上使用OpenEuler WSL遇到的坑 OpenEuler 官方下载WSL系统的脚本十分炸裂，能在x86架构的机器上安装MIPS架构的结果，建议避雷，使用微软商店的软件包下载 本次实验的要求： 1.向OpenEuler系统，或者OpenKylin系统中，增加一个系统调用&#x2F;或内核模块，鼓励程序逻辑的多样化2.撰写一个应用测试程序调用该系统调用&#x2F;测试该内核模块3.使用trace&#x2F;ptrace&#x2F;strace,或类似的系统跟踪工具来对该测试程序进行跟踪调试 内核问题问题描述实验环境是在WSL2下使用OpenEuler，CentOS套壳 借鉴了一些网络上的代码后，对源码进行编译，下面是Makefile文件内容 123456789obj-m:=syscall.oPWD:= $(shell pwd)KERNELDIR:= /lib/modules/$(shell uname -r)/buildEXTRA_CFLAGS= -O0all: make -C $(KERNELDIR) M=$(PWD) modulesclean: make -C $(KERNELDIR) M=$(PWD) clean make后报错： &#x2F;lib&#x2F;modules&#x2F;5.15.146.1-microsoft-standard-WSL2&#x2F;build: No such file or directory. 搜索后可知，WSL2的内核是修改过的，无法使用CentOS上游的内核头文件和modules文件，因此，我们需要手动编译并安装一个版本。 解决步骤下载对应版本内核代码首先查看系统内核版本 1uname -r 5.15.146.1-microsoft-standard-WSL2 到WSL git仓库，找到对应的release 1git clone https://github.com/microsoft/WSL2-Linux-Kernel 编译和安装123cd WSL2-Linux-KernelLOCALVERSION= make KCONFIG_CONFIG=Microsoft/config-wsl -j8sudo LOCALVERSION= make KCONFIG_CONFIG=Microsoft/config-wsl modules_install -j8 这个阶段会遇到较多报错，由于我使用的是CentOS和网络上大多资料使用的Ubuntu不同，因此需要安装的依赖也不一样，这里就直接放出一部分报错和安装的全部命令 fatal error: openssl&#x2F;bio.h: No such file or directoryfatal error: libelf.h: No such file or directoryBTF: .tmp_vmlinux.btf: pahole (pahole) is not available Failed to generate BTF for vmlinuxTry to disable CONFIG_DEBUG_INFO_BTFWarning: ‘make modules_install’ requires depmod. Please install it. 1sudo dnf install bison flex openssl-devel elfutils-libelf-devel dwarves kmod 安装完这些以后，再重新运行上面的指令，这个时候就能发现没有问题了。 insmod问题问题描述当编译成功后，需要加载内核模块 1sudo insmod randomizer.ko 这个时候终端抛出问题： ERROR: could not insert module mymodule.ko: Invalid parameters 但是一番搜索后发现根本没有解决我的问题的方法，这时候查看日志 1dmesg | tail 可以发现出现了这样的错误： BPF:[xxxxx] Invalid name_offset:xxxxxx failed to validate module [mymodule] BTF: -22 在一篇博客中有这样的记录： “rocky linux 9上面，内核编译设置默认打开了DEBUG_INFO_BTF_MODULES，这样所有模块里面都带有BTF信息。 运行时内核的BTF这个机制，如果模块缺少BTF信息（ELF的BTF段）那可以加载成功，但如果BTF的版本不匹配就拒绝加载。 使用源码自己编译内核时，虽然内核源码是一样的但生成的BTF还是不匹配的。 这样自己使用内核源码目录（ 不是系统的&#x2F;lib&#x2F;modules&#x2F;uname -r&#x2F;build ） 编译一个模块出来， 在rocky linux的官方内核系统里面就没法使用了， modprobe 会返回“ bpf invalid name btf -22”错误。 但通常编译模块时，如果make bzImage 之后make clean 删掉vmlinux 后 编译模块时找不到vmlinux就不会BTF信息，通常还是可以正常使用的。 但有的模块使用了 register_btf_kfunc_id_set 函数 向系统注册BTF函数的，这种一定要求BTF 信息的就不行了。 反正这个BTF这个东西，自己编译第三方模块时最好就不要把BTF编译进去了，不然不同的内核小版本都没法兼容，即使同样的内核源码也是不行的。” 可以看到其实是BTF的问题，联系到上面出现的一个报错： BTF: .tmp_vmlinux.btf: pahole (pahole) is not available Failed to generate BTF for vmlinuxTry to disable CONFIG_DEBUG_INFO_BTFWarning: ‘make modules_install’ requires depmod. Please install it. 我们就要在这上面下文章，一开始，我们借助下载dwarves解决了这个报错 而在这里，我们就需要去disable CONFIG_DEBUG_INFO_BTF 因此引出一种可行办法，也就是： make menuconfig 配置内核，生成.config文件 然后在.config文件中修改 CONFIG_DEBUG_INFO_BTF&#x3D;n 但是由于一些奇怪的原因，我无法使用 make menuconfig，于是，我借助了另一种思路 删掉vmlinux 后 编译模块时找不到vmlinux就不会BTF信息 实际上是阴差阳错地，我在WSL2-Linux-Kernel目录下执行make clean，清除了所有*.o文件，然后make重新编译了一次，这时候神奇的事情发生了，尽管我仍然没有.config文件，但是当我使用命令 1sudo insmod randomizer.ko 并没有任何报错出现，这时候再用 1dmesg | tail 查看内核日志和分配给模块的主设备号时 BPF:[xxxxx] Invalid name_offset:xxxxxx failed to validate module [mymodule] BTF: -22 module has been loaded: xxx BTF的问题没有消失，但是我们绕开了 接着创建设备文件 1sudo mknod /dev/mymodule c xxx 0 运行测试程序就可以发现成功了。 参考资料： WSL 运行make提示&#x2F;lib&#x2F;modules&#x2F;xxx&#x2F;build: No such file or directory. Stop.错误解决办法 Btf版本不匹配导致内核模块加载失败的问题 kernel 源码升级","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://blog.zymatrix.top/tags/OS/"},{"name":"Linux Kernel","slug":"Linux-Kernel","permalink":"http://blog.zymatrix.top/tags/Linux-Kernel/"}]},{"title":"2023年小记","slug":"2023","date":"2023-12-31T16:00:00.000Z","updated":"2024-08-12T09:18:51.088Z","comments":true,"path":"2024/01/01/2023/","link":"","permalink":"http://blog.zymatrix.top/2024/01/01/2023/","excerpt":"","text":"新年伊始，日历的数字又换了一代，满大街都是人，狂欢显得他们对帝国的危机没有表现出任何兴奋或是担忧的情绪，仿佛日历变化或是口头言语就能把古旧的社会简单化新，时间在他们那里是不连续的。 “每天早上，当我在阴暗的天空下再次醒来时，我都会觉得对我来说是新年。”——葛兰西","categories":[],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"WEB Security","slug":"web","date":"2023-08-10T16:00:00.000Z","updated":"2024-08-12T09:20:32.430Z","comments":true,"path":"2023/08/11/web/","link":"","permalink":"http://blog.zymatrix.top/2023/08/11/web/","excerpt":"","text":"[toc] 0x00 信息整理来源博客sunny_忧郁小猫猫 - 博客园 (cnblogs.com) 0x01 基础知识 Request请求数据包数据格式 请求行：请求类型&#x2F;请求资源路径、协议的版本和类型 请求头：一些键值对，浏览器与web服务器之间都可以发送，特定的某种含义 空行：请求头与请求体之间用一个空行隔开； 请求体：要发送的数据(一般post提交会使用)；例：user&#x3D;123&amp;pass&#x3D;123 #请求行 请求行由三个标记组成：请求方法、请求URL和HTTP版本，它们用空格分享。 例如：GET /index.html HTTP/1.1 HTTP 规划定义了8种可能的请求方法： GET：检索URL中标识资源的一个简单请求 HEAD：与GET方法相同，服务器只返回状态行和头标，并不返回请求文档 POST：服务器接受被写入客户端输出流中的数据的请求 PUT：服务器保存请求数据作为指定URL新内容的请求 DELETE：服务器删除URL中命令的资源的请求 OPTIONS：关于服务器支持的请求方法信息的请求 TRACE：web服务器反馈Http请求和其头标的请求 CONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理 123456789101112131415161718192021222324252627- ``` #请求头 由关键字/值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。 HOST: 主机或域名地址 Accept：指浏览器或其他客户可以接爱的MIME文件格式。Servlet可以根据它判断并返回适当的文件格式。 User-Agent：是客户浏览器名称 Host：对应网址URL中的Web名称和端口号。 Accept-Langeuage：指出浏览器可以接受的语言种类，如en或en-us，指英语。 connection：用来告诉服务器是否可以维持固定的HTTP连接。http是无连接的，HTTP/1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接 Cookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。 Referer：表明产生请求的网页URL。如比从网页/icconcept/index.jsp中点击一个链接到网页/icwork/search，在向服务器发送的GET/icwork/search中的请求中，Referer是http://hostname:8080/icconcept/index.jsp。这个属性可以用来跟踪Web请求是从什么网站来的。 Content-Type：用来表名request的内容类型。可以用HttpServletRequest的getContentType()方法取得。 Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1. Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式。 #空行 最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。 12345- ``` #请求数据 使用POST传送，最常使用的是 Content-Type 和 Content-Length 头标。 Response请求数据包数据格式 一个响应由四个部分组成；状态行、响应头标、空行、响应数据。 1.状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔 2.响应头标：包含服务器类型、日期、长度、内容类型等 3.空行：响应头与响应体之间用空行隔开 4.响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面 HTTP响应码： 1xx：信息，请求收到，继续处理 2xx：成功，行为被成功地接受、理解和采纳 3xx：重定向，为了完成请求，必须进一步执行的动作 4xx：客户端错误 5xx：服务器错误 200 存在文件 403 存在文件夹 3xx 均可能存在 404 不存在文件及文件夹 500 均可能存在 #响应头标 像请求头标一样，它们指出服务器的功能，标识出响应数据的细节。 #空行 最后一个响应头标之后是一个空行，发送回车符和退行，表明服务器以下不再有头标。 #响应数据 HTML文档和图像等，也就是HTML本身。 0x02 BurpSuite使用使用大全 BurpSuite使用大全（详解）_Alphabets26的博客-CSDN博客 mozhe CTF题目解析 改变Referer实现来源页伪造 使用burpsuite实现多次伪造ip（暴力破解）：首先查找php获取ip地址的方式，也就是 X-Forwarded-For，然后在数据包里面加上这行命令，对ip进行右键send to intruder，在右侧能看到add变量的选项，将attack type 修改为cluster bomb，然后将payloads的payload type修改为numbers，设置范围，再发送数据包，start attack，然后等待，即可。 改变User-Agent实现伪造浏览器信息 浏览器中发送数据包的方式GET和POST的区别：GET与POST的区别？ - 简书 (jianshu.com) 由于GET能发送的数据大小有限制，长度不足，所以会出现”Request-URL Too Long”的情况，这个时候可以利用burpsuite来修改GET为POST传输数据 0x03 搭建安全拓展笔记第3天：基础入门-搭建安全拓展 web中间件漏洞Web中间件常见漏洞总结 | lyxhh (lxhsec.com) 基于中间件的靶场vulhub Vulhub靶场搭建教程 - Zovt - 博客园 (cnblogs.com) 0x04 WEB 源码拓展第4天：基础入门-WEB源码拓展 5. 语言与框架 — Web安全学习笔记 1.0 文档 源码获取：搜索、淘宝咸鱼、第三方源码站（例如菜鸟源码） 0x05 系统及数据库判断服务器操作系统Nmap参考指南(Man Page) https://www.cnblogs.com/php09/p/10530057.html","categories":[{"name":"hacker","slug":"hacker","permalink":"http://blog.zymatrix.top/categories/hacker/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.zymatrix.top/tags/CTF/"}]},{"title":"汇编语言","slug":"汇编语言","date":"2023-06-17T16:00:00.000Z","updated":"2024-09-07T06:24:51.439Z","comments":true,"path":"2023/06/18/汇编语言/","link":"","permalink":"http://blog.zymatrix.top/2023/06/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"","text":"一、mul,div,and,or ,shl,shr,inc,dec指令，中断int 1234mul:8位乘法结果默认放在AX中，16位乘法，结果高位默认放在DX，低位在AXdiv:除数为8位，则AL存商，AH存余数；除数为16位，AX存商，DX存余数xchg op1,op2 ;交换op1和op2的值lea reg,mem(Label) 将变量名或标号的偏移地址送给reg 12345and:在二进制下一位位对比，两位皆为1则结果也为1，其他的皆为0or:二进制下，有一个1就为1，其他的都是0and和or运算常常用于ASCII码大小写转换and al,11011111B 转化为大写字母or al,00100000B 转换为小写字母 1234都是对无符号数的逻辑移位。算术移位是对有符号数的移位，算数移位时要把最前面的符号数不变shl al,1 表示左移一位，相当于乘以2shr al,1 表示右移一位，相当于除以2nop:占位符，占据一个字节 1int 0 引发内中断，相当于跳转调用0号中断处理程序 12inc si si++dec si si-- 总线地址总线：宽度为N根，寻址能力就为2^N bit 数据总线：8086数据总线宽度为16根，一次传输1byte(2 bit)（16位） 二、寄存器1.ds寄存器，段地址、偏移地址、物理地址 物理地址 &#x3D; 段地址左移一位 + 偏移地址 DS（Data Segment) 通常用来存储段地址 段前缀：用于显式地指出内存单元的段地址的”ds:””cs:””ss:””es:”，一般来说默认为ds 注意，赋值给DS不能直接用数字赋值，而应该先赋值给AX，再赋值给DS 2.CS-IP代码段寄存器，jmp,jcxz指令 CS（code segment代码段寄存器）表示的是段地址，IP（指令指针寄存器，Instruction Pointer）表示的是偏移地址，在debug时可以用r命令来修改CS：IP的值，来修改内存中的值。在计算机中，代码和数据是一样的。 jmp 1000:3 表示跳转到地址为1000:3的地方，即修改了CS:IP，jmp bx表示讲IP的值修改为bx，CS的值不变。 jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，其功能相当于 1if(cx == 0) jmp short 标号 3.SS-SP寄存器，栈的push,pop指令 push和pop 栈的基本操作，SS(stack segment),SP(stack point) SS:SP始终指向的是栈顶元素，push和pop指令能够修改SP的值，push使SP-2,pop使SP+2，SS:SP表示的是栈的地址。 4.bp,si,di寄存器，寻址方式以及其他的寄存器 寻址方式：[bx+idata] [bx+si] [bx+di] [bx+si+idata] [bx+di+idata] 注意：方括号内只能用bx,si,di和数字，si和di不能同时出现 1234567891011直接寻址：[idata] 寄存器间接寻址：[bx] [si] [di] [bp] 寄存器相对寻址：[bx+idata] 用于结构体:[bx].idata 用于数组：idata[si] 用于二维数组：[bx][idata]基址变址寻址：[bx+si/di] [bp+si/di] 用于二维数组：[bx][si]相对基址变址寻址：[bx+si+idata] 用于结构中的数组项：[bx].idata[si] 用于二维数组：idata[bx][si] 只要在[ ]中使用bp，而指令中没有显性地给出段地址，段地址就默认在SS中 5.标志位寄存器ZF,PF,SF,CF,OF,DF和串传送指令pushf和popf ZF: 零标志位，记录相关指令执行后，判断结果是否为0，如果为0，则ZF &#x3D; 1,不为0则ZF &#x3D; 0; PF: 奇偶标志位，记录相关指令执行后，结果的所有Bit位中1的个数是否为偶数，如果是偶数则pf &#x3D; 1,奇数则为0 SF:符号标志位，记录相关指令执行后，结果是否为负，如果为负则sf &#x3D; 1,否则为0 CF：进位标志位，进行无符号数运算时 ，记录运算结果的最高有效位的进位值，或从更高位的借位值 OF：溢出标志位，对有符号数运算的溢出标志，如果发生溢出则OF &#x3D; 1,没溢出则OF &#x3D; 0 DF：方向标志位，在串处理指令中，控制每次操作后si,di的增减， df &#x3D; 0 每次操作后si、di递增 df &#x3D;1 每次操作后si、di递减 串传送指令： movsb : 相当于 1mov es:[di],byte ptr ds:[si] ;8086中没有这样的指令，仅作描述 将ds:si指向的内存单元中的字节送入es:di中，然后根据df的值，将si和di递增或递减 类似的，movsw的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据df的值，将si和di递增2或递减2 这两个指令常和rep配合使用 12345rep movsb s:movsb loop s;这两者等价，也就是说rep会根据cx的值重复执行后面的指令 pushf的功能是将标志寄存器的值压栈，popf则是从栈中弹出数据，送入标志寄存器，用以直接访问标志寄存器 6.条件判断语句cmp,je,ja,jb,adc,sbb adc:带进位加法指令，adc ax,bx 表示 (ax) &#x3D; (ax) + (bx) + CF sbb:带借位减法指令, sbb ax,bx 表示(ax) &#x3D; (ax) - (bx) - CF cmp：比较指令，相当于减法指令，只是不保存结果，而是对标志位寄存器产生影响 123456789101112131415161718192021222324252627282930313233343536373839其实，我们通过cmp指令执行后，相关标志位的值就可以看出比较的结果.cmp ax, bx如果(ax) = (bx) 则(ax) - (bx) = 0, 所以：zf = 1 ;如果(ax) ≠ (bx) 则(ax) - (bx) ≠ 0, 所以：zf = 0 ;如果(ax) &lt; (bx) 则(ax) - (bx) 将产生借位, 所以：cf = 1 ;如果(ax) ≥ (bx) 则(ax) - (bx) 不必借位, 所以：cf = 0 ；如果(ax) ＞ (bx) 则(ax) - (bx) 既不必借位，结果也不为0, 所以：cf = 0并且 zf = 0 ;如果(ax) ≤ (bx) 则(ax) - (bx) 既可能借位，结果可能为0, 所以：cf = 1 或 zf = 1 现在我们可以看出比较指令的设计思路，即：通过做减法运算，影响标志寄存器，标志寄存器的相关记录位记录了比较的结果. 反过来：指令cmp ax, bx的逻辑含义是比较ax和bx中的值，如果执行后：zf = 1，说明(ax) = (bx)zf = 0，说明(ax) ≠ (bx)cf = 1，说明(ax) &lt; (bx)cf = 0，说明(ax) ≥ (bx)cf = 0 且 zf = 0，说明(ax) &gt; (bx)cf = 1 或 zf = 1，说明(ax) ≤ (bx)以cmp ah, bh为例，总结一下cpu执行cmp指令后，sf和of的值是如何来说明比较的结果的.1) 如果sf = 1，而of = 0of = 0，说明没有溢出，逻辑上真正结果的正负 = 实际结果的正负;因 sf = 1，实际结果为负，所以逻辑上真正的结果为负，所以 (ah) &lt; (bh) .2) 如果sf = 1，而 of = 1of = 1，说明有溢出，逻辑上真正的结果的正负 ≠ 实际结果的正负；因 sf = 1， 实际结果为负.实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负. 简单分析就可以看出，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正.这样，sf = 1，of = 1，说明了 (ah) &gt; (bh).3) 如果sf = 0，而 of = 1of = 1，说明溢出，逻辑上真正结果的正负 = 实际结果的正负;因sf = 0，实际结果为非负. 而 of = 1说明溢出，则结果为非0，所以，实际结果为正.实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负，简单分析一下，就可以看出，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负.这样，sf = 0，of = 1，说明了 (ah) &lt; (bh).4) 如果 sf = 0，而of = 0of = 0，说明没有溢出，逻辑上真正的结果的正负 = 实际结果的正负；因 sf = 0，实际结果非负，所以逻辑上真正的结果非负，所以 (ah) ≥ (bh) . 利用cmp指令进行比较，改变标志寄存器的值，再用条件转移指令进行转移 三、编写程序1.循环语句loop，call和ret指令写函数，call far ptr和retf指令，本质是栈 loop的循环次数由CX的值来确定 call 调用的函数要一般写在int后面，防止第二次调用 1234567call指令会进行两步操作，1）将当前的IP或CS和IP入栈 push ip2）转移 jmp near ptr 标号call 指令入栈的IP为call后面的指令的地址 12345678call far ptrpush CSpush IPjmp far ptr 标号类似地，入栈的CS和IP都是call后面的指令的地址 ret返回的是call的下一行指令，且ret指令使用的是栈中的内容，修改IP的内容，从而实现近转移，即段内返回，相当于pop ip 而retf修改的是CS和IP的内容，实现远转移,相当于pop IP pop CS 同时，使用这两个指令会改变sp的值（sp+2) call 还有call ax的用法，即先把原IP入栈，再改变IP为ax 2.代码段、数据段、栈段、dup指令 db(define byte):字节型，8位 dw(define word)：字型，16位 dd(define double word):双字型，32位 这些相当于c语言里面的定义数据类型，注意，在十六进制里，表示数字不能以字母为开头，要在前面加上0，在数据定义之后可以用start伪指令来表示程序的开始处，并用end start来表示结束 dup : 123db 3 dup(0) ;定义了3个字节，值都为0db 3 dup(0,1,2) ;定义了9个字节，即重复0,1,2三次db 3 dup(&#x27;abc&#x27;,&#x27;ABC&#x27;) ;定义了18个字节 类似的，dw,dd都可以这样用 3.offset指令,jmp short、far,dword ptr等跳转指令 offset的功能是取得标号的偏移地址 123456789101112131415ptr可以用来表示指针转换，把数据的类型转换jmp short s ;段内短转移，对ip的修改范围为-128~127（单位是字节），jmp跳转实际上是计算偏移地址差，然后加上这个差（向上跳转差是负数）jmp near ptr s ;段内近转移，对ip的修改范围为-32768~32767jmp far ptr s ;段间转移，也称远转移，修改的是CS和IP的值jmp word ptr 内存单元地址 ;（段内转移）功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出，修改的是IP的值jmp dword ptr 内存单元地址 ;（段间转移）功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出，修改的是CS和IP的值例如：mov ax,0123hmov ds:[0],axmov word ptr ds:[2],0 ;这里使用word ptr是表示传入的0是一个字的类型jmp dword ptr ds:[0]执行后， (CS)=0,(IP)=0123h,也就是高地址的ds:[2]的值赋给了CS,低地址的ds:[0]赋给了IP 四、中断1.操作显存数据主存储器地址空间大小为640K，地址从00000到9FFFF，其他各类ROM地址空间256KB，地址从C0000到FFFFF。 显存地址空间大小为128K，地址是从A0000到BFFFF，其中B8000h~BFFFFh共32k的空间，是80*25（25行80列）的彩色字符模式第0页的显示缓冲区。 每个位置需要两个字节（一个字），每一行就有160（A0H）个字节。 对每个位置的两个字节，低位字节存储的是要显示符号的ASCII，高位字节存储的是显示属性的字节 （如图是高字节的属性） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950; 屏幕中间显示三行彩色字assume cs:code, ds:data, ss:stack data segment db &#x27;Welcome to masm!&#x27; db 2,36,113 ;字符属性代码(十进制) data ends stack segment db 16 dup(0)stack ends code segmentstart: mov ax,data mov ds,ax mov bx,0 mov di,16 mov ax,stack mov ss,ax mov sp,0 mov ax,0b800h mov es,ax mov si,160*12+32*2;将字符输出到屏幕中央 ;(显示器可以显示25行，每行80个字符，每个字符两个字节) mov cx,3s1: mov dh,ds:[di] ;高位放属性 push cx mov cx,16s0: mov dl,ds:[bx] ;低位放ASCⅡ码 mov es:[si],dx ;放入缓冲区 add si,2 inc bx ;下一个字符 loop s0 pop cx inc di add si,80h ;移动到下一行 sub bx,bx ;字符串从头开始 loop s1 ;循环3次,输出三行 mov ax,4c00h int 21hcode endsend start 2.标号标号既可以用于代码段，也可以用于数据段，同时用offset+标号来取偏移地址 或者用以下表示方法，成为数据标号，数据标号标记了存储数据的单元的地址和长度，它不同于仅仅表示地址的地址标号 3.直接定址表 数据的直接定址表：建立一张表，表格依次存储字符 “0” ~ “F”，我们可以通过数值 0~15 直接查找到对应的字符。 12345678910111213141516171819202122232425262728293031;用 al 传送要显示的数据showbyte: jmp short show table db &#x27;0123456789ABCDEF&#x27; ;字符表 show: push bx push es mov ah,al shr ah,1 shr ah,1 shr ah,1 shr ah,1 ;右移 4 位，ah 中得到高 4 位的值 and al,00001111b ;al 中为低 4 位的值 mov bl,ah mov bh,0 mov ah,table[bx] ;用高 4 位的值作为相对于 table 的偏移，取得对应的字符 mov bx,0b800h mov es,bx mov es:[160*12+40*2],ah mov bl,al mov bh,0 mov al,table[bx] ;用低 4 位的值作为相对于 table 的偏移，取得对应的字符 mov es:[160*12+40*2+2],al pop es pop bx ret 子程序中，在数值 015 中和字符 “0”“F” 之间建立的映射关系位：以数值 N 为 table 表中的偏移，可以找到对应的字符。 代码的直接定址表：可以在直接定址表中存储子程序的地址，方便地实现不同子程序的调用。 4.中断及其处理中断向量表：每个入口地址占用四个字节，保存IP和CS，总共1024个字节 0号中断由除法除以0触发，执行后相当于int 0 中断向量表起始地址为0000：0000 中断程序在其他位置，可由中断向量表寻址跳转 类代码描述： 5.0号中断改编中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。8086 支持 256 个中断，但是，实际上，系统中要处理的中断事件远没有达到256 个 。所以在中断向量表中，有许多单元是空的。中断向量表是PC系统中最重要的内存区，只用来存放中断处理程序的入口地址，DOS 系统和其他应用程序都不会随便使用这段空间。我们可以利用中断向量表中的空闲单元来存放我们的程序。一般情况下：从0000:0200至0000:02FF的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用。我们估计，do0的长度不可能超过256个字节。结论：我们可以将do0传送到内存0000:0200处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051assume cs:codeCOMMENT !由于中断例程不可能到达256个那么多，所以中断向量表中还有很多是空的比如0000:0200~0000:02FF这256个字节，所以便把中断例程放置在这个位置!code segmentstart:;安装中断例程 mov ax, 0 mov es, ax mov di, 200h ;目的地址es:di 即0000:0200, mov ax, cs mov ds, ax ;源地址ds:si 即do0的偏移地址，也就是中断处理程序 mov si, offset do0 mov cx, offset do0end - offset do0 ;中断处理程序的字节数,也就是要转移的数量 cld ;传输方向为正 rep movsb ;把中断处理程序安装至0000:0200 mov ax, 0 mov es, ax;将中断例程的入口地址放置到中断向量表中 mov word ptr es:[0 * 4], 200h ;将中断处理程序的入口放在0号中断向量中 mov word ptr es:[0 * 4 + 2], 0 mov ax, 4c00h int 21h;中断处理程序do0: ;为了防止字符串被覆盖所以将其放在中断例程里 jmp short do0start db &#x27;Divide overflow!&#x27;, 0do0start: mov ax, 0b800h ;显存段地址 mov es, ax mov di, 160 * 12 + 36 * 2 ;第13行中间位置 mov ax, cs mov ds, ax mov si, 202h ;字符串的偏移地址 mov cx, 10h ;字符串数目s: mov bl, [si] mov es:[di], bl mov es:[di + 1], 2 inc si add di, 2 loop s iret ;返回do0end: nopcode endsend start 6.单步中断基本上，CPU在执行一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程. 单步中断的中断类型码为1，则它所引发的中断过程如下： 12341) 取得中断类型码N；（此时N=1）2) 标志寄存器入栈，TF、IF设置为0；3) CS、IP入栈；4) (IP) = (N*4), (CS) = (N*4+2) 响应中断的特殊情况： 一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程. 可是，在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应. 对于这些情况，这里就不一一举例，只是用一种情况进行说明. 在执行完向ss寄存器传送数据的指令后，即便是发生中断，CPU也不会响应. 这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成. 如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS、IP的值. 而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误. 所以CPU在执行完设置ss的指令后，不响应中断. 这给连续设置ss和sp指向正确的栈顶提供了一个时机. 即，我们应该利用这一特性，将设置ss和sp的指令连续存放，使得sp的指令紧接着设置ss的指令执行，而在此之间，CPU不会引发中断过程. 比如，我们要将栈顶设置1000:0，应该： 123mov ax, 1000hmov ss, axmov sp, 0 而不应该： 1234mov ax,1000hmov ss, axmov ax, 0mov sp, 0 7.int指令引发的中断int 格式： 1int n;n为中断类型码 引发的过程是 12341) 取得中断类型码N；（此时N=1）2) 标志寄存器入栈，TF、IF设置为0；3) CS、IP入栈；4) (IP) = (N*4), (CS) = (N*4+2) 中断7ch的中断例程: 功能为显示一个用0结束的字符串，中断例程安装在 0:200处。参数：（dh）&#x3D; 行号，（dl）&#x3D; 列号，（cl）&#x3D; 颜色，ds:si指向字符串首地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071assume cs:code, ds:datacode segmentstart: jmp install mov dh, 10 mov dl, 10 mov cl, 2 mov ax, data mov ds, ax mov si, 0 int 7ch mov ax, 4c00h int 21h install: mov ax, 0 mov es, ax mov word ptr es:[4 * 7ch], 200h mov word ptr es:[4 * 7ch + 2], 0;安装中断向量表 mov ax, cs mov ds, ax mov ax, 0 mov es, ax mov si, 0 mov di, 200h mov cx, offset do7chEnd - offset do7ch cld rep movsb do7ch:data segment db &quot;welcome to masm!&quot;, 0data ends push cx push si push di mov ax, 0b800h mov es, ax mov ax, data mov ds, ax mov si, 0;源地址偏移 mov al, dh mov bl, 160 mul bl ;dh * 160 add ax, dl mov di, axtrans: mov cl, [si] mov ch, 0 jcxz fin;如果cx = 0，表示已经处理完毕 mov byte ptr es:[di], cl mov byte ptr es:[di + 1], 11000010B inc si add di, 2 jmp transfin: pop di pop si pop cx iret do7chEnd: nopcode endsend start CPU 执行 int 7ch 指令进入中断例程之前，标志寄存器、当前的 CS 和 IP 被压入栈中，在执行完中断例程后，应该用 iret 指令恢复 int 7ch 执行前的标志寄存器和 CS、IP 的值，从而接着执行应用程序。 int 指令和 iret 指令的配合使用与 call 指令和 ret 指令的配合使用具有相似的思路。 8.BIOS和DOS中断处理BIOS（Basic input&#x2F;output system）固化在 ROM 中，包括 I&#x2F;O 设备的处理程序和许多常用的例行程序。 对用户程序来说，可由特定指令 INT n（n 为中断号）通过软终端的方式调用。不管 DOS 是否装入系统，这些调用可以直接控制 I&#x2F;O 设备。 MS-DOS（disk operating system）系统功能调用是DOS为程序员编写汇编语言源程序提供了一组常用子程序（80多个），可在汇编语言程序中直接调用。这些子程序的主要功能包括： (1)设备管理（如键盘、显示器、打印机、磁盘等的管理） (2)文件管理和目录操作 (3)其他管理（如内存、时间、日期等管理） 这些子程序给用户编程带来很大方便，用户不必了解有关的设备、电路、接口等方面的问题，只需直接调用即可。 MS-DOS 规定用INT 21H进入各功能调用子程序的入口，并为每个功能调用规定了一个功能号，以便进入各个相应子程序的入口。 DOS功能调用的子程序已按顺序编号——功能号（00H～68H），其调用方法是： (1) 功能号→AH（根据要使用的DOS功能调用设置入口参数） (2) 入口参数→指定寄存器（将DOS功能调用的编号送入寄存器AH） (3) 发送软中断指令 INT 21H 调用结束后，系统将出口参数送到指定寄存器、内存或直接送到输出设备 9.端口读写CPU 可以直接读写 3 个地方的数据：CPU 内部的寄存器、内存单元、端口。 CPU 通过端口地址来定位端口。因为端口所在的芯片和 CPU 通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。PC 系统中，CPU 最多可以定位 64KB 个不同的端口。则端口地址的范围为 0~65535。 端口的读写指令只有两条：in 和 out。分别从端口读取和写入数据。 比较 CPU 执行内存访问指令和端口访问指令时，总线上的信息： 当端口号大于255(0ffh)时，必须将端口号存入dx再使用in&#x2F;out 访问内存： 1mov ax,ds:[8] CPU 通过地址线将地址信息 8 发出； CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据； 存储器将 8 号单元中的数据通过数据线送入CPU。 访问端口： 1in al,60h;将端口号为60h的端口读出字节至al CPU 通过地址线将地址信息 60h 发出； CPU 通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据； 端口所在的芯片将 60h 端口中的数据通过数据线送入 CPU。 in 和 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据。8 位端口用 al，16 位端口用 ax。 CMOS RAM 芯片 该芯片有两个端口，端口地址为 70h 和 71h。CPU 通过这两个端口来读写 CMOS RAM。 70h 为地址端口，存放要访问的 CMOS RAM 单元的地址；71h 为数据端口，存放从选定的 CMOS RAM 单元中读取的数据，或要写入其中的数据。 在 CMOS RAM 中，存放着当前的时间：年、月、日、时、分、秒。这 6 个信息的长度都位 1 个字节，存放单元为： 时间 秒 分 时 日 月 年 地址（字节） 00 02 04 07 08 09 这些数据以 BCD 码的方式存放。 十进制数码 0 1 2 3 4 5 6 7 8 9 BCD 码 00000 0001 0010 0011 0100 0101 0110 0111 1000 1001 123456789101112131415161718192021222324252627282930（1）CMOS RAM中存储着当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节，存放单元为 秒：0，分：2，时：4，日：7，月：8，年：9，这些数据以BCD码存储，BCD码是以4位二进制数表示十进制数的编码方法，例如十进制的0对应的BCD码为0000，十进制9对应的BCD码为1001，因此一个字节可以表示两个BCD码的两位十进制值。（2）读取CMOS RAM的信息，需要向地址70h写入要访问的单元地址（用al寄存器），然后从数据端口71h中取得指定单元的数据。（3）BCD码值+30h=10进制数对应的ASCII码。（4）显示缓存地址为0b800h处，显示器为80字符宽，25行，每个字符用2个字节显示，高位字节为字符，低位字节为显示属性（可采用默认属性）。;显示年份assume cs:codecode segmemtstart: ;从9号单元读取年份 mov al,9 out 70h,al in al,71h mov ah,alshr ah,4and al,00001111badd ah,30hadd al,30hmov bx,0b800hmov es,bxmov byte ptr es:[160*12+40*2], ahmov byte ptr es:[160*12+40*2+2], almov ax 4c00hint 21hcode endsend start 10.外中断1、可屏蔽中断 可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。当CPU检测到可屏蔽中断信息时，如果IF&#x3D;1，则CPU在执行完当前指令后响应中断，引发中断过程；如果IF&#x3D;0，则不响应可屏蔽中断。 因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。 现在我们可以解释中断过程中将IF置为0的原因了。将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。 如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。8086CPU提供的设置IF的指令如下： sti,设置 IF&#x3D;1；cli,设置 IF&#x3D;0。 2、不可屏蔽中断 不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应引发中断过程。 对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中不需要取中断类型码。则不可屏蔽中断的中断过程为： （1）标志寄存器入栈，IF&#x3D;0，TF&#x3D;0；（2）CS、IP入栈；（3）(IP)&#x3D;(8)，(CS)&#x3D;(0AH)。 几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件(比如说键盘输入)发生时，相关芯片向CPU发出可屏蔽中断信息。 11.PC机键盘处理1. 键盘输入 键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。 按下一个键时，开关接通该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。 扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60h。 松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60h端口中。 一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。扫描码长度为一个字节，通码的第7位为0，断码的第7位为1，即： 断码&#x3D;通码+80h 2. 引发9号中断 键盘的输入到达60h端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。 CPU检测到该中断信息后，如果IF&#x3D;1，则响应中断，引发中断过程转去执行int9中断例程。 3. 执行int9中断例程 BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要的工作如下： （1）读出60h端口中的扫描码；（2）如果是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCII码）送入内存中的BIOS键盘缓冲区；如果是控制键（比如Ctrl）和切换键（比如CapsLock）的扫描码，则将其转变为状态字节（用二进制位记录控制键和切换键状态的字节）写入内存中存储状态字节的单元；（3）对键盘系统进行相关的控制，比如说向相关芯片发出应答信息。 BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。该内存区可以存储15个键盘输入，因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。 12.int 9中断例程定制仿照前面的 13.中断响应外设键盘输入将引发9号中断，BIOS提供了int 9中断例程。CPU在9号中断发生后，执行int 9中断例程，从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。 一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中 BIOS提供了int 16h中断例程供程序员调用。int 16h中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。 应用int 13h中断例程对磁盘进行读写 3.5英寸软盘分为上下两面，每面有80个磁道，每个磁道又分为18个扇区，每个扇区的大小为512个字节。 则：2面x80磁道x18扇区x512字节&#x3D;1440KB≈1.44MB 磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。 BIOS提供的访问磁盘的中断例程为int 13h。读取0面0道1扇区的内容到0:200的程序如下所示。 mov ax,0mov es,axmov bx,200h mov al,1mov ch,0mov cl,1mov dl,0mov dh,0mov ah,2int 13h 入口参数: (ah)&#x3D;int 13h的功能号(2表示读扇区)(al)&#x3D;读取的扇区数(ch)&#x3D;磁道号(cl)&#x3D;扇区号(dh)&#x3D;磁头号(对于软盘即面号，因为一个面用一个磁头来读写)(dl)&#x3D;驱动器号软驱从0开始，0：软驱A, 1：软驱B；硬盘从80h开始，80h：硬盘C, 81h：硬盘Des:bx指向接收从扇区读入数据的内存区 返回参数： 操作成功：(ah)&#x3D;0，(al)&#x3D;读入的扇区数操作失败：(ah)&#x3D;出错代码 将0:200中的内容写入0面0道1扇区。 mov ax,0mov es,axmov bx,200h mov al,1mov ch, 0mov cl,1mov dl,0mov dh,0 mov ah,3int 13h 入口参数： (ah)&#x3D;int 13h的功能号(3表示写扇区)(al)&#x3D;写入的扇区数(ch)&#x3D;磁道号(cl)&#x3D;扇区号(dh)&#x3D;磁头号(面)(dl)&#x3D;驱动器号软驱从0开始，0：软驱A, 1：软驱B；硬盘从80h开始，80h：硬盘C, 81h：硬盘Des:bx指向将写入磁盘的数据 返回参数： 操作成功：(ah)&#x3D;0，(al)&#x3D;写入的扇区数操作失败：(ah)&#x3D;出错代码","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://blog.zymatrix.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"《帝国主义是资本主义的最高阶段》","slug":"《帝国主义是资本主义的最高阶段》","date":"2023-05-10T16:00:00.000Z","updated":"2024-08-12T09:16:44.652Z","comments":true,"path":"2023/05/11/《帝国主义是资本主义的最高阶段》/","link":"","permalink":"http://blog.zymatrix.top/2023/05/11/%E3%80%8A%E5%B8%9D%E5%9B%BD%E4%B8%BB%E4%B9%89%E6%98%AF%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E7%9A%84%E6%9C%80%E9%AB%98%E9%98%B6%E6%AE%B5%E3%80%8B/","excerpt":"","text":"铁路网的分布，这种分布的不平衡，铁路网发展的不平衡，是全世界现代资本主义即垄断资本主义造成的结果。这种结果表明，只要生产资料私有制还存在，在上述这样的经济基础上，帝国主义战争是绝对不可避免的。 很明显，这种大量的超额利润（因为它是在资本家从“自己”国家工人身上榨取的利润之外得来的）可以用来收买工人领袖和工人贵族这个上层。 这个资产阶级化了的工人阶层即“工人贵族”阶层，这个按生活方式、工资数额和整个世界观来说已经完全小市民化的工人阶层，是第二国际的主要支柱，现在是资产阶级的主要社会支柱。因为这是资产阶级在工人运动中的真正代理人，是资本家阶级的工人帮办，是改良主义和沙文主义的真正传播者。在无产阶级同资产阶级的国内战争中，他们有不少人必然会站在资产阶级方面，站在“凡尔赛派”方面来反对“公社战士”。 帝国主义阶段的资本主义紧紧接近最全面的生产社会化，它不顾资本家的愿望和意识，可以说是把他们拖进一种从完全的竞争自由向完全的社会化过渡的新的社会秩序。 生产社会化了，但是占有仍然是私人的。社会化的生产资料仍旧是少数人的私有财产。在形式上被承认的自由竞争的一般架子依然存在，而少数垄断者对其余居民的压迫却更加百倍地沉重、显著和令人难以忍受了。 为数众多的普通中介人成为极少数垄断者的这种转变，是资本主义发展成为资本帝国主义的基本过程之一。 生产的集中；从集中生长起来的垄断；银行和工业日益融合或者说长合在一起，——这就是金融资本产生的历史和这一概念的内容。 垄断既然已经形成，而且操纵着几十亿资本，它就绝对不可避免地要渗透到社会生活的各个方面去，而不管政治制度或其他任何“细节”如何。 资本主义的一般特性，就是资本的占有同资本在生产中的运用相分离，货币资本同工业资本或者说生产资本相分离，全靠货币资本的收入为生的食利者同企业家及一切直接参与运用资本的人相分离，帝国主义，或者说金融资本的统治，是资本主义的最高阶段，这时候，这种分离达到了极大的程度。金融资本对其他一切形式的资本的优势，意味着食利者和金融寡头占统治地位，意味着少数拥有金融“实力”的国家处于和其余一切国家不同的特殊地位。 对自由竞争占完全统治地位的旧资本主义来说，典型的是商品输出。对垄断占统治地位的最新资本主义来说，典型的则是资本输出。 金融资本是一种存在于一切经济关系和一切国际关系中的巨大力量，可以说是起决定作用的力量，它甚至能够支配而且实际上已经支配着一些政治上完全独立的国家。 资本主义愈发达，原料愈感缺乏，竞争和追逐全世界原料产地的斗争愈尖锐，抢夺殖民地的斗争也就愈激烈。 在金融资本的基础上生长起来的非经济的上层建筑，即金融资本的政策和意识形态，加强了夺取殖民地的趋向。 试问，在资本主义基础上，要消除生产力发展和资本积累同金融资本对殖民地和“势力范围”的瓜分这两者之间不相适应的状况，除了用战争以外，还能有什么其他办法呢？ 帝国主义有一种趋势，就是在工人中间也分化出一些特权阶层，并且使他们脱离广大的无产阶级群众。（分化出工人贵族，这些人将是反对无产阶级革命的一部分，但是由于他们仍然是无产阶级，在危机来临之时，现实将会把他们从大梦中拍醒） 例如，恩格斯在1858年10月7日给马克思的信中说：“英国无产阶级实际上日益资产阶级化了，因而这一所有民族中最资产阶级化的民族，看来想把事情最终弄到这样的地步，即除了资产阶级，它还要有资产阶级化的贵族和资产阶级化的无产阶级。” 考茨基的 “理论”的客观即真正的社会意义只有一个，就是拿资本主义制度下可能达到永久和平的希望，对群众进行最反动的安慰，其方法就是使人们不去注意现代的尖锐矛盾和尖锐问题，而去注意某种所谓新的将来的 “超帝国主义”的虚假前途。","categories":[{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"}]},{"title":"建站小记","slug":"first","date":"2023-04-05T16:00:00.000Z","updated":"2024-08-12T09:20:03.695Z","comments":true,"path":"2023/04/06/first/","link":"","permalink":"http://blog.zymatrix.top/2023/04/06/first/","excerpt":"","text":"建站原因在b站上看到了一个搭建个人博客网站的视频，心血来潮以及作为Geek必备的博客作为驱动力，于是查找了一些资料最终找到了以github + hexo 的方式建立博客。感谢朋友（畅姐我的神）的倾情推荐，给了我一个好教程。 曲折的建站过程说到这个，不得不吐槽一下我这令人愤怒的电脑。从我大一上学期配C语言环境开始，再到虚拟机和linux ssh远端连接，这玩意就没让我省心过。吐槽结束，现在是问题时间。 一由于初次上手个人网站搭建，所知甚少。而且最开始时，没有如此系统的教程，都是用的零七碎八的教程，难免遇到各种问题。 npm node hexo 安装完成后出现类似command not found的问题，用Google搜索、在stackoverflow上找相关问题，都没能解决这个问题，最后尝试了csdn上的一个说法，即设置环境变量,在path下面加上npm node hexo等的路径，成功解决问题。（多少有点zz了）路径问题占据了我建站的绝大多数时间。 设置部署仓库和分支出现 “FATAL YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key (107:14)” 的问题。这个问题是因我在更改hexo源码根目录下的_config.yml中的deploy部分直接复制粘贴引起的。参考下图，在repo:以及branch:的冒号后面要加上’ ‘空格。 目前尚未解决的问题。GitHub Actions自动部署，按照教程上传workflow文件到github上，但是目前还没成功，也没查原因。 在执行hexo generate和hexo deploy命令时可能会出现kex_exchange_identification: Connection closed by remote host Connection closed by 20.205.243.166 port 22 fatal: Could not read from remote repository的错误信息，这个时候需要改变一下自己的vpn节点，或者在vpn速度较好时再重新执行hexo d的命令。 二建站完成之后，就是要对网站进行个性化的修改，对样式进行处理 在文章的头部部分增加一下内容能够达到对文章进行分类的效果。这些内容可以在_config.yml文件中找到对应的部分。1234567891011---title: #文章标题cover: #文章封面的图片的链接或者地址category: #文章在子页中的分类tag: - #文章的标签id: #文章的序号date: #文章写作的时间toc: true #是否包含目录timeline: #在时间线中的分类---","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"《国家与革命》","slug":"《国家与革命》 列宁","date":"2023-04-05T16:00:00.000Z","updated":"2024-08-12T09:17:09.654Z","comments":true,"path":"2023/04/06/《国家与革命》 列宁/","link":"","permalink":"http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%9B%BD%E5%AE%B6%E4%B8%8E%E9%9D%A9%E5%91%BD%E3%80%8B%20%E5%88%97%E5%AE%81/","excerpt":"","text":"序言 如果不同“国家”问题上的机会主义偏见作斗争，使劳动群众摆脱资产阶级影响、特别是摆脱帝国主义资产阶级影响的斗争就无法进行。 无产阶级社会主义革命对国家的态度问题不仅具有政治实践的意义，而且具有最迫切的意义，这个问题是要向群众说明，为了使自己从资本的枷锁下解放出来，他们在最近的将来应当做些什么。 第一章 阶级社会与国家国家是阶级矛盾不可调和的产物 当伟大的革命家在世时，压迫阶级总是不断迫害他们，以最恶毒的敌意、最疯狂的仇恨、最放肆的造谣和诽谤对待他们的学说。在他们逝世以后，便试图把他们变为无害的神像，可以说把他们偶像化，赋予他们的名字某种荣誉，以便“安慰”和愚弄被压迫阶级，同时却阉割革命学说的内容，磨去它的革命锋芒，把它庸俗化。 国家是阶级矛盾不可调和的产物和表现。在阶级矛盾客观上不能调和的地方、时候和条件下，便产生国家。反过来说，国家的存在证明阶级矛盾不可调和。 在马克思看来，国家是阶级统治的机关，是一个阶级压迫另一个阶级的机关，是建立一种“秩序”来抑制阶级冲突，使这种压迫合法化、固定化。 既然国家是阶级矛盾不可调和的产物，既然它是凌驾于社会之上并且“日益同社会相异化”的力量，那么很明显，被压迫阶级要求得解放，不仅非进行暴力革命不可，而且非消灭统治阶级所建立的、体现这种“异化”的国家政权机构不可。 国家是剥削被压迫阶级的工具 他们自己相信而且要人民也相信这种荒谬的想法：普选制“在现今的国家里”能够真正体现大多数劳动者的意志，并保证实现这种意志。 目前，在任何民主共和国中，帝国主义和银行统治都把这两种维护和实现财富的无限权力的方法“发展”到了非常巧妙的地步。 国家“自行消亡”和暴力革命 当国家终于真正成为整个社会的代表时，它就使自己成为多余的了。——恩格斯 那时，对人的统治将由对物的管理和对生产过程的领导所代替。国家不是“被废除的”，它是自行消亡的。——恩格斯 按恩格斯的看法，资产阶级国家不是“自行消亡”的，而是由无产阶级在革命中来“消灭”的。在这个革命以后，自行消亡的是无产阶级的国家或半国家。 显然，以一种（无产阶级的）“特殊力量”来代替另一种（资产阶级的）“特殊力量”，这样一种更替是决不能通过“自行消亡”来实现的。 因此任何国家都不是自由的，都不是人民的。 第二章 国家与革命。1848-1851年的经验革命的前夜 无产阶级需要国家政权，中央集权的强力组织，暴力组织，既是为了镇压剥削者的反抗，也是为了领导广大民众即农民、小资产阶级和半无产者来“调整”社会主义经济。 马克思主义教育工人的党，也就是教育无产阶级的先锋队，使它能够夺取政权并引导全体人民走向社会主义，指导并组织新制度，成为所有被剥削劳动者在不要资产阶级并反对资产阶级而建设自己社会生活的事业中的导师、领导者和领袖。 1852年马克思对问题的提法 把马克思主义局限于阶级斗争学说，就是阉割马克思主义，歪曲马克思主义，把马克思主义变为资产阶级可以接受的东西。只有承认阶级斗争、同时也承认无产阶级专政的人，才是马克思主义者。 第三章 国家与革命。1871年巴黎公社的经验。马克思的分析取消议会制 我们不是空想主义者。我们并不“幻想”一下子就可以不要任何管理，不要任何服从；这种由于不懂得无产阶级专政的任务而产生的无政府主义幻想，与马克思主义根本不相容，实际上只会把社会主义革命拖延到人们变成另一种人的时候。 但是所需要的服从，是对一切被剥削劳动者的武装先锋队——无产阶级的服从。 第五章 国家消亡的经济基础从资本主义到共产主义的过渡 产生违反公共生活规则的极端行动的根本社会原因是群众受剥削和群众贫困。这个主要原因一消除，极端行动就必然开始“消亡”。 共产主义社会的第一阶段 任何权利都是把同一标准应用在不同的人身上，即应用在事实上各不相同、各不同等的人身上，因而“平等的权利”就是破坏平等，就是不公平。 可见，在共产主义第一阶段还不能做到公平和平等，因为富裕的程度还会不同，而不同就是不公平。 可见，在共产主义下，在一定的时期内，不仅会保留资产阶级权利，甚至还会保留资产阶级国家，——但没有资产阶级！ 其实，，无论在自然界或在社会中，实际生活随时随地都能使我们看到新事物中有旧的残余。马克思并不是随便把一小块“资产阶级”权利塞到共产主义中去，而是抓住了从资本主义脱胎出来的社会里那种在经济上和政治上不可避免的东西。","categories":[{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"}]},{"title":"《哥达纲领批判》","slug":"《哥达纲领批判》","date":"2023-04-05T16:00:00.000Z","updated":"2024-08-12T09:16:56.871Z","comments":true,"path":"2023/04/06/《哥达纲领批判》/","link":"","permalink":"http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%93%A5%E8%BE%BE%E7%BA%B2%E9%A2%86%E6%89%B9%E5%88%A4%E3%80%8B/","excerpt":"","text":"劳动不是一切财富的源泉。自然界同劳动一样也是使用价值（而物质财富就是由使用价值构成的！）的源泉，劳动本身不过是一种自然力即人的劳动力的表现 只有一个人一开始就以所有者的身份来对待自然界这个一切劳动资料和劳动对象的第一源泉，把自然界当做属于他的东西来处置，他的劳动才成为使用价值的源泉，因而也成为财富的源泉。 在一个集体的、以生产资料公有为基础的社会中，生产者不交换自己的产品；用在产品上的劳动，在这里也不表现为这些产品的价值，不表现为这些产品所具有的某种物的属性，因为这时，同资本主义社会相反，个人的劳动不再经过迂回曲折的道路，而是直接作为总劳动的组成部分存在着。 权利决不能超出社会的经济结构以及由经济结构制约的社会的文化发展 庸俗的社会主义仿效资产阶级经济学家把分配看成并解释成一种不依赖于生产方式的东西，从而把社会主义描写为主要是围绕着分配兜圈子。（由此可见，所谓依靠政府进行再分配的温和社会主义，即社会民主主义国家并不能称作是代表无产阶级的国家，它并未改变资本主义社会的经济基础因而也没有改变无产阶级被剥削的事实。） 在资本主义社会和共产主义社会之间，有一个从前者变为后者的革命转变时期。同这个时期相适应的也有一个政治上的过渡时期，这个时期的国家只能是无产阶级的革命专政。 自由就在于把国家由一个高踞社会之上的机关变成完全服从这个社会的机关；而且就在今天，各种国家形式比较自由或比较不自由，也取决于这些国家形式把“国家的自由”限制到什么程度。 在按照不同的年龄阶段严格调节劳动时间并采取其他保护儿童的预防措施的条件下，生产劳动和教育的早期结合是改造现代社会的最强有力的手段之一。 当无产阶级还需要国家的时候，它需要国家不是为了自由，而是为了镇压自己的敌人，一到有可能谈自由的时候，国家本身就不存在了。","categories":[{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"}]},{"title":"《德意志意识形态（节选）》","slug":"《德意志意识形态（节选）》马克思 恩格斯","date":"2023-04-05T16:00:00.000Z","updated":"2024-08-12T09:15:56.249Z","comments":true,"path":"2023/04/06/《德意志意识形态（节选）》马克思 恩格斯/","link":"","permalink":"http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%BE%B7%E6%84%8F%E5%BF%97%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81%EF%BC%88%E8%8A%82%E9%80%89%EF%BC%89%E3%80%8B%E9%A9%AC%E5%85%8B%E6%80%9D%20%E6%81%A9%E6%A0%BC%E6%96%AF/","excerpt":"","text":"第一卷第一章费尔巴哈唯物主义观点和唯心主义观点的对立 因此，他们是什么样的，这同他们的生产是一致的——既和他们生产什么一致，又和他们怎样生产一致。 各民族之间的相互关系取决于每一个民族的生产力、分工和内部交往的发展程度。 一个民族的生产力发展的水平，最明显地表现于该民族分工的发展程度。任何新的生产力，只要它不是迄今已知的生产力单纯的量的扩大(例如，开垦土地)，都会引起分工的进一步发展。 一个民族内部的分工，首先引起工商业劳动同农业劳动的分离，从而也引起城乡的分离和城乡利益的对立。分工的进一步发展导致商业劳动同工业劳动的分离。 如果他们把哲学、神学、实体和一切废物消融在“自我意识”中，如果他们把“人”从这些词句的统治下——而人从来没有受过这些词句的奴役——解放出来，那么“人”的“解放”也并没有前进一步；只有在现实的世界中并使用现实的手段才能实现真正的解放[16]；没有蒸汽机和珍妮走锭精纺机就不能消灭奴隶制；没有改良的农业就不能消灭农奴制；当人们还不能使自己的吃喝住穿在质和量方面得到充分保证的时候，人们就根本不能获得解放 我们谈的是一些没有任何前提的德国人，因此我们首先应当确定一切人类生存的第一个前提，也就是一切历史的第一个前提[30]，这个前提是：人们为了能够“创造历史”，必须能够生活[31]。但是为了生活，首先就需要吃喝住穿以及其他一些东西。因此第一个历史活动就是生产满足这些需要的资料，即生产物质生活本身，而且这是这样的历史活动，一切历史的一种基本条件，人们单是为了能够生活就必须每日每时去完成它，现在和几千年前都是这样。 由此可见，一开始就表明了人们之间是有物质联系的。这种联系是由需要和生产方式决定的，它和人本身有同样长久的历史；这种联系不断采取新的形式，因而就表现为“历史”，它不需要有专门把人们联合起来的任何政治的或宗教的呓语。 其次，生产力的这种发展之所以是绝对必需的实际前提，还因为：只有随着生产力的这种普遍发展，人们的普遍交往才能建立起来；普遍交往，一方面，可以产生一切民族中同时都存在着“没有财产的”群众这一现象(普遍竞争)，使每一民族都依赖于其他民族的变革；最后，地域性的个人为世界历史性的、经验上普遍的个人所代替。不这样，(1)共产主义就只能作为某种地域性的东西而存在；(2)交往的力量本身就不可能发展成为一种普遍的因而是不堪忍受的力量：它们会依然处于地方的、笼罩着迷信气氛的“状态”；(3)交往的任何扩大都会消灭地域性的共产主义。共产主义只有作为占统治地位的各民族“一下子”同时发生的行动，在经验上才是可能的，而这是以生产力的普遍发展和与此相联系的世界交往为前提的。","categories":[{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"}]},{"title":"《法德农民问题》","slug":"法德农民问题","date":"2023-04-05T16:00:00.000Z","updated":"2024-08-12T09:20:39.209Z","comments":true,"path":"2023/04/06/法德农民问题/","link":"","permalink":"http://blog.zymatrix.top/2023/04/06/%E6%B3%95%E5%BE%B7%E5%86%9C%E6%B0%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"作为政治力量的要素，农民至今在多数场合下仅仅表现出自己的那种生根于农村生活孤僻状况中的冷漠态度。广大居民群众的这种冷漠态度，不仅是巴黎和罗马国会腐败情况的强有力支柱，而且是俄罗斯专制主义的强有力的支柱。 社会党夺取政权已成为最近将来的事情。然而，为了夺取政权，这个政党应当首先从城市跑到农村，应当成为农村中的力量。 那末我们对待小农的态度是怎样的呢？在我们夺得国家权力的那一天，我们应该怎样对待他们呢？ 第一，法国纲领的原理是绝对正确的：我们预见到小农必然灭亡，但我们无论如何不要以自己的干预去加速其灭亡。 第二，同样明显的，当我们掌握了国家权力的时候，我们根本不能设想用强制的办法去剥夺小农（不论有无报偿，都是一样），像我们将不得不如此对待大土地占有者那样。我们对于小农的任务，首先是把他们的私人生产和私人占有变为合作社的生产和占有，但不是用强制的办法，而是通过示范和为此提供社会帮助。 - 我们永远也不能许诺小农给他保持个体经济和个人财产去反对资本主义生产的优势力量。我们只能许诺他们说，我们不会违反他们的意志而用强力干预他们的财产关系。","categories":[{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"}]},{"title":"CS:APP阅读笔记#1","slug":"csapp1","date":"2023-03-28T16:00:00.000Z","updated":"2024-08-12T09:19:24.266Z","comments":true,"path":"2023/03/29/csapp1/","link":"","permalink":"http://blog.zymatrix.top/2023/03/29/csapp1/","excerpt":"","text":"第2章 信息的表示和处理2.2.5在本节中的网络旁注DATA:TMIN部分提到，在C语言中把TMin32（32位有符号数最小值）写成是-2147483647-1，而不是简单的写成是-2147483648或者0x80000000。在C的头文件limits.h中有 12#define INT_MAX 2147483647#define INT_MIN (-INT_MAX - 1) 然而旁注仅仅提到是由于“补码表示的不对称性和C语言的转换规则之间奇怪的交互”，至于是什么规则，书中并没有解释。 后查阅谷歌，参考了文章https://www.cnblogs.com/jack47/archive/2013/01/06/tmin32-in-c.html https://ld246.com/article/1357370795290 文章指出，在某些编译器中，表示一个负数往往采用的是-X(X&gt;0)的形式，而由于32位机器以及补码表示整型的不对称性，2147483648超过了32位机器所能表示的最大有符号整型数的范围，造成溢出，因此必须写成-2147483647-1。简而言之，就是 “用一句话来解释C语言中TMin32的古怪写法的原因：虽然-2147483648 这个数值能够用int类型来表示，但在C语言中却没法写出对应这个数值的int类型常量。”","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"csapp","slug":"csapp","permalink":"http://blog.zymatrix.top/tags/csapp/"}]},{"title":"2022年度总结","slug":"2022年度总结","date":"2022-12-30T16:00:00.000Z","updated":"2024-08-12T09:15:39.418Z","comments":true,"path":"2022/12/31/2022年度总结/","link":"","permalink":"http://blog.zymatrix.top/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"第一次对自己人生的十八分之一进行总结，不知是出于这一年自己太过庸常，还是波澜起伏的大事太多,总之，我总算是愿意花上一点时间坐在电脑前，回顾一下这一年的纷扰，同时展望一下不可展望的未来。马克·吐温说:“现实比小说荒诞多了，虚构还要在一定逻辑下进行，而现实往往毫无逻辑可言。”我愿意用荒诞这样一个无法言说荒诞的词来概括这一年。这一年，我看到的我所认为魔幻的事件以一种难以预料到的方式出现，以致所有人吹嘘其重要性的高考显得那么平常。六月初的两天，我只是在安详之中度过，尽管身边的每一个人所展现出来的神态、语言和动作，都在明确地告诉我这是我目前的人生中最重要的大事，但是我总会不屑地告诉自己，十八年前的那一天显然更为重要。依照今日马后炮的回忆，它所带来的心情波动，甚至不及我填报志愿的几日和我住进宿舍的那一天。我甚至不愿意再花上一分钟去回忆那段时光，因为只有同学、师长、亲人和书本值得被我记录。这一年，我去到了大学，一个曾经令我魂牵梦萦的圣地。我厌倦了高中那重复难以获得新知的枯燥，度过的日子就像是在沙漠里每日以沙子充饥。我说:“对于高中，回忆是痛苦的，最后在回忆里留下的一定是一群值得怀念的人。”很多事只有当它出现在面前的时候，才能知道真正的模样。大学也是如此。毫无意义的会议、毫无意义的课程、毫无意义的内耗这些是只有身在围城中的人才能深切知晓的。我只会把大学丑陋的一面讲述给自己，至于那些美好的画面，在那之前我已经幻想得足够多了。这一年，无能的官僚资产阶级在无产阶级爆发出的怨气和对乌鲁木齐火灾中不幸罹难的同胞的同情中被迫让步，全国各地此起彼伏的游行示威宣示着对官僚资产阶级的不满。我很高兴能够见到这一切，我仍然记得那天我是怎样的激动，看着手机上的新闻，身体有些微微颤抖。这样一件大事，对我的鼓舞比这一年里任何事情都更加明显。这一年，我下定决心，开始学习马列毛主义思想，这些人类历史长河中闪耀的明星，他们将是我未来精神上的导师。这一年，我第一次深刻地领悟到了自己在行动上如何地侏儒。那个决心在暑假阅遍数十书的书虫不见了取而代之的是无营养的知乎;那个决心要好好学习的“卷怪”不见了，取而代之的是无尽的游戏;那个决心要动笔写作的想象者不见了，我看到了自己荒芜的想象世界和波澜不惊的感情世界。简单来说，我缺失了爱的能力。生动的小说世界和情感丰沛的诗再也没有出现在生活之中，我曾经用来思考的碎片时间被智能手机填充，稍稍空闲下来的间隙，眼睛盯着的不是空气而是屏幕，本就不够深邃的思维愈发迟钝，质问和怀疑之后剩下的不是重新行动，而是一地鸡毛。这一年，“我年华虚度，空余一身疲惫，和所有以梦为马的诗人一样，岁月易逝，一滴不剩”很奇怪，漫长的一年值得纪念的寥寥数语就能概括，而短暂的一天我却怎么也过不好。至于对未来的期望，不过是些老调重弹的东西，写下对这一年的回顾后，我不想对未来再有什么幻想了,只送给2023年一句毛泽东同志的话:“好好学习，天天向上”。","categories":[],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"}]}],"categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"},{"name":"hacker","slug":"hacker","permalink":"http://blog.zymatrix.top/categories/hacker/"},{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://blog.zymatrix.top/tags/C/"},{"name":"Java","slug":"Java","permalink":"http://blog.zymatrix.top/tags/Java/"},{"name":"后端","slug":"后端","permalink":"http://blog.zymatrix.top/tags/%E5%90%8E%E7%AB%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://blog.zymatrix.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JavaSE","slug":"JavaSE","permalink":"http://blog.zymatrix.top/tags/JavaSE/"},{"name":"Python","slug":"Python","permalink":"http://blog.zymatrix.top/tags/Python/"},{"name":"OS","slug":"OS","permalink":"http://blog.zymatrix.top/tags/OS/"},{"name":"Linux Kernel","slug":"Linux-Kernel","permalink":"http://blog.zymatrix.top/tags/Linux-Kernel/"},{"name":"杂记","slug":"杂记","permalink":"http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"},{"name":"CTF","slug":"CTF","permalink":"http://blog.zymatrix.top/tags/CTF/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://blog.zymatrix.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"},{"name":"csapp","slug":"csapp","permalink":"http://blog.zymatrix.top/tags/csapp/"}]}