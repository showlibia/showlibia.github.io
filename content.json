{"meta":{"title":"Matrix's blog","subtitle":"","description":"那时她还年轻，不知道命运馈赠的礼物都在暗中标好了价格","author":"Matrix","url":"http://blog.zymatrix.top","root":"/"},"pages":[{"title":"建站小记","date":"2023-04-05T16:00:00.000Z","updated":"2024-01-01T16:58:53.557Z","comments":true,"path":"about/index.html","permalink":"http://blog.zymatrix.top/about/index.html","excerpt":"","text":"建站原因在b站上看到了一个搭建个人博客网站的视频，心血来潮以及作为Geek必备的博客作为驱动力，于是查找了一些资料最终找到了以github + hexo 的方式建立博客。感谢朋友（畅姐我的神）的倾情推荐，给了我一个好教程。 曲折的建站过程说到这个，不得不吐槽一下我这令人愤怒的电脑。从我大一上学期配C语言环境开始，再到虚拟机和linux ssh远端连接，这玩意就没让我省心过。吐槽结束，现在是问题时间。 一由于初次上手个人网站搭建，所知甚少。而且最开始时，没有如此系统的教程，都是用的零七碎八的教程，难免遇到各种问题。 npm node hexo 安装完成后出现类似command not found的问题，用Google搜索、在stackoverflow上找相关问题，都没能解决这个问题，最后尝试了csdn上的一个说法，即设置环境变量,在path下面加上npm node hexo等的路径，成功解决问题。（多少有点zz了）路径问题占据了我建站的绝大多数时间。 设置部署仓库和分支出现 “FATAL YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key (107:14)” 的问题。这个问题是因我在更改hexo源码根目录下的_config.yml中的deploy部分直接复制粘贴引起的。参考下图，在repo:以及branch:的冒号后面要加上’ ‘空格。 目前尚未解决的问题。GitHub Actions自动部署，按照教程上传workflow文件到github上，但是目前还没成功，也没查原因。 在执行hexo generate和hexo deploy命令时可能会出现kex_exchange_identification: Connection closed by remote host Connection closed by 20.205.243.166 port 22 fatal: Could not read from remote repository的错误信息，这个时候需要改变一下自己的vpn节点，或者在vpn速度较好时再重新执行hexo d的命令。 二建站完成之后，就是要对网站进行个性化的修改，对样式进行处理 在文章的头部部分增加一下内容能够达到对文章进行分类的效果。这些内容可以在_config.yml文件中找到对应的部分。 1234567891011---title: #文章标题toc: true #是否包含目录cover: #文章封面的图片的链接或者地址category: #文章在子页中的分类tag: - #文章的标签id: #文章的序号date: #文章写作的时间timeline: #在时间线中的分类---"},{"title":"标签","date":"2024-08-11T16:00:00.000Z","updated":"2024-08-12T09:22:38.009Z","comments":false,"path":"tags/index.html","permalink":"http://blog.zymatrix.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-08-12T09:23:00.000Z","updated":"2024-08-12T09:23:46.204Z","comments":true,"path":"categories/index.html","permalink":"http://blog.zymatrix.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaSE","slug":"JavaSE","date":"2024-08-11T16:00:00.000Z","updated":"2024-08-16T03:31:35.376Z","comments":true,"path":"2024/08/12/JavaSE/","link":"","permalink":"http://blog.zymatrix.top/2024/08/12/JavaSE/","excerpt":"","text":"JavaSE日志日志能够方便程序员定位程序Bug，并且日志的开关很方便。 Logback利用Maven管理Logback下载，并且将logback.xml文件放入src路径下 关于Logback的使用，可以参考文档和教程 以下是一个简单示例： 123456789101112131415161718192021222324import org.sl4j.Logger;import org.sl4j.LoggerFactory; public class LogbackTest &#123; public static final logger LOGGER = LoggerFactory.getlogger(&quot;LogbackTest&quot;); public static void main(String[] args)&#123; try &#123; LOGGER.info(&quot;Division logging starts&quot;); divide(10, 0); LOGGER.info(&quot;Division succeeds&quot;); &#125; catch(Exception e) &#123; LOGGER.error(&quot;Division fails&quot;); &#125; &#125; public static void divide(int a, int b)&#123; LOGGER.debug(&quot;a&quot;: + a); LOGGER.debug(&quot;b&quot;: + b); int c = a / b; LOGGER.info(&quot;result:&quot; + c); &#125;&#125; 日志级别 只有日志的级别大于或等于核心配置文件（logback.xml）配置的日志级别，才会被记录，否则不记录。 多线程多线程的创建注意，不要把主线程任务放在启动子线程之前，并且使用start方法启动线程 继承Thread类：重写run方法。缺点是无法继承其他类，不利于功能扩展。 实现Runnable接口：重写run方法，这里实现的是一个任务对象，因此需要将任务对象使用new Thread(p)来创建线程。由于Runnable是一个函数式接口，因此可以利用Lamada简化实现。 实现Callable接口：前两个方法都是void方法，没有返回结果。重写call方法，将Callable的对象封装成FutureTask（实现了Runable）。将线程任务对象交给Thread对象。线程执行完毕后，通过FutureTask对象的get方法获取线程任务执行的结果，这里会等待任务执行完毕保证一定能获取到结果。 线程同步 同步代码块，同步方法，都是用synchronized，对于同步代码块，应当传入this参数确保加锁的是同一个对象，如果是静态方法，应该传入Object.class字节码。 Lock，注意要在finally当中确保解锁 线程通信当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以相互协调，并避免无效的资源争夺 生产者消费者模型 线程池一个可以复用线程的技术 核心线程数量配置： 计算密集型： CPU核数 + 1 IO密集型： CPU核数 * 2 ThreadPoolExecutor创建线程池 12345public class ThreadPoolTest &#123; public static void main(String[] args) &#123; ExecutorService pool = new ThreadPoolExecutor(3, 5, 8, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); &#125;&#125; 参数解析： 1public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize: 核心线程数量 这是线程池中始终保持活跃的线程数量。即使它们处于空闲状态，也不会被终止。 maximumPoolSize: 最大线程数量 这是线程池中允许的最大线程数量。如果任务数量超过了核心线程数量，并且工作队列已经填满，线程池会创建临时线程来处理任务。 keepAliveTime: 临时线程空闲存活时间 这是当线程池中的线程数量超过核心线程数量时，多余的线程在终止前可以保持空闲状态的最长时间。如果超过这个时间，多余的线程将被终止。 TimeUnit: 存活时间单位 这是keepAliveTime参数的时间单位，例如秒、分钟、小时等。 BlockingQueue&lt;Runnable&gt;: 工作队列 这是一个阻塞队列，用于存储等待执行的任务。当所有核心线程都在忙碌时，新任务会被放入这个队列中等待。 ThreadFactory: 线程工厂 这个参数允许你创建自定义的线程实例，可以用来设置线程的名称、优先级等属性。 RejectedExecutionHandler: 拒绝执行处理器 当任务太多，无法被线程池接受时，这个处理器会被调用。它定义了任务被拒绝时的处理策略，例如丢弃任务、抛出异常等。 线程池处理Runnable任务 12345678910111213141516171819202122232425public class ThreadPoolTest &#123; public static void main(String[] args) &#123; ExecutorService pool = new ThreadPoolExecutor( 3, 5, 8, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy() ); Runnable target = new MyRunnable(); pool.execute(target); pool.execute(target); pool.execute(target); //加入工作队列 pool.execute(target); pool.execute(target); pool.execute(target); pool.execute(target); //临时线程 pool.execute(target); pool.execute(target); // 由解决方案来决定下面的线程的后续 pool.execute(target); pool.shutdown(); //等到所有线程任务结束后退出程序 &#125;&#125; 处理Callable任务 1234567891011121314151617181920public class ThreadPoolTest1 &#123; public static void main(String[] args) throws Exception &#123; ExecutorService pool = new ThreadPoolExecutor( 3, 5, 8, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy() ); Future&lt;String&gt; f1 = pool.submit(new MyCallable(100)); Future&lt;String&gt; f2 = pool.submit(new MyCallable(200)); Future&lt;String&gt; f3 = pool.submit(new MyCallable(300)); Future&lt;String&gt; f4 = pool.submit(new MyCallable(400)); System.out.println(f1.get()); System.out.println(f2.get()); System.out.println(f3.get()); System.out.println(f4.get()); pool.shutdown(); &#125;&#125; Executors工具类实现线程池 1234static ExecutorService newCachedThreadPool()static ExecutorService newFixedThreadPool(int nThreads)static ExecutorService newSingleThreadExecutor()static ScheduledExecutorService newSingleThreadScheduledExecutor() 大型并发系统使用Executors可能的风险 线程池不允许使用 Executors去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明:Executors返回的线程池对象的弊端如下: FixedThreadPool和singleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 00M。 CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致00M。 线程的生命周期Java为线程定义了6种状态，在Thread.State枚举类中： A thread state. A thread can be in one of the following states: NEWA thread that has not yet started is in this state. RUNNABLEA thread executing in the Java virtual machine is in this state. BLOCKEDA thread that is blocked waiting for a monitor lock is in this state. WAITINGA thread that is waiting indefinitely for another thread to perform a particular action is in this state. TIMED_WAITINGA thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state. TERMINATEDA thread that has exited is in this state 网络通信InetAddress UDP DatagramSocket:用于创建客户端、服务端 TCP: Socket类和ServerSocket类 如下是一个简易群聊，在本地创建客户端和服务端，利用服务端进行端口转发，接收来自客户端的消息并转发至其他客户端 12345678910111213141516171819202122//Server.javapackage tcp;import java.net.ServerSocket;import java.net.Socket;import java.util.ArrayList;import java.util.List;public class Server &#123; public static List&lt;Socket&gt; onlinesockets = new ArrayList&lt;&gt;(); public static void main(String[] args) throws Exception &#123; ServerSocket serversocket = new ServerSocket(6666); System.out.println(&quot;------Server is running------&quot;); while (true) &#123; Socket socket = serversocket.accept(); onlinesockets.add(socket); System.out.println(socket.getRemoteSocketAddress() + &quot; is online&quot;); new ServerReadThread(socket).start(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132// Client.javapackage tcp;import java.io.DataOutputStream;import java.io.OutputStream;import java.net.Socket;import java.util.Scanner;public class Client &#123; public static void main(String[] args) throws Exception &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;, 6666); new ClientReadThread(socket).start(); OutputStream os = socket.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); Scanner sc = new Scanner(System.in); while (true) &#123; System.out.println(&quot;Please enter：&quot;); String msg = sc.nextLine(); if (&quot;exit&quot;.equals(msg)) &#123; dos.close(); socket.close(); break; &#125; dos.writeUTF(msg); dos.flush(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//ServerReadThreadpackage tcp;import java.io.*;import java.net.Socket;public class ServerReadThread extends Thread&#123; private Socket socket; public ServerReadThread(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; InputStream is = socket.getInputStream(); DataInputStream dis = new DataInputStream(is); while (true) &#123; try &#123; String msg = dis.readUTF(); msg = socket.getRemoteSocketAddress() + &quot;:&quot; + msg; System.out.println(msg); sendMsgToAll(msg); &#125; catch (Exception e) &#123; System.out.println(&quot;the client &quot;+socket.getRemoteSocketAddress() + &quot; is closed&quot;); Server.onlinesockets.remove(socket); dis.close(); socket.close(); break; &#125; &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; // 发送消息至除自己外的所有客户端 private void sendMsgToAll(String msg) throws IOException &#123; for (Socket onlinesocket : Server.onlinesockets) &#123; if (onlinesocket.equals(socket)) &#123; continue; &#125; OutputStream os = onlinesocket.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); dos.writeUTF(msg); dos.flush(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536//ClientReadThreadpackage tcp;import java.io.DataInputStream;import java.io.InputStream;import java.net.Socket;//接收服务端分发的消息public class ClientReadThread extends Thread&#123; private Socket socket; public ClientReadThread(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; InputStream is = socket.getInputStream(); DataInputStream dis = new DataInputStream(is); while (true) &#123; try &#123; String msg = dis.readUTF(); System.out.println(msg); &#125; catch (Exception e) &#123; System.out.println(&quot;the client &quot;+socket.getRemoteSocketAddress() + &quot; itself is closed&quot;); dis.close(); socket.close(); break; &#125; &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 可以将上面的Server代码修改一下，变为BS架构的服务端，并且利用线程池来实现高并发 Java高级junit 测试junit 是一种用于Java开发的测试框架。 @Test注解,public void测试方法 断言机制，Assert.assertEquals() 反射 便于理解框架和源码 RTTI（Run-Time Type Identification）运行时类型识别，在运行时识别一个对象的类型和类的信息 获取Class对象、Constructor对象、成员变量(Field)和方法(Method) 并且使用 破坏封装性 Class类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。 注解使用Class类解析出对象含有的注解，利用条件语句选择执行，从而实现类junit框架的简易测试。","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://blog.zymatrix.top/tags/JavaSE/"}]},{"title":"DRF开发","slug":"DRF开发笔记","date":"2024-04-24T16:00:00.000Z","updated":"2024-08-12T09:19:54.188Z","comments":true,"path":"2024/04/25/DRF开发笔记/","link":"","permalink":"http://blog.zymatrix.top/2024/04/25/DRF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"DRF开发笔记在项目目录下的__init__.py文件中需要加入 123import pymysqlpymysql.install_as_MySQLdb() 来使用mysql views.py实现视图函数本文件下实现的是增删改查功能，也就是get post put delete 123456789# Viewset实现from rest_framework.viewsets import ReadOnlyModelViewSet,ModelViewSetclass BookViewSet(ReadOnlyModelViewSet): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer class BookViewSet(ModelViewSet): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer 12345678910111213141516171819202122232425262728293031323334353637383940414243# APIViewclass BookListAPIView(APIView): def get(self, request): books = BookInfo.objects.all() serializer = BookInfoSerializer(books, many=True) return Response(serializer.data) def post(self, request): serializer = BookInfoSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) # GenericAPIView + Mixin 实现接口class BookInfoView(GenericAPIView, CreateModelMixin, ListModelMixin): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer def get(self, request): return self.list(request) def post(self, request): return self.create(request)class BookInfoDetailView(GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer def get(self, request, pk): return self.retrieve(request, pk) def put(self, request, pk): return self.update(request, pk) def delete(self, request, pk): return self.destroy(request, pk) # GenericAPIView + Mixin 实现合成from rest_framework.generics import ListCreateAPIView, RetrieveUpdateDestroyAPIViewclass BookInfoView(ListCreateAPIView): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializerclass BookInfoDetailView(RetrieveUpdateDestroyAPIView): queryset = BookInfo.objects.all() serializer_class = BookInfoSerializer 自定义行为123456from rest_framework.decotators import action@action(method=[&#x27;get&#x27;], detail=False) # 使用这个装饰器才能在路由中加入本方法def latest(self, request): book = BookInfo.objects.latest(&#x27;id&#x27;) serializer = self.get_serializer(book) return Response(serializer.data) 重定向：1return redirect(reverse(&#x27;users:index&#x27;)) Cookie：12345def cookie(request): response = HttpResponse(&#x27;ok&#x27;) response.set_cookie(&#x27;name&#x27;, &#x27;zz&#x27;) response.delete_cookie(&#x27;name&#x27;) return response Session:123def session(request): request.session[&#x27;name&#x27;] = &#x27;zz&#x27; # 设置session return HttpResponse(&#x27;session&#x27;) 装饰器123456@method_decorator(decorator, name=&#x27;get&#x27;)# 装饰get方法，如果是dispatch装饰所有方法class DemoView(ModelViewSet): # 指定查询集 queryset = BookInfo.objects.all() serializer = BookInfoSerializer 12345serializer = BookInfoSerializer(data=data)serializer.is_valid(raise_exception=True) # 验证数据是否合法serializer.errors() # 返回验证错误信息serializer.validated_data() # 返回验证后的数据serializer.save() # 保存数据 models.py定义各类模型 1234567891011121314class BookInfo(models.Model): btitle = models.CharField(max_length=20, verbose_name=&#x27;名称&#x27;) bpub_date = models.DateField(verbose_name=&#x27;发布日期&#x27;, null=True) bread = models.IntegerField(default=0, verbose_name=&#x27;阅读量&#x27;) bcomment = models.IntegerField(default=0, verbose_name=&#x27;评论量&#x27;) is_delete = models.BooleanField(default=False, verbose_name=&#x27;逻辑删除&#x27;) class Meta: db_table = &#x27;bookinfo&#x27; verbose_name = &#x27;图书&#x27; verbose_name_plural = verbose_name def __str__(self): return self.btitle 数据库迁移 python manage.py makemigrations serializers.py1234567891011class BookInfoModelSerializer(serializers.ModelSerializer): class Meta: model = BookInfo # 指定映射字段 fields = &#x27;__all__&#x27; &quot;&quot;&quot;BookInfoSerializer(instance, data)传参给instance表示序列化,传给data表示反序列化serializer = BookInfoSerializer(instace = book)serializer.data 获取到序列化后的数据&quot;&quot;&quot; 12345678910111213141516171819202122# 上下等价class BookInfoSerializer(serializers.Serializer): id = serializers.IntegerField(label=&#x27;ID&#x27;,read_only=True) btitle = serializers.CharField(max_length=20, label=&#x27;名称&#x27;) bpub_date = serializers.DateField(label=&#x27;发布日期&#x27;) bread = serializers.IntegerField(label=&#x27;阅读量&#x27;) bcomment = serializers.IntegerField(label=&#x27;评论量&#x27;) is_delete = serializers.BooleanField(label=&#x27;逻辑删除&#x27;, required=False) image = serializers.ImageField(label=&#x27;图片&#x27;, required=False) hero = serializers.PrimaryKeyRelatedField(read_only=True) # 仅用于序列化输出 def validate_btitle(self, value): if &#x27;django&#x27; not in value: raise serializers.ValidationError(&#x27;图书不是关于Django的&#x27;) return value def validate(self, attrs): bread = attrs[&#x27;bread&#x27;] bcomment = attrs[&#x27;bcomment&#x27;] if bread &lt; bcomment: raise serializers.ValidationError(&#x27;阅读量小于评论量&#x27;) return attrs urls.py整个项目： 123456urlpatterns = [ path(r&#x27;^admin/&#x27;, admin.site.urls), path(&#x27;api-auth/&#x27;,include(&#x27;rest_framework.urls&#x27;)), path(r&#x27;^users/&#x27;, include(&#x27;users.urls&#x27;, namespace=&#x27;users&#x27;)), # 把users子应用的所有路由添加到根路由中，添加命名空间，为反向解析添加限制 url(r&#x27;^&#x27;, include(&#x27;books.urls&#x27;))] 每个app： 定义当前子应用下的所有路由 1234567891011# users app Django# 正则，视图函数名urlpatterns = [ path(r&#x27;^index/(?P&lt;city&gt;[a-z]+)/(?P&lt;year&gt;\\d&#123;4&#125;)/$&#x27;,views.index, name=&#x27;&#x27;), # 别名 # 类视图 path(r&#x27;^index/$&#x27;, views.Index.as_view())]# 定义路由后的&#x27;/&#x27; 要加上# ^：这个字符在正则表达式中表示字符串的开始。使用^确保URL模式匹配从URL的开始处进行。# $：这个字符在正则表达式中表示字符串的结束。使用$确保URL模式匹配到URL的末尾处。# 利用括号给正则分组，并利用?P&lt;&gt;为正则指定参数 1234# drf 只能在视图集时使用router = DefaultRouter()router.register(r&#x27;books&#x27;, views.BookInfoView)urlpatterns += router.urls # 拼接生成的路由 12345678# 当使用Viewset时,后续替换用上面的urlpatterns = [ path(r&#x27;^book/(?P&lt;pk&gt;\\d+)/$&#x27;,views.BookViewset.as_view(&#123;&#x27;get&#x27;:&#x27;retrieve&#x27;, &#x27;put&#x27;:&#x27;update&#x27;,&#x27;delete&#x27;:&#x27;destroy&#x27;&#125;), name=&#x27;&#x27;), # 别名 # 类视图 path(r&#x27;^book/$&#x27;, views.BookViewset.as_view(&#123;&#x27;get&#x27;:&#x27;list&#x27;, &#x27;post&#x27;:&#x27;create&#x27;&#125;)) url(r&#x27;^book/latest/$&#x27;, views.BookViewset.as_view(&#123;&#x27;get&#x27;:&#x27;latest&#x27;&#125;)) url(r&#x27;^book/(?P&lt;pk&gt;\\d+)/read/$&#x27;, views.BookViewset.as_view(&#123;&#x27;put&#x27;:&#x27;read&#x27;&#125;))] apps.pysettings.py123456789101112INSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;rest_framework&#x27;, &#x27;user.apps.UserConfig&#x27;, # 注册子应用] 1ALLOWED_HOSTS = [] # 允许访问的域名 123456DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;zq_new_notify&#x27;, &#125;&#125; 12345# 配置静态文件加载存储目录# 静态文件简单使用，一般不用STATICFILES_DIR = [ os.path.join(BASE_DIR, &#x27;static_files&#x27;)] 123456789101112# redis配置CACHES = &#123; &#x27;default&#x27;: &#123; &#x27;BACKEND&#x27;: &#x27;django_redis.cache.RedisCache&#x27;, &#x27;LOCATION&#x27;:&#x27;redis://127.0.0.1:6379/1&#x27;, &#x27;OPTIONS&#x27;: &#123; &#x27;CLIENT_CLASS&#x27;:&#x27;django_redis.client.DefaultClient&#x27;, &#125;, &#125;&#125;SESSION_ENGINE = &#x27;django.contrib.sessions.backends.cache&#x27;SESSION_CACHE_ALIAS = &#x27;default&#x27;","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"Web后端","slug":"Web后端","permalink":"http://blog.zymatrix.top/tags/Web%E5%90%8E%E7%AB%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.zymatrix.top/tags/Python/"}]},{"title":"并发Bugs","slug":"JYYOS并发bugs","date":"2024-04-08T16:00:00.000Z","updated":"2024-08-12T09:20:11.007Z","comments":true,"path":"2024/04/09/JYYOS并发bugs/","link":"","permalink":"http://blog.zymatrix.top/2024/04/09/JYYOS%E5%B9%B6%E5%8F%91bugs/","excerpt":"","text":"并发Bug笔记内容来自蒋炎岩老师的OS课程以及slides 死锁AA-Deadlockunlock之前出现中断，然后lock()，此时会出现spin ABBA-Deadlock（最常见） T-&gt;lock(A)-&gt;lock(B) T-&gt;lock(B)-&gt;lock(A) 当一个线程lock AB后才能执行，但如果T1lock(A),T2lock(B)，此时无法满足条件，死锁 如何避免死锁 Lock ordering 任意时刻系统中的锁都是有限的 给所有锁编号 (Lock Ordering) 严格按照从小到大的顺序获得锁 Proof (sketch) 任意时刻，总有一个线程获得 “编号最大” 的锁 这个线程总是可以继续运行 数据竞争(Data Race)不同的线程同时访问同一内存，且至少有一个是写 例子： Case 1: 上错了锁 12345678910void T_1() &#123; spin_lock(&amp;A); sum++; spin_unlock(&amp;A); &#125; void T_2() &#123; spin_lock(&amp;B); sum++; spin_unlock(&amp;B); &#125; Case 2: 忘记上锁 12345678void T_1() &#123; spin_lock(&amp;A); sum++; spin_unlock(&amp;A); &#125; void T_2() &#123; sum++; &#125; 原子性&#x2F;顺序违反“ABA”: 代码被别人 “强势插入” 即便分别上锁 (消除数据竞争)，依然是 AV Diablo I 里复制物品的例子 Therac-25 中 “移动 Mirror + 设置状态” “BA”: 事件未按预定的顺序发生 例子：concurrent use-after-free GhostRace (USENIX Sec’24) 应对并发Bugs死锁我们可以在运行时检查一切明确的 Specification！ 严格按照编号执行 运行时lockorder的检查(lockdep) ThreadSanitizer: 运行时的数据竞争检查 应对死局: Sanitizers现代复杂软件系统必备的支撑工具 AddressSanitizer(asan);(paper): 非法内存访问 Buffer (heap&#x2F;stack&#x2F;global) overflow, use-after-free, use-after-return, double-free, …; 没有 KASAN, Linux Kernel 的质量&#x2F;安全性直接崩盘 ThreadSanitizer (tsan): 数据竞争 KCSAN: Concurrency bugs should fear the big bad data-race detector MemorySanitizer (msan), UBSanitizer (ubsan), … SpecSanitizer: 基于 AI&#x2F;LLM 的 “specification 检查” 就等你来开发了 应对死线：防御性编程Full Sanitizer 很难实现 不如换一种思路 我们可以 “编程”！ Best-effort is better than no-effort! 不实现 “完整” 的检查 (允许存在误报&#x2F;漏报) 但实现简单、非常有用——而且有惊喜 我们不是一直都在写 assertions 吗？ Peterson 算法：assert(nest == 1); 链表：assert(u-&gt;prev-&gt;next == u); spinlock: if (holding(&amp;lk)) panic(); Buffer Overrun检查 Canary: “牺牲” 内存单元，预警 memory error 例如：Stack Guard（栈溢出），缓冲区溢出 低配版Lockdep高配版 lockdep 太复杂？ 统计当前的 spin count 如果超过某个明显不正常的数值 (100,000,000) 就报告 你感觉到 “hang” 了 1234567int spin_cnt = 0;while (xchg(&amp;lk, ❌) == ❌) &#123; if (spin_cnt++ &gt; SPIN_LIMIT) &#123; panic(&quot;Spin limit exceeded @ %s:%d\\n&quot;, __FILE__, __LINE__); &#125;&#125; 配合调试器和线程 backtrace 一秒诊断死锁 低配版AddressSanitizerL1 内存分配器的 specification 已分配内存 S&#x3D;[ℓ0,r0)∪[ℓ1,r1)∪…S&#x3D;[ℓ0,r0)∪[ℓ1,r1)∪… kalloc(s) 返回的 [ℓ,r)[ℓ,r) 必须满足 [ℓ,r)∩S&#x3D;∅[ℓ,r)∩S&#x3D;∅ 1234567891011// allocationfor (int i = 0; (i + 1) * sizeof(u32) &lt;= size; i++) &#123; panic_on(((u32 *)ptr)[i] == MAGIC, &quot;double-allocation&quot;); arr[i] = MAGIC;&#125;// freefor (int i = 0; (i + 1) * sizeof(u32) &lt;= alloc_size(ptr); i++) &#123; panic_on(((u32 *)ptr)[i] == 0, &quot;double-free&quot;); arr[i] = 0;&#125; 低配版ThreadSanitizer直接观测状态影响 12345678910// Suppose x is lock-protected...int observe1 = x;delay();int observe2 = x;assert(observe1 == observe2);... Effective data-race detection for the Kernel (OSDI’10) SemanticSanitizer两个看似平常的检查 检查整数是否在某个范围 12345#define CHECK_INT(x, cond) \\ (&#123; panic_on(!((x) cond), \\ &quot;int check fail: &quot; \\ #x &quot; &quot; #cond); \\ &#125;) 检查指针是否位于堆区 123#define CHECK_HEAP(ptr) \\ (&#123; panic_on(!IN_RANGE((ptr), heap)); &#125;)","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://blog.zymatrix.top/tags/OS/"}]},{"title":"The Problems of Using OpenEuler WSL","slug":"The Problems of Using OpenEuler WSL","date":"2024-03-08T16:00:00.000Z","updated":"2024-08-12T09:20:23.533Z","comments":true,"path":"2024/03/09/The Problems of Using OpenEuler WSL/","link":"","permalink":"http://blog.zymatrix.top/2024/03/09/The%20Problems%20of%20Using%20OpenEuler%20WSL/","excerpt":"","text":"The Problems of Using OpenEuler WSL记录一下在OS课上使用OpenEuler WSL遇到的坑 OpenEuler 官方下载WSL系统的脚本十分炸裂，能在x86架构的机器上安装MIPS架构的结果，建议避雷，使用微软商店的软件包下载 本次实验的要求： 1.向OpenEuler系统，或者OpenKylin系统中，增加一个系统调用&#x2F;或内核模块，鼓励程序逻辑的多样化2.撰写一个应用测试程序调用该系统调用&#x2F;测试该内核模块3.使用trace&#x2F;ptrace&#x2F;strace,或类似的系统跟踪工具来对该测试程序进行跟踪调试 内核问题问题描述实验环境是在WSL2下使用OpenEuler，CentOS套壳 借鉴了一些网络上的代码后，对源码进行编译，下面是Makefile文件内容 123456789obj-m:=syscall.oPWD:= $(shell pwd)KERNELDIR:= /lib/modules/$(shell uname -r)/buildEXTRA_CFLAGS= -O0all: make -C $(KERNELDIR) M=$(PWD) modulesclean: make -C $(KERNELDIR) M=$(PWD) clean make后报错： &#x2F;lib&#x2F;modules&#x2F;5.15.146.1-microsoft-standard-WSL2&#x2F;build: No such file or directory. 搜索后可知，WSL2的内核是修改过的，无法使用CentOS上游的内核头文件和modules文件，因此，我们需要手动编译并安装一个版本。 解决步骤下载对应版本内核代码首先查看系统内核版本 1uname -r 5.15.146.1-microsoft-standard-WSL2 到WSL git仓库，找到对应的release 1git clone https://github.com/microsoft/WSL2-Linux-Kernel 编译和安装123cd WSL2-Linux-KernelLOCALVERSION= make KCONFIG_CONFIG=Microsoft/config-wsl -j8sudo LOCALVERSION= make KCONFIG_CONFIG=Microsoft/config-wsl modules_install -j8 这个阶段会遇到较多报错，由于我使用的是CentOS和网络上大多资料使用的Ubuntu不同，因此需要安装的依赖也不一样，这里就直接放出一部分报错和安装的全部命令 fatal error: openssl&#x2F;bio.h: No such file or directoryfatal error: libelf.h: No such file or directoryBTF: .tmp_vmlinux.btf: pahole (pahole) is not available Failed to generate BTF for vmlinuxTry to disable CONFIG_DEBUG_INFO_BTFWarning: ‘make modules_install’ requires depmod. Please install it. 1sudo dnf install bison flex openssl-devel elfutils-libelf-devel dwarves kmod 安装完这些以后，再重新运行上面的指令，这个时候就能发现没有问题了。 insmod问题问题描述当编译成功后，需要加载内核模块 1sudo insmod randomizer.ko 这个时候终端抛出问题： ERROR: could not insert module mymodule.ko: Invalid parameters 但是一番搜索后发现根本没有解决我的问题的方法，这时候查看日志 1dmesg | tail 可以发现出现了这样的错误： BPF:[xxxxx] Invalid name_offset:xxxxxx failed to validate module [mymodule] BTF: -22 在一篇博客中有这样的记录： “rocky linux 9上面，内核编译设置默认打开了DEBUG_INFO_BTF_MODULES，这样所有模块里面都带有BTF信息。 运行时内核的BTF这个机制，如果模块缺少BTF信息（ELF的BTF段）那可以加载成功，但如果BTF的版本不匹配就拒绝加载。 使用源码自己编译内核时，虽然内核源码是一样的但生成的BTF还是不匹配的。 这样自己使用内核源码目录（ 不是系统的&#x2F;lib&#x2F;modules&#x2F;uname -r&#x2F;build ） 编译一个模块出来， 在rocky linux的官方内核系统里面就没法使用了， modprobe 会返回“ bpf invalid name btf -22”错误。 但通常编译模块时，如果make bzImage 之后make clean 删掉vmlinux 后 编译模块时找不到vmlinux就不会BTF信息，通常还是可以正常使用的。 但有的模块使用了 register_btf_kfunc_id_set 函数 向系统注册BTF函数的，这种一定要求BTF 信息的就不行了。 反正这个BTF这个东西，自己编译第三方模块时最好就不要把BTF编译进去了，不然不同的内核小版本都没法兼容，即使同样的内核源码也是不行的。” 可以看到其实是BTF的问题，联系到上面出现的一个报错： BTF: .tmp_vmlinux.btf: pahole (pahole) is not available Failed to generate BTF for vmlinuxTry to disable CONFIG_DEBUG_INFO_BTFWarning: ‘make modules_install’ requires depmod. Please install it. 我们就要在这上面下文章，一开始，我们借助下载dwarves解决了这个报错 而在这里，我们就需要去disable CONFIG_DEBUG_INFO_BTF 因此引出一种可行办法，也就是： make menuconfig 配置内核，生成.config文件 然后在.config文件中修改 CONFIG_DEBUG_INFO_BTF&#x3D;n 但是由于一些奇怪的原因，我无法使用 make menuconfig，于是，我借助了另一种思路 删掉vmlinux 后 编译模块时找不到vmlinux就不会BTF信息 实际上是阴差阳错地，我在WSL2-Linux-Kernel目录下执行make clean，清除了所有*.o文件，然后make重新编译了一次，这时候神奇的事情发生了，尽管我仍然没有.config文件，但是当我使用命令 1sudo insmod randomizer.ko 并没有任何报错出现，这时候再用 1dmesg | tail 查看内核日志和分配给模块的主设备号时 BPF:[xxxxx] Invalid name_offset:xxxxxx failed to validate module [mymodule] BTF: -22 module has been loaded: xxx BTF的问题没有消失，但是我们绕开了 接着创建设备文件 1sudo mknod /dev/mymodule c xxx 0 运行测试程序就可以发现成功了。 参考资料： WSL 运行make提示&#x2F;lib&#x2F;modules&#x2F;xxx&#x2F;build: No such file or directory. Stop.错误解决办法 Btf版本不匹配导致内核模块加载失败的问题 kernel 源码升级","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://blog.zymatrix.top/tags/OS/"},{"name":"Linux Kernel","slug":"Linux-Kernel","permalink":"http://blog.zymatrix.top/tags/Linux-Kernel/"}]},{"title":"2023年小记","slug":"2023","date":"2023-12-31T16:00:00.000Z","updated":"2024-08-12T09:18:51.088Z","comments":true,"path":"2024/01/01/2023/","link":"","permalink":"http://blog.zymatrix.top/2024/01/01/2023/","excerpt":"","text":"新年伊始，日历的数字又换了一代，满大街都是人，狂欢显得他们对帝国的危机没有表现出任何兴奋或是担忧的情绪，仿佛日历变化或是口头言语就能把古旧的社会简单化新，时间在他们那里是不连续的。 “每天早上，当我在阴暗的天空下再次醒来时，我都会觉得对我来说是新年。”——葛兰西","categories":[],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"WEB Security","slug":"web","date":"2023-08-10T16:00:00.000Z","updated":"2024-08-12T09:20:32.430Z","comments":true,"path":"2023/08/11/web/","link":"","permalink":"http://blog.zymatrix.top/2023/08/11/web/","excerpt":"","text":"[toc] 0x00 信息整理来源博客sunny_忧郁小猫猫 - 博客园 (cnblogs.com) 0x01 基础知识 Request请求数据包数据格式 请求行：请求类型&#x2F;请求资源路径、协议的版本和类型 请求头：一些键值对，浏览器与web服务器之间都可以发送，特定的某种含义 空行：请求头与请求体之间用一个空行隔开； 请求体：要发送的数据(一般post提交会使用)；例：user&#x3D;123&amp;pass&#x3D;123 #请求行 请求行由三个标记组成：请求方法、请求URL和HTTP版本，它们用空格分享。 例如：GET /index.html HTTP/1.1 HTTP 规划定义了8种可能的请求方法： GET：检索URL中标识资源的一个简单请求 HEAD：与GET方法相同，服务器只返回状态行和头标，并不返回请求文档 POST：服务器接受被写入客户端输出流中的数据的请求 PUT：服务器保存请求数据作为指定URL新内容的请求 DELETE：服务器删除URL中命令的资源的请求 OPTIONS：关于服务器支持的请求方法信息的请求 TRACE：web服务器反馈Http请求和其头标的请求 CONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理 123456789101112131415161718192021222324252627- ``` #请求头 由关键字/值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。 HOST: 主机或域名地址 Accept：指浏览器或其他客户可以接爱的MIME文件格式。Servlet可以根据它判断并返回适当的文件格式。 User-Agent：是客户浏览器名称 Host：对应网址URL中的Web名称和端口号。 Accept-Langeuage：指出浏览器可以接受的语言种类，如en或en-us，指英语。 connection：用来告诉服务器是否可以维持固定的HTTP连接。http是无连接的，HTTP/1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接 Cookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。 Referer：表明产生请求的网页URL。如比从网页/icconcept/index.jsp中点击一个链接到网页/icwork/search，在向服务器发送的GET/icwork/search中的请求中，Referer是http://hostname:8080/icconcept/index.jsp。这个属性可以用来跟踪Web请求是从什么网站来的。 Content-Type：用来表名request的内容类型。可以用HttpServletRequest的getContentType()方法取得。 Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1. Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式。 #空行 最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。 12345- ``` #请求数据 使用POST传送，最常使用的是 Content-Type 和 Content-Length 头标。 Response请求数据包数据格式 一个响应由四个部分组成；状态行、响应头标、空行、响应数据。 1.状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔 2.响应头标：包含服务器类型、日期、长度、内容类型等 3.空行：响应头与响应体之间用空行隔开 4.响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面 HTTP响应码： 1xx：信息，请求收到，继续处理 2xx：成功，行为被成功地接受、理解和采纳 3xx：重定向，为了完成请求，必须进一步执行的动作 4xx：客户端错误 5xx：服务器错误 200 存在文件 403 存在文件夹 3xx 均可能存在 404 不存在文件及文件夹 500 均可能存在 #响应头标 像请求头标一样，它们指出服务器的功能，标识出响应数据的细节。 #空行 最后一个响应头标之后是一个空行，发送回车符和退行，表明服务器以下不再有头标。 #响应数据 HTML文档和图像等，也就是HTML本身。 0x02 BurpSuite使用使用大全 BurpSuite使用大全（详解）_Alphabets26的博客-CSDN博客 mozhe CTF题目解析 改变Referer实现来源页伪造 使用burpsuite实现多次伪造ip（暴力破解）：首先查找php获取ip地址的方式，也就是 X-Forwarded-For，然后在数据包里面加上这行命令，对ip进行右键send to intruder，在右侧能看到add变量的选项，将attack type 修改为cluster bomb，然后将payloads的payload type修改为numbers，设置范围，再发送数据包，start attack，然后等待，即可。 改变User-Agent实现伪造浏览器信息 浏览器中发送数据包的方式GET和POST的区别：GET与POST的区别？ - 简书 (jianshu.com) 由于GET能发送的数据大小有限制，长度不足，所以会出现”Request-URL Too Long”的情况，这个时候可以利用burpsuite来修改GET为POST传输数据 0x03 搭建安全拓展笔记第3天：基础入门-搭建安全拓展 web中间件漏洞Web中间件常见漏洞总结 | lyxhh (lxhsec.com) 基于中间件的靶场vulhub Vulhub靶场搭建教程 - Zovt - 博客园 (cnblogs.com) 0x04 WEB 源码拓展第4天：基础入门-WEB源码拓展 5. 语言与框架 — Web安全学习笔记 1.0 文档 源码获取：搜索、淘宝咸鱼、第三方源码站（例如菜鸟源码） 0x05 系统及数据库判断服务器操作系统Nmap参考指南(Man Page) https://www.cnblogs.com/php09/p/10530057.html","categories":[{"name":"hacker","slug":"hacker","permalink":"http://blog.zymatrix.top/categories/hacker/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://blog.zymatrix.top/tags/CTF/"}]},{"title":"汇编语言","slug":"汇编语言","date":"2023-06-17T16:00:00.000Z","updated":"2024-08-12T09:20:49.253Z","comments":true,"path":"2023/06/18/汇编语言/","link":"","permalink":"http://blog.zymatrix.top/2023/06/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"","text":"一、mul,div,and,or ,shl,shr,inc,dec指令，中断int 1234mul:8位乘法结果默认放在AX中，16位乘法，结果高位默认放在DX，低位在AXdiv:除数为8位，则AL存商，AH存余数；除数为16位，AX存商，DX存余数xchg op1,op2 ;交换op1和op2的值lea reg,mem(Label) 将变量名或标号的偏移地址送给reg 12345and:在二进制下一位位对比，两位皆为1则结果也为1，其他的皆为0or:二进制下，有一个1就为1，其他的都是0and和or运算常常用于ASCII码大小写转换and al,11011111B 转化为大写字母or al,00100000B 转换为小写字母 1234都是对无符号数的逻辑移位。算术移位是对有符号数的移位，算数移位时要把最前面的符号数不变shl al,1 表示左移一位，相当于乘以2shr al,1 表示右移一位，相当于除以2nop:占位符，占据一个字节 1int 0 引发内中断，相当于跳转调用0号中断处理程序 12inc si si++dec si si-- 总线地址总线：宽度为N根，寻址能力就为2^N bit 数据总线：8086数据总线宽度为16根，一次传输1byte(2 bit)（16位） 二、寄存器1.ds寄存器，段地址、偏移地址、物理地址 物理地址 &#x3D; 段地址左移一位 + 偏移地址 DS（Data Segment) 通常用来存储段地址 段前缀：用于显式地指出内存单元的段地址的”ds:””cs:””ss:””es:”，一般来说默认为ds 注意，赋值给DS不能直接用数字赋值，而应该先赋值给AX，再赋值给DS 2.CS-IP代码段寄存器，jmp,jcxz指令 CS（code segment代码段寄存器）表示的是段地址，IP（指令指针寄存器，Instruction Pointer）表示的是偏移地址，在debug时可以用r命令来修改CS：IP的值，来修改内存中的值。在计算机中，代码和数据是一样的。 jmp 1000:3 表示跳转到地址为1000:3的地方，即修改了CS:IP，jmp bx表示讲IP的值修改为bx，CS的值不变。 jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，其功能相当于 1if(cx == 0) jmp short 标号 3.SS-SP寄存器，栈的push,pop指令 push和pop 栈的基本操作，SS(stack segment),SP(stack point) SS:SP始终指向的是栈顶元素，push和pop指令能够修改SP的值，push使SP-2,pop使SP+2，SS:SP表示的是栈的地址。 4.bp,si,di寄存器，寻址方式以及其他的寄存器 寻址方式：[bx+idata] [bx+si] [bx+di] [bx+si+idata] [bx+di+idata] 注意：方括号内只能用bx,si,di和数字，si和di不能同时出现 1234567891011直接寻址：[idata] 寄存器间接寻址：[bx] [si] [di] [bp] 寄存器相对寻址：[bx+idata] 用于结构体:[bx].idata 用于数组：idata[si] 用于二维数组：[bx][idata]基址变址寻址：[bx+si/di] [bp+si/di] 用于二维数组：[bx][si]相对基址变址寻址：[bx+si+idata] 用于结构中的数组项：[bx].idata[si] 用于二维数组：idata[bx][si] 只要在[ ]中使用bp，而指令中没有显性地给出段地址，段地址就默认在SS中 5.标志位寄存器ZF,PF,SF,CF,OF,DF和串传送指令pushf和popf ZF: 零标志位，记录相关指令执行后，判断结果是否为0，如果为0，则ZF &#x3D; 1,不为0则ZF &#x3D; 0; PF: 奇偶标志位，记录相关指令执行后，结果的所有Bit位中1的个数是否为偶数，如果是偶数则pf &#x3D; 1,奇数则为0 SF:符号标志位，记录相关指令执行后，结果是否为负，如果为负则sf &#x3D; 1,否则为0 CF：进位标志位，进行无符号数运算时 ，记录运算结果的最高有效位的进位值，或从更高位的借位值 OF：溢出标志位，对有符号数运算的溢出标志，如果发生溢出则OF &#x3D; 1,没溢出则OF &#x3D; 0 DF：方向标志位，在串处理指令中，控制每次操作后si,di的增减， df &#x3D; 0 每次操作后si、di递增 df &#x3D;1 每次操作后si、di递减 串传送指令： movsb : 相当于 1mov es:[di],byte ptr ds:[si] ;8086中没有这样的指令，仅作描述 将ds:si指向的内存单元中的字节送入es:di中，然后根据df的值，将si和di递增或递减 类似的，movsw的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据df的值，将si和di递增2或递减2 这两个指令常和rep配合使用 12345rep movsb s:movsb loop s;这两者等价，也就是说rep会根据cx的值重复执行后面的指令 pushf的功能是将标志寄存器的值压栈，popf则是从栈中弹出数据，送入标志寄存器，用以直接访问标志寄存器 6.条件判断语句cmp,je,ja,jb,adc,sbb adc:带进位加法指令，adc ax,bx 表示 (ax) &#x3D; (ax) + (bx) + CF sbb:带借位减法指令, sbb ax,bx 表示(ax) &#x3D; (ax) - (bx) - CF cmp：比较指令，相当于减法指令，只是不保存结果，而是对标志位寄存器产生影响 123456789101112131415161718192021222324252627282930313233343536373839其实，我们通过cmp指令执行后，相关标志位的值就可以看出比较的结果.cmp ax, bx如果(ax) = (bx) 则(ax) - (bx) = 0, 所以：zf = 1 ;如果(ax) ≠ (bx) 则(ax) - (bx) ≠ 0, 所以：zf = 0 ;如果(ax) &lt; (bx) 则(ax) - (bx) 将产生借位, 所以：cf = 1 ;如果(ax) ≥ (bx) 则(ax) - (bx) 不必借位, 所以：cf = 0 ；如果(ax) ＞ (bx) 则(ax) - (bx) 既不必借位，结果也不为0, 所以：cf = 0并且 zf = 0 ;如果(ax) ≤ (bx) 则(ax) - (bx) 既可能借位，结果可能为0, 所以：cf = 1 或 zf = 1 现在我们可以看出比较指令的设计思路，即：通过做减法运算，影响标志寄存器，标志寄存器的相关记录位记录了比较的结果. 反过来：指令cmp ax, bx的逻辑含义是比较ax和bx中的值，如果执行后：zf = 1，说明(ax) = (bx)zf = 0，说明(ax) ≠ (bx)cf = 1，说明(ax) &lt; (bx)cf = 0，说明(ax) ≥ (bx)cf = 0 且 zf = 0，说明(ax) &gt; (bx)cf = 1 或 zf = 1，说明(ax) ≤ (bx)以cmp ah, bh为例，总结一下cpu执行cmp指令后，sf和of的值是如何来说明比较的结果的.1) 如果sf = 1，而of = 0of = 0，说明没有溢出，逻辑上真正结果的正负 = 实际结果的正负;因 sf = 1，实际结果为负，所以逻辑上真正的结果为负，所以 (ah) &lt; (bh) .2) 如果sf = 1，而 of = 1of = 1，说明有溢出，逻辑上真正的结果的正负 ≠ 实际结果的正负；因 sf = 1， 实际结果为负.实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负. 简单分析就可以看出，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正.这样，sf = 1，of = 1，说明了 (ah) &gt; (bh).3) 如果sf = 0，而 of = 1of = 1，说明溢出，逻辑上真正结果的正负 = 实际结果的正负;因sf = 0，实际结果为非负. 而 of = 1说明溢出，则结果为非0，所以，实际结果为正.实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负，简单分析一下，就可以看出，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负.这样，sf = 0，of = 1，说明了 (ah) &lt; (bh).4) 如果 sf = 0，而of = 0of = 0，说明没有溢出，逻辑上真正的结果的正负 = 实际结果的正负；因 sf = 0，实际结果非负，所以逻辑上真正的结果非负，所以 (ah) ≥ (bh) . 利用cmp指令进行比较，改变标志寄存器的值，再用条件转移指令进行转移 三、编写程序1.循环语句loop，call和ret指令写函数，call far ptr和retf指令，本质是栈 loop的循环次数由CX的值来确定 call 调用的函数要一般写在int后面，防止第二次调用 1234567call指令会进行两步操作，1）将当前的IP或CS和IP入栈 push ip2）转移 jmp near ptr 标号call 指令入栈的IP为call后面的指令的地址 12345678call far ptrpush CSpush IPjmp far ptr 标号类似地，入栈的CS和IP都是call后面的指令的地址 ret返回的是call的下一行指令，且ret指令使用的是栈中的内容，修改IP的内容，从而实现近转移，即段内返回，相当于pop ip 而retf修改的是CS和IP的内容，实现远转移,相当于pop IP pop CS 同时，使用这两个指令会改变sp的值（sp+2) call 还有call ax的用法，即先把原IP入栈，再改变IP为ax 2.代码段、数据段、栈段、dup指令 db(define byte):字节型，8位 dw(define word)：字型，16位 dd(define double word):双字型，32位 这些相当于c语言里面的定义数据类型，注意，在十六进制里，表示数字不能以字母为开头，要在前面加上0，在数据定义之后可以用start伪指令来表示程序的开始处，并用end start来表示结束 dup : 123db 3 dup(0) ;定义了3个字节，值都为0db 3 dup(0,1,2) ;定义了9个字节，即重复0,1,2三次db 3 dup(&#x27;abc&#x27;,&#x27;ABC&#x27;) ;定义了18个字节 类似的，dw,dd都可以这样用 3.offset指令,jmp short、far,dword ptr等跳转指令 offset的功能是取得标号的偏移地址 123456789101112131415ptr可以用来表示指针转换，把数据的类型转换jmp short s ;段内短转移，对ip的修改范围为-128~127（单位是字节），jmp跳转实际上是计算偏移地址差，然后加上这个差（向上跳转差是负数）jmp near ptr s ;段内近转移，对ip的修改范围为-32768~32767jmp far ptr s ;段间转移，也称远转移，修改的是CS和IP的值jmp word ptr 内存单元地址 ;（段内转移）功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出，修改的是IP的值jmp dword ptr 内存单元地址 ;（段间转移）功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出，修改的是CS和IP的值例如：mov ax,0123hmov ds:[0],axmov word ptr ds:[2],0 ;这里使用word ptr是表示传入的0是一个字的类型jmp dword ptr ds:[0]执行后， (CS)=0,(IP)=0123h,也就是高地址的ds:[2]的值赋给了CS,低地址的ds:[0]赋给了IP 四、中断1.操作显存数据主存储器地址空间大小为640K，地址从00000到9FFFF，其他各类ROM地址空间256KB，地址从C0000到FFFFF。 显存地址空间大小为128K，地址是从A0000到BFFFF，其中B8000h~BFFFFh共32k的空间，是80*25（25行80列）的彩色字符模式第0页的显示缓冲区。 每个位置需要两个字节（一个字），每一行就有160（A0H）个字节。 对每个位置的两个字节，低位字节存储的是要显示符号的ASCII，高位字节存储的是显示属性的字节 （如图是高字节的属性） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950; 屏幕中间显示三行彩色字assume cs:code, ds:data, ss:stack data segment db &#x27;Welcome to masm!&#x27; db 2,36,113 ;字符属性代码(十进制) data ends stack segment db 16 dup(0)stack ends code segmentstart: mov ax,data mov ds,ax mov bx,0 mov di,16 mov ax,stack mov ss,ax mov sp,0 mov ax,0b800h mov es,ax mov si,160*12+32*2;将字符输出到屏幕中央 ;(显示器可以显示25行，每行80个字符，每个字符两个字节) mov cx,3s1: mov dh,ds:[di] ;高位放属性 push cx mov cx,16s0: mov dl,ds:[bx] ;低位放ASCⅡ码 mov es:[si],dx ;放入缓冲区 add si,2 inc bx ;下一个字符 loop s0 pop cx inc di add si,80h ;移动到下一行 sub bx,bx ;字符串从头开始 loop s1 ;循环3次,输出三行 mov ax,4c00h int 21hcode endsend start 2.标号标号既可以用于代码段，也可以用于数据段，同时用offset+标号来取偏移地址 或者用以下表示方法，成为数据标号，数据标号标记了存储数据的单元的地址和长度，它不同于仅仅表示地址的地址标号 3.直接定址表 数据的直接定址表：建立一张表，表格依次存储字符 “0” ~ “F”，我们可以通过数值 0~15 直接查找到对应的字符。 12345678910111213141516171819202122232425262728293031;用 al 传送要显示的数据showbyte: jmp short show table db &#x27;0123456789ABCDEF&#x27; ;字符表 show: push bx push es mov ah,al shr ah,1 shr ah,1 shr ah,1 shr ah,1 ;右移 4 位，ah 中得到高 4 位的值 and al,00001111b ;al 中为低 4 位的值 mov bl,ah mov bh,0 mov ah,table[bx] ;用高 4 位的值作为相对于 table 的偏移，取得对应的字符 mov bx,0b800h mov es,bx mov es:[160*12+40*2],ah mov bl,al mov bh,0 mov al,table[bx] ;用低 4 位的值作为相对于 table 的偏移，取得对应的字符 mov es:[160*12+40*2+2],al pop es pop bx ret 子程序中，在数值 015 中和字符 “0”“F” 之间建立的映射关系位：以数值 N 为 table 表中的偏移，可以找到对应的字符。 代码的直接定址表：可以在直接定址表中存储子程序的地址，方便地实现不同子程序的调用。 4.中断及其处理中断向量表：每个入口地址占用四个字节，保存IP和CS，总共1024个字节 0号中断由除法除以0触发，执行后相当于int 0 中断向量表起始地址为0000：0000 中断程序在其他位置，可由中断向量表寻址跳转 类代码描述： 5.0号中断改编中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。8086 支持 256 个中断，但是，实际上，系统中要处理的中断事件远没有达到256 个 。所以在中断向量表中，有许多单元是空的。中断向量表是PC系统中最重要的内存区，只用来存放中断处理程序的入口地址，DOS 系统和其他应用程序都不会随便使用这段空间。我们可以利用中断向量表中的空闲单元来存放我们的程序。一般情况下：从0000:0200至0000:02FF的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用。我们估计，do0的长度不可能超过256个字节。结论：我们可以将do0传送到内存0000:0200处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051assume cs:codeCOMMENT !由于中断例程不可能到达256个那么多，所以中断向量表中还有很多是空的比如0000:0200~0000:02FF这256个字节，所以便把中断例程放置在这个位置!code segmentstart:;安装中断例程 mov ax, 0 mov es, ax mov di, 200h ;目的地址es:di 即0000:0200, mov ax, cs mov ds, ax ;源地址ds:si 即do0的偏移地址，也就是中断处理程序 mov si, offset do0 mov cx, offset do0end - offset do0 ;中断处理程序的字节数,也就是要转移的数量 cld ;传输方向为正 rep movsb ;把中断处理程序安装至0000:0200 mov ax, 0 mov es, ax;将中断例程的入口地址放置到中断向量表中 mov word ptr es:[0 * 4], 200h ;将中断处理程序的入口放在0号中断向量中 mov word ptr es:[0 * 4 + 2], 0 mov ax, 4c00h int 21h;中断处理程序do0: ;为了防止字符串被覆盖所以将其放在中断例程里 jmp short do0start db &#x27;Divide overflow!&#x27;, 0do0start: mov ax, 0b800h ;显存段地址 mov es, ax mov di, 160 * 12 + 36 * 2 ;第13行中间位置 mov ax, cs mov ds, ax mov si, 202h ;字符串的偏移地址 mov cx, 10h ;字符串数目s: mov bl, [si] mov es:[di], bl mov es:[di + 1], 2 inc si add di, 2 loop s iret ;返回do0end: nopcode endsend start 6.单步中断基本上，CPU在执行一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程. 单步中断的中断类型码为1，则它所引发的中断过程如下： 12341) 取得中断类型码N；（此时N=1）2) 标志寄存器入栈，TF、IF设置为0；3) CS、IP入栈；4) (IP) = (N*4), (CS) = (N*4+2) 响应中断的特殊情况： 一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程. 可是，在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应. 对于这些情况，这里就不一一举例，只是用一种情况进行说明. 在执行完向ss寄存器传送数据的指令后，即便是发生中断，CPU也不会响应. 这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成. 如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS、IP的值. 而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误. 所以CPU在执行完设置ss的指令后，不响应中断. 这给连续设置ss和sp指向正确的栈顶提供了一个时机. 即，我们应该利用这一特性，将设置ss和sp的指令连续存放，使得sp的指令紧接着设置ss的指令执行，而在此之间，CPU不会引发中断过程. 比如，我们要将栈顶设置1000:0，应该： 123mov ax, 1000hmov ss, axmov sp, 0 而不应该： 1234mov ax,1000hmov ss, axmov ax, 0mov sp, 0 7.int指令引发的中断int 格式： 1int n;n为中断类型码 引发的过程是 12341) 取得中断类型码N；（此时N=1）2) 标志寄存器入栈，TF、IF设置为0；3) CS、IP入栈；4) (IP) = (N*4), (CS) = (N*4+2) 中断7ch的中断例程: 功能为显示一个用0结束的字符串，中断例程安装在 0:200处。参数：（dh）&#x3D; 行号，（dl）&#x3D; 列号，（cl）&#x3D; 颜色，ds:si指向字符串首地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071assume cs:code, ds:datacode segmentstart: jmp install mov dh, 10 mov dl, 10 mov cl, 2 mov ax, data mov ds, ax mov si, 0 int 7ch mov ax, 4c00h int 21h install: mov ax, 0 mov es, ax mov word ptr es:[4 * 7ch], 200h mov word ptr es:[4 * 7ch + 2], 0;安装中断向量表 mov ax, cs mov ds, ax mov ax, 0 mov es, ax mov si, 0 mov di, 200h mov cx, offset do7chEnd - offset do7ch cld rep movsb do7ch:data segment db &quot;welcome to masm!&quot;, 0data ends push cx push si push di mov ax, 0b800h mov es, ax mov ax, data mov ds, ax mov si, 0;源地址偏移 mov al, dh mov bl, 160 mul bl ;dh * 160 add ax, dl mov di, axtrans: mov cl, [si] mov ch, 0 jcxz fin;如果cx = 0，表示已经处理完毕 mov byte ptr es:[di], cl mov byte ptr es:[di + 1], 11000010B inc si add di, 2 jmp transfin: pop di pop si pop cx iret do7chEnd: nopcode endsend start CPU 执行 int 7ch 指令进入中断例程之前，标志寄存器、当前的 CS 和 IP 被压入栈中，在执行完中断例程后，应该用 iret 指令恢复 int 7ch 执行前的标志寄存器和 CS、IP 的值，从而接着执行应用程序。 int 指令和 iret 指令的配合使用与 call 指令和 ret 指令的配合使用具有相似的思路。 8.BIOS和DOS中断处理BIOS（Basic input&#x2F;output system）固化在 ROM 中，包括 I&#x2F;O 设备的处理程序和许多常用的例行程序。 对用户程序来说，可由特定指令 INT n（n 为中断号）通过软终端的方式调用。不管 DOS 是否装入系统，这些调用可以直接控制 I&#x2F;O 设备。 MS-DOS（disk operating system）系统功能调用是DOS为程序员编写汇编语言源程序提供了一组常用子程序（80多个），可在汇编语言程序中直接调用。这些子程序的主要功能包括： (1)设备管理（如键盘、显示器、打印机、磁盘等的管理） (2)文件管理和目录操作 (3)其他管理（如内存、时间、日期等管理） 这些子程序给用户编程带来很大方便，用户不必了解有关的设备、电路、接口等方面的问题，只需直接调用即可。 MS-DOS 规定用INT 21H进入各功能调用子程序的入口，并为每个功能调用规定了一个功能号，以便进入各个相应子程序的入口。 DOS功能调用的子程序已按顺序编号——功能号（00H～68H），其调用方法是： (1) 功能号→AH（根据要使用的DOS功能调用设置入口参数） (2) 入口参数→指定寄存器（将DOS功能调用的编号送入寄存器AH） (3) 发送软中断指令 INT 21H 调用结束后，系统将出口参数送到指定寄存器、内存或直接送到输出设备 9.端口读写CPU 可以直接读写 3 个地方的数据：CPU 内部的寄存器、内存单元、端口。 CPU 通过端口地址来定位端口。因为端口所在的芯片和 CPU 通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。PC 系统中，CPU 最多可以定位 64KB 个不同的端口。则端口地址的范围为 0~65535。 端口的读写指令只有两条：in 和 out。分别从端口读取和写入数据。 比较 CPU 执行内存访问指令和端口访问指令时，总线上的信息： 当端口号大于255(0ffh)时，必须将端口号存入dx再使用in&#x2F;out 访问内存： 1mov ax,ds:[8] CPU 通过地址线将地址信息 8 发出； CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据； 存储器将 8 号单元中的数据通过数据线送入CPU。 访问端口： 1in al,60h;将端口号为60h的端口读出字节至al CPU 通过地址线将地址信息 60h 发出； CPU 通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据； 端口所在的芯片将 60h 端口中的数据通过数据线送入 CPU。 in 和 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据。8 位端口用 al，16 位端口用 ax。 CMOS RAM 芯片 该芯片有两个端口，端口地址为 70h 和 71h。CPU 通过这两个端口来读写 CMOS RAM。 70h 为地址端口，存放要访问的 CMOS RAM 单元的地址；71h 为数据端口，存放从选定的 CMOS RAM 单元中读取的数据，或要写入其中的数据。 在 CMOS RAM 中，存放着当前的时间：年、月、日、时、分、秒。这 6 个信息的长度都位 1 个字节，存放单元为： 时间 秒 分 时 日 月 年 地址（字节） 00 02 04 07 08 09 这些数据以 BCD 码的方式存放。 十进制数码 0 1 2 3 4 5 6 7 8 9 BCD 码 00000 0001 0010 0011 0100 0101 0110 0111 1000 1001 123456789101112131415161718192021222324252627282930（1）CMOS RAM中存储着当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节，存放单元为 秒：0，分：2，时：4，日：7，月：8，年：9，这些数据以BCD码存储，BCD码是以4位二进制数表示十进制数的编码方法，例如十进制的0对应的BCD码为0000，十进制9对应的BCD码为1001，因此一个字节可以表示两个BCD码的两位十进制值。（2）读取CMOS RAM的信息，需要向地址70h写入要访问的单元地址（用al寄存器），然后从数据端口71h中取得指定单元的数据。（3）BCD码值+30h=10进制数对应的ASCII码。（4）显示缓存地址为0b800h处，显示器为80字符宽，25行，每个字符用2个字节显示，高位字节为字符，低位字节为显示属性（可采用默认属性）。;显示年份assume cs:codecode segmemtstart: ;从9号单元读取年份 mov al,9 out 70h,al in al,71h mov ah,alshr ah,4and al,00001111badd ah,30hadd al,30hmov bx,0b800hmov es,bxmov byte ptr es:[160*12+40*2], ahmov byte ptr es:[160*12+40*2+2], almov ax 4c00hint 21hcode endsend start 10.外中断1、可屏蔽中断 可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。当CPU检测到可屏蔽中断信息时，如果IF&#x3D;1，则CPU在执行完当前指令后响应中断，引发中断过程；如果IF&#x3D;0，则不响应可屏蔽中断。 因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。 现在我们可以解释中断过程中将IF置为0的原因了。将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。 如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。8086CPU提供的设置IF的指令如下： sti,设置 IF&#x3D;1；cli,设置 IF&#x3D;0。 2、不可屏蔽中断 不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应引发中断过程。 对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中不需要取中断类型码。则不可屏蔽中断的中断过程为： （1）标志寄存器入栈，IF&#x3D;0，TF&#x3D;0；（2）CS、IP入栈；（3）(IP)&#x3D;(8)，(CS)&#x3D;(0AH)。 几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件(比如说键盘输入)发生时，相关芯片向CPU发出可屏蔽中断信息。 11.PC机键盘处理1. 键盘输入 键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。 按下一个键时，开关接通该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。 扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60h。 松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60h端口中。 一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。扫描码长度为一个字节，通码的第7位为0，断码的第7位为1，即： 断码&#x3D;通码+80h 2. 引发9号中断 键盘的输入到达60h端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。 CPU检测到该中断信息后，如果IF&#x3D;1，则响应中断，引发中断过程转去执行int9中断例程。 3. 执行int9中断例程 BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要的工作如下： （1）读出60h端口中的扫描码；（2）如果是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCII码）送入内存中的BIOS键盘缓冲区；如果是控制键（比如Ctrl）和切换键（比如CapsLock）的扫描码，则将其转变为状态字节（用二进制位记录控制键和切换键状态的字节）写入内存中存储状态字节的单元；（3）对键盘系统进行相关的控制，比如说向相关芯片发出应答信息。 BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。该内存区可以存储15个键盘输入，因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。 12.int 9中断例程定制仿照前面的 13.中断响应外设键盘输入将引发9号中断，BIOS提供了int 9中断例程。CPU在9号中断发生后，执行int 9中断例程，从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。 一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中 BIOS提供了int 16h中断例程供程序员调用。int 16h中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。 应用int 13h中断例程对磁盘进行读写 3.5英寸软盘分为上下两面，每面有80个磁道，每个磁道又分为18个扇区，每个扇区的大小为512个字节。 则：2面x80磁道x18扇区x512字节&#x3D;1440KB≈1.44MB 磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。 BIOS提供的访问磁盘的中断例程为int 13h。读取0面0道1扇区的内容到0:200的程序如下所示。 mov ax,0mov es,axmov bx,200h mov al,1mov ch,0mov cl,1mov dl,0mov dh,0mov ah,2int 13h 入口参数: (ah)&#x3D;int 13h的功能号(2表示读扇区)(al)&#x3D;读取的扇区数(ch)&#x3D;磁道号(cl)&#x3D;扇区号(dh)&#x3D;磁头号(对于软盘即面号，因为一个面用一个磁头来读写)(dl)&#x3D;驱动器号软驱从0开始，0：软驱A, 1：软驱B；硬盘从80h开始，80h：硬盘C, 81h：硬盘Des:bx指向接收从扇区读入数据的内存区 返回参数： 操作成功：(ah)&#x3D;0，(al)&#x3D;读入的扇区数操作失败：(ah)&#x3D;出错代码 将0:200中的内容写入0面0道1扇区。 mov ax,0mov es,axmov bx,200h mov al,1mov ch, 0mov cl,1mov dl,0mov dh,0 mov ah,3int 13h 入口参数： (ah)&#x3D;int 13h的功能号(3表示写扇区)(al)&#x3D;写入的扇区数(ch)&#x3D;磁道号(cl)&#x3D;扇区号(dh)&#x3D;磁头号(面)(dl)&#x3D;驱动器号软驱从0开始，0：软驱A, 1：软驱B；硬盘从80h开始，80h：硬盘C, 81h：硬盘Des:bx指向将写入磁盘的数据 返回参数： 操作成功：(ah)&#x3D;0，(al)&#x3D;写入的扇区数操作失败：(ah)&#x3D;出错代码","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://blog.zymatrix.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"《帝国主义是资本主义的最高阶段》","slug":"《帝国主义是资本主义的最高阶段》","date":"2023-05-10T16:00:00.000Z","updated":"2024-08-12T09:16:44.652Z","comments":true,"path":"2023/05/11/《帝国主义是资本主义的最高阶段》/","link":"","permalink":"http://blog.zymatrix.top/2023/05/11/%E3%80%8A%E5%B8%9D%E5%9B%BD%E4%B8%BB%E4%B9%89%E6%98%AF%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E7%9A%84%E6%9C%80%E9%AB%98%E9%98%B6%E6%AE%B5%E3%80%8B/","excerpt":"","text":"铁路网的分布，这种分布的不平衡，铁路网发展的不平衡，是全世界现代资本主义即垄断资本主义造成的结果。这种结果表明，只要生产资料私有制还存在，在上述这样的经济基础上，帝国主义战争是绝对不可避免的。 很明显，这种大量的超额利润（因为它是在资本家从“自己”国家工人身上榨取的利润之外得来的）可以用来收买工人领袖和工人贵族这个上层。 这个资产阶级化了的工人阶层即“工人贵族”阶层，这个按生活方式、工资数额和整个世界观来说已经完全小市民化的工人阶层，是第二国际的主要支柱，现在是资产阶级的主要社会支柱。因为这是资产阶级在工人运动中的真正代理人，是资本家阶级的工人帮办，是改良主义和沙文主义的真正传播者。在无产阶级同资产阶级的国内战争中，他们有不少人必然会站在资产阶级方面，站在“凡尔赛派”方面来反对“公社战士”。 帝国主义阶段的资本主义紧紧接近最全面的生产社会化，它不顾资本家的愿望和意识，可以说是把他们拖进一种从完全的竞争自由向完全的社会化过渡的新的社会秩序。 生产社会化了，但是占有仍然是私人的。社会化的生产资料仍旧是少数人的私有财产。在形式上被承认的自由竞争的一般架子依然存在，而少数垄断者对其余居民的压迫却更加百倍地沉重、显著和令人难以忍受了。 为数众多的普通中介人成为极少数垄断者的这种转变，是资本主义发展成为资本帝国主义的基本过程之一。 生产的集中；从集中生长起来的垄断；银行和工业日益融合或者说长合在一起，——这就是金融资本产生的历史和这一概念的内容。 垄断既然已经形成，而且操纵着几十亿资本，它就绝对不可避免地要渗透到社会生活的各个方面去，而不管政治制度或其他任何“细节”如何。 资本主义的一般特性，就是资本的占有同资本在生产中的运用相分离，货币资本同工业资本或者说生产资本相分离，全靠货币资本的收入为生的食利者同企业家及一切直接参与运用资本的人相分离，帝国主义，或者说金融资本的统治，是资本主义的最高阶段，这时候，这种分离达到了极大的程度。金融资本对其他一切形式的资本的优势，意味着食利者和金融寡头占统治地位，意味着少数拥有金融“实力”的国家处于和其余一切国家不同的特殊地位。 对自由竞争占完全统治地位的旧资本主义来说，典型的是商品输出。对垄断占统治地位的最新资本主义来说，典型的则是资本输出。 金融资本是一种存在于一切经济关系和一切国际关系中的巨大力量，可以说是起决定作用的力量，它甚至能够支配而且实际上已经支配着一些政治上完全独立的国家。 资本主义愈发达，原料愈感缺乏，竞争和追逐全世界原料产地的斗争愈尖锐，抢夺殖民地的斗争也就愈激烈。 在金融资本的基础上生长起来的非经济的上层建筑，即金融资本的政策和意识形态，加强了夺取殖民地的趋向。 试问，在资本主义基础上，要消除生产力发展和资本积累同金融资本对殖民地和“势力范围”的瓜分这两者之间不相适应的状况，除了用战争以外，还能有什么其他办法呢？ 帝国主义有一种趋势，就是在工人中间也分化出一些特权阶层，并且使他们脱离广大的无产阶级群众。（分化出工人贵族，这些人将是反对无产阶级革命的一部分，但是由于他们仍然是无产阶级，在危机来临之时，现实将会把他们从大梦中拍醒） 例如，恩格斯在1858年10月7日给马克思的信中说：“英国无产阶级实际上日益资产阶级化了，因而这一所有民族中最资产阶级化的民族，看来想把事情最终弄到这样的地步，即除了资产阶级，它还要有资产阶级化的贵族和资产阶级化的无产阶级。” 考茨基的 “理论”的客观即真正的社会意义只有一个，就是拿资本主义制度下可能达到永久和平的希望，对群众进行最反动的安慰，其方法就是使人们不去注意现代的尖锐矛盾和尖锐问题，而去注意某种所谓新的将来的 “超帝国主义”的虚假前途。","categories":[{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"}]},{"title":"《哥达纲领批判》","slug":"《哥达纲领批判》","date":"2023-04-05T16:00:00.000Z","updated":"2024-08-12T09:16:56.871Z","comments":true,"path":"2023/04/06/《哥达纲领批判》/","link":"","permalink":"http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%93%A5%E8%BE%BE%E7%BA%B2%E9%A2%86%E6%89%B9%E5%88%A4%E3%80%8B/","excerpt":"","text":"劳动不是一切财富的源泉。自然界同劳动一样也是使用价值（而物质财富就是由使用价值构成的！）的源泉，劳动本身不过是一种自然力即人的劳动力的表现 只有一个人一开始就以所有者的身份来对待自然界这个一切劳动资料和劳动对象的第一源泉，把自然界当做属于他的东西来处置，他的劳动才成为使用价值的源泉，因而也成为财富的源泉。 在一个集体的、以生产资料公有为基础的社会中，生产者不交换自己的产品；用在产品上的劳动，在这里也不表现为这些产品的价值，不表现为这些产品所具有的某种物的属性，因为这时，同资本主义社会相反，个人的劳动不再经过迂回曲折的道路，而是直接作为总劳动的组成部分存在着。 权利决不能超出社会的经济结构以及由经济结构制约的社会的文化发展 庸俗的社会主义仿效资产阶级经济学家把分配看成并解释成一种不依赖于生产方式的东西，从而把社会主义描写为主要是围绕着分配兜圈子。（由此可见，所谓依靠政府进行再分配的温和社会主义，即社会民主主义国家并不能称作是代表无产阶级的国家，它并未改变资本主义社会的经济基础因而也没有改变无产阶级被剥削的事实。） 在资本主义社会和共产主义社会之间，有一个从前者变为后者的革命转变时期。同这个时期相适应的也有一个政治上的过渡时期，这个时期的国家只能是无产阶级的革命专政。 自由就在于把国家由一个高踞社会之上的机关变成完全服从这个社会的机关；而且就在今天，各种国家形式比较自由或比较不自由，也取决于这些国家形式把“国家的自由”限制到什么程度。 在按照不同的年龄阶段严格调节劳动时间并采取其他保护儿童的预防措施的条件下，生产劳动和教育的早期结合是改造现代社会的最强有力的手段之一。 当无产阶级还需要国家的时候，它需要国家不是为了自由，而是为了镇压自己的敌人，一到有可能谈自由的时候，国家本身就不存在了。","categories":[{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"}]},{"title":"建站小记","slug":"first","date":"2023-04-05T16:00:00.000Z","updated":"2024-08-12T09:20:03.695Z","comments":true,"path":"2023/04/06/first/","link":"","permalink":"http://blog.zymatrix.top/2023/04/06/first/","excerpt":"","text":"建站原因在b站上看到了一个搭建个人博客网站的视频，心血来潮以及作为Geek必备的博客作为驱动力，于是查找了一些资料最终找到了以github + hexo 的方式建立博客。感谢朋友（畅姐我的神）的倾情推荐，给了我一个好教程。 曲折的建站过程说到这个，不得不吐槽一下我这令人愤怒的电脑。从我大一上学期配C语言环境开始，再到虚拟机和linux ssh远端连接，这玩意就没让我省心过。吐槽结束，现在是问题时间。 一由于初次上手个人网站搭建，所知甚少。而且最开始时，没有如此系统的教程，都是用的零七碎八的教程，难免遇到各种问题。 npm node hexo 安装完成后出现类似command not found的问题，用Google搜索、在stackoverflow上找相关问题，都没能解决这个问题，最后尝试了csdn上的一个说法，即设置环境变量,在path下面加上npm node hexo等的路径，成功解决问题。（多少有点zz了）路径问题占据了我建站的绝大多数时间。 设置部署仓库和分支出现 “FATAL YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key (107:14)” 的问题。这个问题是因我在更改hexo源码根目录下的_config.yml中的deploy部分直接复制粘贴引起的。参考下图，在repo:以及branch:的冒号后面要加上’ ‘空格。 目前尚未解决的问题。GitHub Actions自动部署，按照教程上传workflow文件到github上，但是目前还没成功，也没查原因。 在执行hexo generate和hexo deploy命令时可能会出现kex_exchange_identification: Connection closed by remote host Connection closed by 20.205.243.166 port 22 fatal: Could not read from remote repository的错误信息，这个时候需要改变一下自己的vpn节点，或者在vpn速度较好时再重新执行hexo d的命令。 二建站完成之后，就是要对网站进行个性化的修改，对样式进行处理 在文章的头部部分增加一下内容能够达到对文章进行分类的效果。这些内容可以在_config.yml文件中找到对应的部分。1234567891011---title: #文章标题cover: #文章封面的图片的链接或者地址category: #文章在子页中的分类tag: - #文章的标签id: #文章的序号date: #文章写作的时间toc: true #是否包含目录timeline: #在时间线中的分类---","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"《德意志意识形态（节选）》","slug":"《德意志意识形态（节选）》马克思 恩格斯","date":"2023-04-05T16:00:00.000Z","updated":"2024-08-12T09:15:56.249Z","comments":true,"path":"2023/04/06/《德意志意识形态（节选）》马克思 恩格斯/","link":"","permalink":"http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%BE%B7%E6%84%8F%E5%BF%97%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81%EF%BC%88%E8%8A%82%E9%80%89%EF%BC%89%E3%80%8B%E9%A9%AC%E5%85%8B%E6%80%9D%20%E6%81%A9%E6%A0%BC%E6%96%AF/","excerpt":"","text":"第一卷第一章费尔巴哈唯物主义观点和唯心主义观点的对立 因此，他们是什么样的，这同他们的生产是一致的——既和他们生产什么一致，又和他们怎样生产一致。 各民族之间的相互关系取决于每一个民族的生产力、分工和内部交往的发展程度。 一个民族的生产力发展的水平，最明显地表现于该民族分工的发展程度。任何新的生产力，只要它不是迄今已知的生产力单纯的量的扩大(例如，开垦土地)，都会引起分工的进一步发展。 一个民族内部的分工，首先引起工商业劳动同农业劳动的分离，从而也引起城乡的分离和城乡利益的对立。分工的进一步发展导致商业劳动同工业劳动的分离。 如果他们把哲学、神学、实体和一切废物消融在“自我意识”中，如果他们把“人”从这些词句的统治下——而人从来没有受过这些词句的奴役——解放出来，那么“人”的“解放”也并没有前进一步；只有在现实的世界中并使用现实的手段才能实现真正的解放[16]；没有蒸汽机和珍妮走锭精纺机就不能消灭奴隶制；没有改良的农业就不能消灭农奴制；当人们还不能使自己的吃喝住穿在质和量方面得到充分保证的时候，人们就根本不能获得解放 我们谈的是一些没有任何前提的德国人，因此我们首先应当确定一切人类生存的第一个前提，也就是一切历史的第一个前提[30]，这个前提是：人们为了能够“创造历史”，必须能够生活[31]。但是为了生活，首先就需要吃喝住穿以及其他一些东西。因此第一个历史活动就是生产满足这些需要的资料，即生产物质生活本身，而且这是这样的历史活动，一切历史的一种基本条件，人们单是为了能够生活就必须每日每时去完成它，现在和几千年前都是这样。 由此可见，一开始就表明了人们之间是有物质联系的。这种联系是由需要和生产方式决定的，它和人本身有同样长久的历史；这种联系不断采取新的形式，因而就表现为“历史”，它不需要有专门把人们联合起来的任何政治的或宗教的呓语。 其次，生产力的这种发展之所以是绝对必需的实际前提，还因为：只有随着生产力的这种普遍发展，人们的普遍交往才能建立起来；普遍交往，一方面，可以产生一切民族中同时都存在着“没有财产的”群众这一现象(普遍竞争)，使每一民族都依赖于其他民族的变革；最后，地域性的个人为世界历史性的、经验上普遍的个人所代替。不这样，(1)共产主义就只能作为某种地域性的东西而存在；(2)交往的力量本身就不可能发展成为一种普遍的因而是不堪忍受的力量：它们会依然处于地方的、笼罩着迷信气氛的“状态”；(3)交往的任何扩大都会消灭地域性的共产主义。共产主义只有作为占统治地位的各民族“一下子”同时发生的行动，在经验上才是可能的，而这是以生产力的普遍发展和与此相联系的世界交往为前提的。","categories":[{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"}]},{"title":"《国家与革命》","slug":"《国家与革命》 列宁","date":"2023-04-05T16:00:00.000Z","updated":"2024-08-12T09:17:09.654Z","comments":true,"path":"2023/04/06/《国家与革命》 列宁/","link":"","permalink":"http://blog.zymatrix.top/2023/04/06/%E3%80%8A%E5%9B%BD%E5%AE%B6%E4%B8%8E%E9%9D%A9%E5%91%BD%E3%80%8B%20%E5%88%97%E5%AE%81/","excerpt":"","text":"序言 如果不同“国家”问题上的机会主义偏见作斗争，使劳动群众摆脱资产阶级影响、特别是摆脱帝国主义资产阶级影响的斗争就无法进行。 无产阶级社会主义革命对国家的态度问题不仅具有政治实践的意义，而且具有最迫切的意义，这个问题是要向群众说明，为了使自己从资本的枷锁下解放出来，他们在最近的将来应当做些什么。 第一章 阶级社会与国家国家是阶级矛盾不可调和的产物 当伟大的革命家在世时，压迫阶级总是不断迫害他们，以最恶毒的敌意、最疯狂的仇恨、最放肆的造谣和诽谤对待他们的学说。在他们逝世以后，便试图把他们变为无害的神像，可以说把他们偶像化，赋予他们的名字某种荣誉，以便“安慰”和愚弄被压迫阶级，同时却阉割革命学说的内容，磨去它的革命锋芒，把它庸俗化。 国家是阶级矛盾不可调和的产物和表现。在阶级矛盾客观上不能调和的地方、时候和条件下，便产生国家。反过来说，国家的存在证明阶级矛盾不可调和。 在马克思看来，国家是阶级统治的机关，是一个阶级压迫另一个阶级的机关，是建立一种“秩序”来抑制阶级冲突，使这种压迫合法化、固定化。 既然国家是阶级矛盾不可调和的产物，既然它是凌驾于社会之上并且“日益同社会相异化”的力量，那么很明显，被压迫阶级要求得解放，不仅非进行暴力革命不可，而且非消灭统治阶级所建立的、体现这种“异化”的国家政权机构不可。 国家是剥削被压迫阶级的工具 他们自己相信而且要人民也相信这种荒谬的想法：普选制“在现今的国家里”能够真正体现大多数劳动者的意志，并保证实现这种意志。 目前，在任何民主共和国中，帝国主义和银行统治都把这两种维护和实现财富的无限权力的方法“发展”到了非常巧妙的地步。 国家“自行消亡”和暴力革命 当国家终于真正成为整个社会的代表时，它就使自己成为多余的了。——恩格斯 那时，对人的统治将由对物的管理和对生产过程的领导所代替。国家不是“被废除的”，它是自行消亡的。——恩格斯 按恩格斯的看法，资产阶级国家不是“自行消亡”的，而是由无产阶级在革命中来“消灭”的。在这个革命以后，自行消亡的是无产阶级的国家或半国家。 显然，以一种（无产阶级的）“特殊力量”来代替另一种（资产阶级的）“特殊力量”，这样一种更替是决不能通过“自行消亡”来实现的。 因此任何国家都不是自由的，都不是人民的。 第二章 国家与革命。1848-1851年的经验革命的前夜 无产阶级需要国家政权，中央集权的强力组织，暴力组织，既是为了镇压剥削者的反抗，也是为了领导广大民众即农民、小资产阶级和半无产者来“调整”社会主义经济。 马克思主义教育工人的党，也就是教育无产阶级的先锋队，使它能够夺取政权并引导全体人民走向社会主义，指导并组织新制度，成为所有被剥削劳动者在不要资产阶级并反对资产阶级而建设自己社会生活的事业中的导师、领导者和领袖。 1852年马克思对问题的提法 把马克思主义局限于阶级斗争学说，就是阉割马克思主义，歪曲马克思主义，把马克思主义变为资产阶级可以接受的东西。只有承认阶级斗争、同时也承认无产阶级专政的人，才是马克思主义者。 第三章 国家与革命。1871年巴黎公社的经验。马克思的分析取消议会制 我们不是空想主义者。我们并不“幻想”一下子就可以不要任何管理，不要任何服从；这种由于不懂得无产阶级专政的任务而产生的无政府主义幻想，与马克思主义根本不相容，实际上只会把社会主义革命拖延到人们变成另一种人的时候。 但是所需要的服从，是对一切被剥削劳动者的武装先锋队——无产阶级的服从。 第五章 国家消亡的经济基础从资本主义到共产主义的过渡 产生违反公共生活规则的极端行动的根本社会原因是群众受剥削和群众贫困。这个主要原因一消除，极端行动就必然开始“消亡”。 共产主义社会的第一阶段 任何权利都是把同一标准应用在不同的人身上，即应用在事实上各不相同、各不同等的人身上，因而“平等的权利”就是破坏平等，就是不公平。 可见，在共产主义第一阶段还不能做到公平和平等，因为富裕的程度还会不同，而不同就是不公平。 可见，在共产主义下，在一定的时期内，不仅会保留资产阶级权利，甚至还会保留资产阶级国家，——但没有资产阶级！ 其实，，无论在自然界或在社会中，实际生活随时随地都能使我们看到新事物中有旧的残余。马克思并不是随便把一小块“资产阶级”权利塞到共产主义中去，而是抓住了从资本主义脱胎出来的社会里那种在经济上和政治上不可避免的东西。","categories":[{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"}]},{"title":"《法德农民问题》","slug":"法德农民问题","date":"2023-04-05T16:00:00.000Z","updated":"2024-08-12T09:20:39.209Z","comments":true,"path":"2023/04/06/法德农民问题/","link":"","permalink":"http://blog.zymatrix.top/2023/04/06/%E6%B3%95%E5%BE%B7%E5%86%9C%E6%B0%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"作为政治力量的要素，农民至今在多数场合下仅仅表现出自己的那种生根于农村生活孤僻状况中的冷漠态度。广大居民群众的这种冷漠态度，不仅是巴黎和罗马国会腐败情况的强有力支柱，而且是俄罗斯专制主义的强有力的支柱。 社会党夺取政权已成为最近将来的事情。然而，为了夺取政权，这个政党应当首先从城市跑到农村，应当成为农村中的力量。 那末我们对待小农的态度是怎样的呢？在我们夺得国家权力的那一天，我们应该怎样对待他们呢？ 第一，法国纲领的原理是绝对正确的：我们预见到小农必然灭亡，但我们无论如何不要以自己的干预去加速其灭亡。 第二，同样明显的，当我们掌握了国家权力的时候，我们根本不能设想用强制的办法去剥夺小农（不论有无报偿，都是一样），像我们将不得不如此对待大土地占有者那样。我们对于小农的任务，首先是把他们的私人生产和私人占有变为合作社的生产和占有，但不是用强制的办法，而是通过示范和为此提供社会帮助。 - 我们永远也不能许诺小农给他保持个体经济和个人财产去反对资本主义生产的优势力量。我们只能许诺他们说，我们不会违反他们的意志而用强力干预他们的财产关系。","categories":[{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"}]},{"title":"CS:APP阅读笔记#1","slug":"csapp1","date":"2023-03-28T16:00:00.000Z","updated":"2024-08-12T09:19:24.266Z","comments":true,"path":"2023/03/29/csapp1/","link":"","permalink":"http://blog.zymatrix.top/2023/03/29/csapp1/","excerpt":"","text":"第2章 信息的表示和处理2.2.5在本节中的网络旁注DATA:TMIN部分提到，在C语言中把TMin32（32位有符号数最小值）写成是-2147483647-1，而不是简单的写成是-2147483648或者0x80000000。在C的头文件limits.h中有 12#define INT_MAX 2147483647#define INT_MIN (-INT_MAX - 1) 然而旁注仅仅提到是由于“补码表示的不对称性和C语言的转换规则之间奇怪的交互”，至于是什么规则，书中并没有解释。 后查阅谷歌，参考了文章https://www.cnblogs.com/jack47/archive/2013/01/06/tmin32-in-c.html https://ld246.com/article/1357370795290 文章指出，在某些编译器中，表示一个负数往往采用的是-X(X&gt;0)的形式，而由于32位机器以及补码表示整型的不对称性，2147483648超过了32位机器所能表示的最大有符号整型数的范围，造成溢出，因此必须写成-2147483647-1。简而言之，就是 “用一句话来解释C语言中TMin32的古怪写法的原因：虽然-2147483648 这个数值能够用int类型来表示，但在C语言中却没法写出对应这个数值的int类型常量。”","categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"}],"tags":[{"name":"csapp","slug":"csapp","permalink":"http://blog.zymatrix.top/tags/csapp/"}]},{"title":"2022年度总结","slug":"2022年度总结","date":"2022-12-30T16:00:00.000Z","updated":"2024-08-12T09:15:39.418Z","comments":true,"path":"2022/12/31/2022年度总结/","link":"","permalink":"http://blog.zymatrix.top/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"第一次对自己人生的十八分之一进行总结，不知是出于这一年自己太过庸常，还是波澜起伏的大事太多,总之，我总算是愿意花上一点时间坐在电脑前，回顾一下这一年的纷扰，同时展望一下不可展望的未来。马克·吐温说:“现实比小说荒诞多了，虚构还要在一定逻辑下进行，而现实往往毫无逻辑可言。”我愿意用荒诞这样一个无法言说荒诞的词来概括这一年。这一年，我看到的我所认为魔幻的事件以一种难以预料到的方式出现，以致所有人吹嘘其重要性的高考显得那么平常。六月初的两天，我只是在安详之中度过，尽管身边的每一个人所展现出来的神态、语言和动作，都在明确地告诉我这是我目前的人生中最重要的大事，但是我总会不屑地告诉自己，十八年前的那一天显然更为重要。依照今日马后炮的回忆，它所带来的心情波动，甚至不及我填报志愿的几日和我住进宿舍的那一天。我甚至不愿意再花上一分钟去回忆那段时光，因为只有同学、师长、亲人和书本值得被我记录。这一年，我去到了大学，一个曾经令我魂牵梦萦的圣地。我厌倦了高中那重复难以获得新知的枯燥，度过的日子就像是在沙漠里每日以沙子充饥。我说:“对于高中，回忆是痛苦的，最后在回忆里留下的一定是一群值得怀念的人。”很多事只有当它出现在面前的时候，才能知道真正的模样。大学也是如此。毫无意义的会议、毫无意义的课程、毫无意义的内耗这些是只有身在围城中的人才能深切知晓的。我只会把大学丑陋的一面讲述给自己，至于那些美好的画面，在那之前我已经幻想得足够多了。这一年，无能的官僚资产阶级在无产阶级爆发出的怨气和对乌鲁木齐火灾中不幸罹难的同胞的同情中被迫让步，全国各地此起彼伏的游行示威宣示着对官僚资产阶级的不满。我很高兴能够见到这一切，我仍然记得那天我是怎样的激动，看着手机上的新闻，身体有些微微颤抖。这样一件大事，对我的鼓舞比这一年里任何事情都更加明显。这一年，我下定决心，开始学习马列毛主义思想，这些人类历史长河中闪耀的明星，他们将是我未来精神上的导师。这一年，我第一次深刻地领悟到了自己在行动上如何地侏儒。那个决心在暑假阅遍数十书的书虫不见了取而代之的是无营养的知乎;那个决心要好好学习的“卷怪”不见了，取而代之的是无尽的游戏;那个决心要动笔写作的想象者不见了，我看到了自己荒芜的想象世界和波澜不惊的感情世界。简单来说，我缺失了爱的能力。生动的小说世界和情感丰沛的诗再也没有出现在生活之中，我曾经用来思考的碎片时间被智能手机填充，稍稍空闲下来的间隙，眼睛盯着的不是空气而是屏幕，本就不够深邃的思维愈发迟钝，质问和怀疑之后剩下的不是重新行动，而是一地鸡毛。这一年，“我年华虚度，空余一身疲惫，和所有以梦为马的诗人一样，岁月易逝，一滴不剩”很奇怪，漫长的一年值得纪念的寥寥数语就能概括，而短暂的一天我却怎么也过不好。至于对未来的期望，不过是些老调重弹的东西，写下对这一年的回顾后，我不想对未来再有什么幻想了,只送给2023年一句毛泽东同志的话:“好好学习，天天向上”。","categories":[],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"}]}],"categories":[{"name":"cs","slug":"cs","permalink":"http://blog.zymatrix.top/categories/cs/"},{"name":"hacker","slug":"hacker","permalink":"http://blog.zymatrix.top/categories/hacker/"},{"name":"my love","slug":"my-love","permalink":"http://blog.zymatrix.top/categories/my-love/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://blog.zymatrix.top/tags/JavaSE/"},{"name":"Web后端","slug":"Web后端","permalink":"http://blog.zymatrix.top/tags/Web%E5%90%8E%E7%AB%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.zymatrix.top/tags/Python/"},{"name":"OS","slug":"OS","permalink":"http://blog.zymatrix.top/tags/OS/"},{"name":"Linux Kernel","slug":"Linux-Kernel","permalink":"http://blog.zymatrix.top/tags/Linux-Kernel/"},{"name":"杂记","slug":"杂记","permalink":"http://blog.zymatrix.top/tags/%E6%9D%82%E8%AE%B0/"},{"name":"CTF","slug":"CTF","permalink":"http://blog.zymatrix.top/tags/CTF/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://blog.zymatrix.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"哲学","slug":"哲学","permalink":"http://blog.zymatrix.top/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马列毛","slug":"马列毛","permalink":"http://blog.zymatrix.top/tags/%E9%A9%AC%E5%88%97%E6%AF%9B/"},{"name":"csapp","slug":"csapp","permalink":"http://blog.zymatrix.top/tags/csapp/"}]}